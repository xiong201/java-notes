<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java 并发面试题</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/java-notes/img/favicon.ico">
    <meta name="description" content="知识管理">
    <meta name="keywords" content="vuepress,theme,blog,vdoing">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/java-notes/assets/css/0.styles.fb2e25c6.css" as="style"><link rel="preload" href="/java-notes/assets/js/app.d397b22c.js" as="script"><link rel="preload" href="/java-notes/assets/js/2.f70b3895.js" as="script"><link rel="preload" href="/java-notes/assets/js/58.b86ff1af.js" as="script"><link rel="prefetch" href="/java-notes/assets/js/10.2adfc515.js"><link rel="prefetch" href="/java-notes/assets/js/11.28dcb787.js"><link rel="prefetch" href="/java-notes/assets/js/12.2a292b61.js"><link rel="prefetch" href="/java-notes/assets/js/13.3f1dfbd4.js"><link rel="prefetch" href="/java-notes/assets/js/14.337236bc.js"><link rel="prefetch" href="/java-notes/assets/js/15.7637f176.js"><link rel="prefetch" href="/java-notes/assets/js/16.dc014ebd.js"><link rel="prefetch" href="/java-notes/assets/js/17.d0e4e790.js"><link rel="prefetch" href="/java-notes/assets/js/18.a5049df9.js"><link rel="prefetch" href="/java-notes/assets/js/19.346aa9f6.js"><link rel="prefetch" href="/java-notes/assets/js/20.ea34675a.js"><link rel="prefetch" href="/java-notes/assets/js/21.72feca8c.js"><link rel="prefetch" href="/java-notes/assets/js/22.5aa91d64.js"><link rel="prefetch" href="/java-notes/assets/js/23.f5dc3702.js"><link rel="prefetch" href="/java-notes/assets/js/24.ede98ecc.js"><link rel="prefetch" href="/java-notes/assets/js/25.96dad39b.js"><link rel="prefetch" href="/java-notes/assets/js/26.da17699a.js"><link rel="prefetch" href="/java-notes/assets/js/27.09d5fc3b.js"><link rel="prefetch" href="/java-notes/assets/js/28.d82616db.js"><link rel="prefetch" href="/java-notes/assets/js/29.e1686044.js"><link rel="prefetch" href="/java-notes/assets/js/3.68505a47.js"><link rel="prefetch" href="/java-notes/assets/js/30.86d62f2d.js"><link rel="prefetch" href="/java-notes/assets/js/31.8b9dad5a.js"><link rel="prefetch" href="/java-notes/assets/js/32.3588a7d0.js"><link rel="prefetch" href="/java-notes/assets/js/33.3dbbfd6b.js"><link rel="prefetch" href="/java-notes/assets/js/34.9adfa464.js"><link rel="prefetch" href="/java-notes/assets/js/35.a8146fb2.js"><link rel="prefetch" href="/java-notes/assets/js/36.4bbba0d8.js"><link rel="prefetch" href="/java-notes/assets/js/37.3d247b0f.js"><link rel="prefetch" href="/java-notes/assets/js/38.d0c2890b.js"><link rel="prefetch" href="/java-notes/assets/js/39.a1e26461.js"><link rel="prefetch" href="/java-notes/assets/js/4.79b93306.js"><link rel="prefetch" href="/java-notes/assets/js/40.33e37909.js"><link rel="prefetch" href="/java-notes/assets/js/41.b22b997f.js"><link rel="prefetch" href="/java-notes/assets/js/42.af86b93f.js"><link rel="prefetch" href="/java-notes/assets/js/43.c88942c6.js"><link rel="prefetch" href="/java-notes/assets/js/44.864ea6c7.js"><link rel="prefetch" href="/java-notes/assets/js/45.37e9acf1.js"><link rel="prefetch" href="/java-notes/assets/js/46.2a8ee5fe.js"><link rel="prefetch" href="/java-notes/assets/js/47.13102c5d.js"><link rel="prefetch" href="/java-notes/assets/js/48.5e02063f.js"><link rel="prefetch" href="/java-notes/assets/js/49.5902bf17.js"><link rel="prefetch" href="/java-notes/assets/js/5.d7e4c5f6.js"><link rel="prefetch" href="/java-notes/assets/js/50.5ed3edee.js"><link rel="prefetch" href="/java-notes/assets/js/51.7760a883.js"><link rel="prefetch" href="/java-notes/assets/js/52.f14b692e.js"><link rel="prefetch" href="/java-notes/assets/js/53.df43b82d.js"><link rel="prefetch" href="/java-notes/assets/js/54.391d2efe.js"><link rel="prefetch" href="/java-notes/assets/js/55.e1d64285.js"><link rel="prefetch" href="/java-notes/assets/js/56.12d3c417.js"><link rel="prefetch" href="/java-notes/assets/js/57.465c2ade.js"><link rel="prefetch" href="/java-notes/assets/js/59.a2969c73.js"><link rel="prefetch" href="/java-notes/assets/js/6.ad13b64c.js"><link rel="prefetch" href="/java-notes/assets/js/60.3970fce2.js"><link rel="prefetch" href="/java-notes/assets/js/61.69a94672.js"><link rel="prefetch" href="/java-notes/assets/js/62.94da23dc.js"><link rel="prefetch" href="/java-notes/assets/js/63.f2950404.js"><link rel="prefetch" href="/java-notes/assets/js/64.895ba847.js"><link rel="prefetch" href="/java-notes/assets/js/65.bb29c100.js"><link rel="prefetch" href="/java-notes/assets/js/66.70d3b479.js"><link rel="prefetch" href="/java-notes/assets/js/67.a242cece.js"><link rel="prefetch" href="/java-notes/assets/js/68.abd94893.js"><link rel="prefetch" href="/java-notes/assets/js/69.60cece2e.js"><link rel="prefetch" href="/java-notes/assets/js/7.8e50d771.js"><link rel="prefetch" href="/java-notes/assets/js/70.0b44f657.js"><link rel="prefetch" href="/java-notes/assets/js/71.c324bf57.js"><link rel="prefetch" href="/java-notes/assets/js/72.8aa10de8.js"><link rel="prefetch" href="/java-notes/assets/js/73.1e7220c4.js"><link rel="prefetch" href="/java-notes/assets/js/74.d1c0ce09.js"><link rel="prefetch" href="/java-notes/assets/js/75.42ffe6a2.js"><link rel="prefetch" href="/java-notes/assets/js/76.e92e283d.js"><link rel="prefetch" href="/java-notes/assets/js/77.0f7fadf2.js"><link rel="prefetch" href="/java-notes/assets/js/78.2a59eb91.js"><link rel="prefetch" href="/java-notes/assets/js/8.a2306c4b.js"><link rel="prefetch" href="/java-notes/assets/js/9.7e1ead44.js">
    <link rel="stylesheet" href="/java-notes/assets/css/0.styles.fb2e25c6.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/java-notes/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/java-notes/" class="nav-link">首页</a></div><div class="nav-item"><a href="/java-notes/pages/0e35d1/" class="nav-link">Java 知识体系</a></div><div class="nav-item"><a href="/java-notes/pages/5547aa/" class="nav-link">Java 面试宝典</a></div><div class="nav-item"><a href="/java-notes/pages/1eb629/" class="nav-link">软技能</a></div> <a href="https://github.com/xiong201" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/java-notes/" class="nav-link">首页</a></div><div class="nav-item"><a href="/java-notes/pages/0e35d1/" class="nav-link">Java 知识体系</a></div><div class="nav-item"><a href="/java-notes/pages/5547aa/" class="nav-link">Java 面试宝典</a></div><div class="nav-item"><a href="/java-notes/pages/1eb629/" class="nav-link">软技能</a></div> <a href="https://github.com/xiong201" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>面试准备</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java 八股文</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java-notes/pages/b4d599/" class="sidebar-link">Java 基础面试题</a></li><li><a href="/java-notes/pages/346648/" class="sidebar-link">Java 集合 面试题</a></li><li><a href="/java-notes/pages/f4f268/" aria-current="page" class="active sidebar-link">Java 并发面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#什么是线程和进程-线程与进程的关系-区别及优缺点" class="sidebar-link">什么是线程和进程？线程与进程的关系，区别及优缺点？</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#为什么要使用多线程呢" class="sidebar-link">为什么要使用多线程呢</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#说说线程的生命周期和状态" class="sidebar-link">说说线程的生命周期和状态</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level1"><a href="/java-notes/pages/f4f268/#java-中有哪些锁" class="sidebar-link">Java 中有哪些锁？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#什么是线程死锁-如何预防和避免线程死锁" class="sidebar-link">什么是线程死锁？如何预防和避免线程死锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level1"><a href="/java-notes/pages/f4f268/#乐观锁和悲观锁" class="sidebar-link">乐观锁和悲观锁</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#乐观锁和悲观锁的区别" class="sidebar-link">乐观锁和悲观锁的区别</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#如何实现乐观锁" class="sidebar-link">如何实现乐观锁</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#cas了解么-原理" class="sidebar-link">CAS了解么？原理？</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#乐观锁存在哪些问题" class="sidebar-link">乐观锁存在哪些问题</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#什么是aba问题-aba问题怎么解决" class="sidebar-link">什么是ABA问题？ABA问题怎么解决</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level1"><a href="/java-notes/pages/f4f268/#jmm" class="sidebar-link">JMM</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#并发编程的三个重要特性" class="sidebar-link">并发编程的三个重要特性</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#什么是jmm-为什么需要jmm" class="sidebar-link">什么是JMM？为什么需要JMM</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#jmm是如何抽象线程和主内存之间的关系" class="sidebar-link">JMM是如何抽象线程和主内存之间的关系？</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#java内存区域和jmm有何区别" class="sidebar-link">Java内存区域和JMM有何区别</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#happens-before原则是什么-为什么需要happens-before原则" class="sidebar-link">happens-before原则是什么？为什么需要happens-before原则</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level1"><a href="/java-notes/pages/f4f268/#synchronized-关键字" class="sidebar-link">synchronized 关键字</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#synchronized-关键字的作用-自己是怎么使用的。" class="sidebar-link">synchronized 关键字的作用，自己是怎么使用的。</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#synchronized-关键字的底层原理" class="sidebar-link">synchronized 关键字的底层原理</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#jdk1-6-之后-synchronized-关键字底层做了哪些优化。synchronized-锁升级流程。" class="sidebar-link">JDK1.6 之后 synchronized 关键字底层做了哪些优化。synchronized 锁升级流程。</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#synchronized-和-reentranlock-的区别" class="sidebar-link">synchronized 和 ReentranLock 的区别</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#synchronized-和-volatile-的区别" class="sidebar-link">synchronized 和 volatile 的区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level1"><a href="/java-notes/pages/f4f268/#volatile关键字" class="sidebar-link">volatile关键字</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#volatile-关键字如何保证变量的可见性" class="sidebar-link">volatile 关键字如何保证变量的可见性</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#volatile-如何禁止指令重排序" class="sidebar-link">volatile 如何禁止指令重排序</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#volatile-可以保证原子性么" class="sidebar-link">volatile 可以保证原子性么</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level1"><a href="/java-notes/pages/f4f268/#threadlocal" class="sidebar-link">ThreadLocal</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#threadlocal-有什么用" class="sidebar-link">ThreadLocal 有什么用</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#如何使用-threadlocal" class="sidebar-link">如何使用 ThreadLocal</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#threadlocal-原理了解吗" class="sidebar-link">ThreadLocal 原理了解吗</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#threadlocal-内存泄露问题是怎么导致的" class="sidebar-link">ThreadLocal 内存泄露问题是怎么导致的？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level1"><a href="/java-notes/pages/f4f268/#线程池" class="sidebar-link">线程池</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#什么是线程池" class="sidebar-link">什么是线程池</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#为什么要用线程池" class="sidebar-link">为什么要用线程池</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#如何创建线程池" class="sidebar-link">如何创建线程池</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#线程池常见参数有哪些-如何解释" class="sidebar-link">线程池常见参数有哪些？如何解释？</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#线程池的饱和策略有哪些" class="sidebar-link">线程池的饱和策略有哪些</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#线程池的执行流程" class="sidebar-link">线程池的执行流程</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#如何设定线程池的大小" class="sidebar-link">如何设定线程池的大小</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level1"><a href="/java-notes/pages/f4f268/#aqs" class="sidebar-link">AQS</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#aqs-是什么" class="sidebar-link">AQS 是什么？</a></li><li class="sidebar-sub-header level2"><a href="/java-notes/pages/f4f268/#aqs的原理是什么" class="sidebar-link">AQS的原理是什么</a></li></ul></li><li><a href="/java-notes/pages/89ee48/" class="sidebar-link">Java 新特性面试题</a></li><li><a href="/java-notes/pages/752c30/" class="sidebar-link">JVM 面试题</a></li><li><a href="/java-notes/pages/b23391/" class="sidebar-link">MySQL 面试题</a></li><li><a href="/java-notes/pages/b1ecc7/" class="sidebar-link">Redis 面试题</a></li><li><a href="/java-notes/pages/330962/" class="sidebar-link">Spring 面试题</a></li><li><a href="/java-notes/pages/e68641/" class="sidebar-link">Mybatis&amp;MybatisPlus 面试题</a></li><li><a href="/java-notes/pages/663a49/" class="sidebar-link">SpringBoot 面试题</a></li><li><a href="/java-notes/pages/3c9abe/" class="sidebar-link">SpringCloud 面试题</a></li><li><a href="/java-notes/pages/4a2429/" class="sidebar-link">SpringCloudAlibaba 面试题</a></li><li><a href="/java-notes/pages/0d16b1/" class="sidebar-link">分布式</a></li><li><a href="/java-notes/pages/d4abbd/" class="sidebar-link">Nginx 面试题</a></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/java-notes/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>Java 面试宝典</span></li><li data-v-06225672><span data-v-06225672>Java 八股文</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="javascript:;" data-v-06225672>Xiong</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-10-24</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">Java 并发面试题<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h1 id=""><a href="#" class="header-anchor">#</a></h1> <h1 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h1> <h2 id="什么是线程和进程-线程与进程的关系-区别及优缺点"><a href="#什么是线程和进程-线程与进程的关系-区别及优缺点" class="header-anchor">#</a> 什么是线程和进程？线程与进程的关系，区别及优缺点？</h2> <p>进程是程序的一次执行过程，是系统运行程序的基本单位。系统运行一个程序就是一个进程从创建，运行到消亡的过程。线程是一个进程更小的执行单位。一个进程在执行过程中可以产生多个线程。 多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。<br>
进程是独立的，而线程则不一定，因为同一进程中线程可能会相互影响。<strong>线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p> <h2 id="为什么要使用多线程呢"><a href="#为什么要使用多线程呢" class="header-anchor">#</a> 为什么要使用多线程呢</h2> <ul><li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li> <li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li></ul> <h2 id="说说线程的生命周期和状态"><a href="#说说线程的生命周期和状态" class="header-anchor">#</a> 说说线程的生命周期和状态</h2> <p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p> <ul><li><strong>NEW</strong>: 初始状态，线程被创建出来但没有被调用 start() 。</li> <li><strong>RUNNABLE</strong>: 运行状态，线程被调用了 start()等待运行的状态。</li> <li><strong>BLOCKED</strong> ：阻塞状态，需要等待锁释放。</li> <li><strong>WAITING</strong>：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li> <li><strong>TIME_WAITING</strong>：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li> <li><strong>TERMINATED</strong>：终止状态，表示该线程已经运行完毕。</li></ul> <p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p> <h1 id="java-中有哪些锁"><a href="#java-中有哪些锁" class="header-anchor">#</a> Java 中有哪些锁？</h1> <p>Java 中锁可以分：</p> <ul><li>悲观锁/乐观锁</li> <li>共享锁/独占锁</li> <li>公平锁/非公平锁</li> <li>可中断锁/非可中断锁</li> <li>可重入锁/不可重入锁</li> <li>自旋锁/非自旋锁</li></ul> <h2 id="什么是线程死锁-如何预防和避免线程死锁"><a href="#什么是线程死锁-如何预防和避免线程死锁" class="header-anchor">#</a> 什么是线程死锁？如何预防和避免线程死锁</h2> <p>线程死锁就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期阻塞，因此程序不能正常终止。</p> <p>产生死锁需要满足四个必要条件：</p> <ol><li><strong>互斥条件</strong>：该资源任意一个时刻只由一个线程占用。</li> <li><strong>请求与保持条件</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li> <li><strong>不剥夺条件</strong>:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li> <li><strong>循环等待条件</strong>:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol> <p>要避免线程死锁，只要破坏死锁产生的必要条件就可以：</p> <ol><li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li> <li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li> <li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol> <h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="header-anchor">#</a> 乐观锁和悲观锁</h1> <h2 id="乐观锁和悲观锁的区别"><a href="#乐观锁和悲观锁的区别" class="header-anchor">#</a> 乐观锁和悲观锁的区别</h2> <ul><li><strong>乐观锁通常用多于写比较少的情况下（多读场景），避免频繁加锁影响性能，大大提升了系统的吞吐量。</strong></li> <li><strong>悲观锁通常多用于写多比较多的情况下（多写场景），避免频繁失败和重试影响性能。</strong></li></ul> <h2 id="如何实现乐观锁"><a href="#如何实现乐观锁" class="header-anchor">#</a> 如何实现乐观锁</h2> <p>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些。</p> <h2 id="cas了解么-原理"><a href="#cas了解么-原理" class="header-anchor">#</a> CAS了解么？原理？</h2> <p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。
CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。
<strong>原子操作</strong> 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。
CAS 涉及到三个操作数：</p> <ul><li><strong>V</strong> ：要更新的变量值(Var)</li> <li><strong>E</strong> ：预期值(Expected)</li> <li><strong>N</strong> ：拟写入的新值(New)</li></ul> <p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。
<strong>举一个简单的例子</strong> ：线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6，假设不存在 ABA 问题）。</p> <ol><li>i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。</li> <li>i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。</li></ol> <p>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。
Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及 CPU 都有关系。</p> <h2 id="乐观锁存在哪些问题"><a href="#乐观锁存在哪些问题" class="header-anchor">#</a> 乐观锁存在哪些问题</h2> <ul><li><strong>ABA问题</strong>：一个变量V初始值是A，期间被改为其他值，然后又改回A，那么CAS操作就会误认为它从来没被修改过，这就是ABA问题。解决办法是在变量前面追加上版本号和时间戳。</li> <li><strong>循环时间长开销大</strong>： CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</li> <li><strong>只能保证一个共享变量的原子操作</strong>： CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</li></ul> <h2 id="什么是aba问题-aba问题怎么解决"><a href="#什么是aba问题-aba问题怎么解决" class="header-anchor">#</a> 什么是ABA问题？ABA问题怎么解决</h2> <p>ABA问题是乐观锁常见的问题。
如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>&quot;ABA&quot;问题。</strong>
ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong></p> <h1 id="jmm"><a href="#jmm" class="header-anchor">#</a> JMM</h1> <h2 id="并发编程的三个重要特性"><a href="#并发编程的三个重要特性" class="header-anchor">#</a> 并发编程的三个重要特性</h2> <ul><li><strong>原子性</strong>： 一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。  在 Java 中，可以借助<code>synchronized</code> 、各种 <code>Lock</code> 以及各种原子类实现原子性。<code>synchronized</code> 和各种 Lock 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 <code>volatile</code>或者<code>final</code>关键字）来保证原子操作。</li> <li><strong>可见性</strong>：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。在 Java 中，可以借助synchronized 、volatile 以及各种 Lock 实现可见性。如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</li> <li><strong>有序性</strong>：由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。<strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。  在 Java 中，volatile 关键字可以禁止指令进行重排序优化。</li></ul> <h2 id="什么是jmm-为什么需要jmm"><a href="#什么是jmm-为什么需要jmm" class="header-anchor">#</a> 什么是JMM？为什么需要JMM</h2> <p>JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。
<strong>为什么要遵守这些并发相关的原则和规范呢？</strong> 这是因为并发编程下，像 CPU 多级缓存和指令重排这类设计可能会导致程序运行出现一些问题。就比如说我们上面提到的指令重排序就可能会让多线程程序的执行出现问题，为此，JMM 抽象了 happens-before 原则来解决这个指令重排序问题。
JMM 说白了就是定义了一些规范来解决这些问题，开发者可以利用这些规范更方便地开发多线程程序。对于 Java 开发者说，你不需要了解底层原理，直接使用并发相关的一些关键字和类（比如 volatile、synchronized、各种 Lock）即可开发出并发安全的程序。</p> <h2 id="jmm是如何抽象线程和主内存之间的关系"><a href="#jmm是如何抽象线程和主内存之间的关系" class="header-anchor">#</a> JMM是如何抽象线程和主内存之间的关系？</h2> <p><strong>Java 内存模型（JMM）</strong> 抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中， 为共享变量提供了可见性的保障 。</p> <h2 id="java内存区域和jmm有何区别"><a href="#java内存区域和jmm有何区别" class="header-anchor">#</a> Java内存区域和JMM有何区别</h2> <p><strong>Java 内存区域和内存模型是完全不一样的两个东西</strong> ：</p> <ul><li>JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。</li> <li>Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li></ul> <h2 id="happens-before原则是什么-为什么需要happens-before原则"><a href="#happens-before原则是什么-为什么需要happens-before原则" class="header-anchor">#</a> happens-before原则是什么？为什么需要happens-before原则</h2> <p><strong>逻辑时钟并不度量时间本身，仅区分事件发生的前后顺序，其本质就是定义了一种 happens-before 关系。</strong>
happens-before 原则的诞生是为了程序员和编译器、处理器之间的平衡。程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可。编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化。</p> <h1 id="synchronized-关键字"><a href="#synchronized-关键字" class="header-anchor">#</a> synchronized 关键字</h1> <h2 id="synchronized-关键字的作用-自己是怎么使用的。"><a href="#synchronized-关键字的作用-自己是怎么使用的。" class="header-anchor">#</a> synchronized 关键字的作用，自己是怎么使用的。</h2> <p><code>synchronized</code>是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。
在 Java 早期版本中，<code>synchronized</code>属于 <strong>重量级锁</strong>，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。
不过，在 Java 6 之后， <code>synchronized</code>引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。因此， <code>synchronized</code> 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 <code>synchronized</code></p> <h2 id="synchronized-关键字的底层原理"><a href="#synchronized-关键字的底层原理" class="header-anchor">#</a> synchronized 关键字的底层原理</h2> <p>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。
synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。
<strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p> <h2 id="jdk1-6-之后-synchronized-关键字底层做了哪些优化。synchronized-锁升级流程。"><a href="#jdk1-6-之后-synchronized-关键字底层做了哪些优化。synchronized-锁升级流程。" class="header-anchor">#</a> JDK1.6 之后 synchronized 关键字底层做了哪些优化。synchronized 锁升级流程。</h2> <p>DK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。
锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p> <blockquote><p>参考：<a href="https://www.cnblogs.com/wuqinglong/p/9945618.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/wuqinglong/p/9945618.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="synchronized-和-reentranlock-的区别"><a href="#synchronized-和-reentranlock-的区别" class="header-anchor">#</a> synchronized 和 ReentranLock 的区别</h2> <ul><li><strong>synchronized 依赖于 JVM 实现的</strong>，在 JDK1.6 对 synchronized 关键字进行了很多优化，但是这些优化都是基于虚拟机层面实现的。</li></ul> <p><strong>ReentrantLock 是 JDK 实现的</strong>，查看源码，可以看到底层是通过lock() 和 unlock() 方法配合 try/finally 语句块来完成</p> <ul><li>ReentrantLock 支持中断等待锁的机制，而 synchronized 不支持</li> <li>ReentrantLock 支持公平锁和非公平锁，默认是非公平锁，synchronized 只能是非公平锁。</li></ul> <h2 id="synchronized-和-volatile-的区别"><a href="#synchronized-和-volatile-的区别" class="header-anchor">#</a> synchronized 和 volatile 的区别</h2> <p>synchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在！</p> <ul><li>volatile 关键字是线程同步的轻量级实现，所以 volatile性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。</li> <li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</li> <li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</li></ul> <h1 id="volatile关键字"><a href="#volatile关键字" class="header-anchor">#</a> volatile关键字</h1> <h2 id="volatile-关键字如何保证变量的可见性"><a href="#volatile-关键字如何保证变量的可见性" class="header-anchor">#</a> volatile 关键字如何保证变量的可见性</h2> <p>在 Java 中，volatile 关键字可以保证变量的可见性，如果我们将变量声明为 <strong>volatile</strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。<br>
volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。
<img src="https://cdn.nlark.com/yuque/0/2023/png/21516648/1676872581269-a764b630-98d5-4204-b8b1-9cfe73672812.png#averageHue=%23dcbf77&amp;clientId=u610db969-cba4-4&amp;from=paste&amp;height=567&amp;id=uebed9c13&amp;originHeight=850&amp;originWidth=983&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=102522&amp;status=done&amp;style=none&amp;taskId=u18f74dbd-5308-4b5d-b8fa-0f46396e38e&amp;title=&amp;width=655.3333333333334" alt="image.png"></p> <h2 id="volatile-如何禁止指令重排序"><a href="#volatile-如何禁止指令重排序" class="header-anchor">#</a> volatile 如何禁止指令重排序</h2> <p><strong>在 Java 中，volatile 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。</strong> 如果我们将变量声明为 <strong>volatile</strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。
在 Java 中，Unsafe 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">loadFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">storeFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">fullFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="volatile-可以保证原子性么"><a href="#volatile-可以保证原子性么" class="header-anchor">#</a> volatile 可以保证原子性么</h2> <p><strong>volatile 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</strong></p> <h1 id="threadlocal"><a href="#threadlocal" class="header-anchor">#</a> ThreadLocal</h1> <h2 id="threadlocal-有什么用"><a href="#threadlocal-有什么用" class="header-anchor">#</a> ThreadLocal 有什么用</h2> <p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong>
JDK 中自带的ThreadLocal类正是为了解决这样的问题。 <strong>ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong>
如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。
再举个简单的例子：两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。</p> <h2 id="如何使用-threadlocal"><a href="#如何使用-threadlocal" class="header-anchor">#</a> 如何使用 ThreadLocal</h2> <p>下面简单演示一下如何在项目中实际使用 ThreadLocal 。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>text<span class="token punctuation">.</span></span><span class="token class-name">SimpleDateFormat</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalExample</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>

     <span class="token comment">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SimpleDateFormat</span><span class="token punctuation">&gt;</span></span> formatter <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">&quot;yyyyMMdd HHmm&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">ThreadLocalExample</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Thread Name= &quot;</span><span class="token operator">+</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">&quot; default Formatter = &quot;</span><span class="token operator">+</span>formatter<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//formatter pattern is changed here by thread, but it won't reflect to other threads</span>
        formatter<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Thread Name= &quot;</span><span class="token operator">+</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">&quot; formatter = &quot;</span><span class="token operator">+</span>formatter<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>


</code></pre></div><p>输出结果：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">default</span> <span class="token class-name">Formatter</span> <span class="token operator">=</span> yyyyMMdd <span class="token class-name">HHmm</span>
<span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">0</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span><span class="token class-name">M</span><span class="token operator">-</span>d ah<span class="token operator">:</span>mm
<span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">default</span> <span class="token class-name">Formatter</span> <span class="token operator">=</span> yyyyMMdd <span class="token class-name">HHmm</span>
<span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">default</span> <span class="token class-name">Formatter</span> <span class="token operator">=</span> yyyyMMdd <span class="token class-name">HHmm</span>
<span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">1</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span><span class="token class-name">M</span><span class="token operator">-</span>d ah<span class="token operator">:</span>mm
<span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">3</span> <span class="token keyword">default</span> <span class="token class-name">Formatter</span> <span class="token operator">=</span> yyyyMMdd <span class="token class-name">HHmm</span>
<span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">2</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span><span class="token class-name">M</span><span class="token operator">-</span>d ah<span class="token operator">:</span>mm
<span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">4</span> <span class="token keyword">default</span> <span class="token class-name">Formatter</span> <span class="token operator">=</span> yyyyMMdd <span class="token class-name">HHmm</span>
<span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">3</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span><span class="token class-name">M</span><span class="token operator">-</span>d ah<span class="token operator">:</span>mm
<span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">4</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span><span class="token class-name">M</span><span class="token operator">-</span>d ah<span class="token operator">:</span>mm
<span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">5</span> <span class="token keyword">default</span> <span class="token class-name">Formatter</span> <span class="token operator">=</span> yyyyMMdd <span class="token class-name">HHmm</span>
<span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">5</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span><span class="token class-name">M</span><span class="token operator">-</span>d ah<span class="token operator">:</span>mm
<span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">6</span> <span class="token keyword">default</span> <span class="token class-name">Formatter</span> <span class="token operator">=</span> yyyyMMdd <span class="token class-name">HHmm</span>
<span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">6</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span><span class="token class-name">M</span><span class="token operator">-</span>d ah<span class="token operator">:</span>mm
<span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">7</span> <span class="token keyword">default</span> <span class="token class-name">Formatter</span> <span class="token operator">=</span> yyyyMMdd <span class="token class-name">HHmm</span>
<span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">7</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span><span class="token class-name">M</span><span class="token operator">-</span>d ah<span class="token operator">:</span>mm
<span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">8</span> <span class="token keyword">default</span> <span class="token class-name">Formatter</span> <span class="token operator">=</span> yyyyMMdd <span class="token class-name">HHmm</span>
<span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">9</span> <span class="token keyword">default</span> <span class="token class-name">Formatter</span> <span class="token operator">=</span> yyyyMMdd <span class="token class-name">HHmm</span>
<span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">8</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span><span class="token class-name">M</span><span class="token operator">-</span>d ah<span class="token operator">:</span>mm
<span class="token class-name">Thread</span> <span class="token class-name">Name</span><span class="token operator">=</span> <span class="token number">9</span> formatter <span class="token operator">=</span> yy<span class="token operator">-</span><span class="token class-name">M</span><span class="token operator">-</span>d ah<span class="token operator">:</span>mm

</code></pre></div><p>从输出中可以看出，虽然 Thread-0 已经改变了 formatter 的值，但 Thread-1 默认格式化值与初始化值相同，其他线程也一样。</p> <h2 id="threadlocal-原理了解吗"><a href="#threadlocal-原理了解吗" class="header-anchor">#</a> ThreadLocal 原理了解吗</h2> <p>从 Thread类源代码入手。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token comment">//......</span>
    <span class="token comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span>
    <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> threadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span>
    <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> inheritableThreadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">//......</span>
<span class="token punctuation">}</span>

</code></pre></div><p>从上面Thread类 源代码可以看出Thread 类中有一个 threadLocals 和 一个 inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量,我们可以把 ThreadLocalMap 理解为ThreadLocal 类实现的定制化的 HashMap。默认情况下这两个变量都是 null，只有当前线程调用 ThreadLocal 类的 set或get方法时才创建它们，实际上调用这两个方法的时候，我们调用的是ThreadLocalMap类对应的 get()、set()方法。
ThreadLocal类的set()方法</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//获取当前请求的线程</span>
    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span>
    <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token comment">// 将需要存储的值放入到这个哈希表中</span>
        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">ThreadLocalMap</span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> t<span class="token punctuation">.</span>threadLocals<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>通过上面这些内容，我们足以通过猜测得出结论：**最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。**ThrealLocal 类中可以通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread t)可以访问到该线程的ThreadLocalMap对象。
<strong>每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> firstKey<span class="token punctuation">,</span> <span class="token class-name">Object</span> firstValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//......</span>
<span class="token punctuation">}</span>

</code></pre></div><p>比如我们在同一个线程中声明了两个 ThreadLocal 对象的话， Thread内部都是使用仅有的那个ThreadLocalMap 存放数据的，ThreadLocalMap的 key 就是 ThreadLocal对象，value 就是 ThreadLocal 对象调用set方法设置的值。
ThreadLocal 数据结构如下图所示：
<img src="https://cdn.nlark.com/yuque/0/2023/png/21516648/1676873578331-55fd505c-18b2-46e2-ba15-7abbd567dd45.png#averageHue=%23fae1c5&amp;clientId=u610db969-cba4-4&amp;from=paste&amp;height=435&amp;id=u64462da0&amp;originHeight=653&amp;originWidth=936&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=60123&amp;status=done&amp;style=none&amp;taskId=u6d9bfe07-fe99-4aa0-8bcc-76729509e3a&amp;title=&amp;width=624" alt="image.png"></p> <h2 id="threadlocal-内存泄露问题是怎么导致的"><a href="#threadlocal-内存泄露问题是怎么导致的" class="header-anchor">#</a> ThreadLocal 内存泄露问题是怎么导致的？</h2> <p><strong>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉</strong>。
这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。<strong>使用完 ThreadLocal方法后 最好手动调用remove()方法</strong></p> <h1 id="线程池"><a href="#线程池" class="header-anchor">#</a> 线程池</h1> <h2 id="什么是线程池"><a href="#什么是线程池" class="header-anchor">#</a> 什么是线程池</h2> <p>顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p> <h2 id="为什么要用线程池"><a href="#为什么要用线程池" class="header-anchor">#</a> 为什么要用线程池</h2> <p>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。
<strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。
<strong>使用线程池的好处</strong>：</p> <ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li> <li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li> <li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul> <h2 id="如何创建线程池"><a href="#如何创建线程池" class="header-anchor">#</a> 如何创建线程池</h2> <p><strong>方式一：通过</strong><code>**ThreadPoolExecutor**</code><strong>构造函数来创建（推荐）。</strong> <img src="https://cdn.nlark.com/yuque/0/2023/png/21516648/1676874278279-81ffe8ab-0b83-43fe-9a60-9df2180f0c46.png#averageHue=%23eeedce&amp;clientId=u610db969-cba4-4&amp;from=paste&amp;height=180&amp;id=u7ce38790&amp;originHeight=270&amp;originWidth=1424&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=282687&amp;status=done&amp;style=none&amp;taskId=ue26f2bbd-f368-488b-8bff-3d5489617f7&amp;title=&amp;width=949.3333333333334" alt="image.png"></p> <p><strong>方式二：通过 <strong><code>**Executor**</code></strong> 框架的工具类 <strong><code>**Executors**</code></strong> 来创建。</strong></p> <p>我们可以创建多种类型的 ThreadPoolExecutor：</p> <ul><li><strong>FixedThreadPool</strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li> <li><strong>SingleThreadExecutor：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li> <li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li> <li><strong>ScheduledThreadPool</strong> ：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li></ul> <p>对应 Executors 工具类中的方法如图所示：
<img src="https://cdn.nlark.com/yuque/0/2023/png/21516648/1676874364107-52f18721-835e-496c-9e08-b8ce5858c526.png#averageHue=%232f353c&amp;clientId=u610db969-cba4-4&amp;from=paste&amp;height=438&amp;id=u92822543&amp;originHeight=657&amp;originWidth=942&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=348982&amp;status=done&amp;style=none&amp;taskId=ucd368b13-e203-4cf6-977b-e204aa6ff2f&amp;title=&amp;width=628" alt="image.png"></p> <h2 id="线程池常见参数有哪些-如何解释"><a href="#线程池常见参数有哪些-如何解释" class="header-anchor">#</a> 线程池常见参数有哪些？如何解释？</h2> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token comment">/**
     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token comment">//线程池的核心线程数量</span>
                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token comment">//线程池的最大线程数</span>
                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span><span class="token comment">//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span>
                              <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span><span class="token comment">//时间单位</span>
                              <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span><span class="token comment">//任务队列，用来储存等待执行任务的队列</span>
                              <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span><span class="token comment">//线程工厂，用来创建线程，一般默认即可</span>
                              <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token comment">//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span>
                               <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>
            maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>
            maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>
            keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> threadFactory <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> handler <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

</code></pre></div><p><strong>ThreadPoolExecutor 3 个最重要的参数：</strong></p> <ul><li><strong>corePoolSize :</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li> <li><strong>maximumPoolSize :</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li> <li><strong>workQueue:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul> <p>ThreadPoolExecutor其他常见参数 :</p> <ul><li><strong>keepAliveTime</strong>:线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</li> <li><strong>unit</strong> : keepAliveTime 参数的时间单位。</li> <li><strong>threadFactory</strong> :executor 创建新线程的时候会用到。</li> <li><strong>handler</strong> :饱和策略。关于饱和策略下面单独介绍一下。</li></ul> <h2 id="线程池的饱和策略有哪些"><a href="#线程池的饱和策略有哪些" class="header-anchor">#</a> 线程池的饱和策略有哪些</h2> <p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，ThreadPoolTaskExecutor 定义一些策略:</p> <ul><li><strong>ThreadPoolExecutor.AbortPolicy：</strong> 抛出 RejectedExecutionException来拒绝新任务的处理。</li> <li><strong>ThreadPoolExecutor.CallerRunsPolicy：</strong> 调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li> <li><strong>ThreadPoolExecutor.DiscardPolicy：</strong> 不处理新任务，直接丢弃掉。</li> <li><strong>ThreadPoolExecutor.DiscardOldestPolicy：</strong> 此策略将丢弃最早的未处理的任务请求。</li></ul> <p>举个例子： Spring 通过 ThreadPoolTaskExecutor 或者我们直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，当我们不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 ThreadPoolExecutor 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）</p> <h2 id="线程池的执行流程"><a href="#线程池的执行流程" class="header-anchor">#</a> 线程池的执行流程</h2> <p><img src="https://cdn.nlark.com/yuque/0/2023/png/21516648/1676874843825-a0980bca-d45d-4756-a1e0-067e3592de7e.png#averageHue=%23fefefe&amp;clientId=u610db969-cba4-4&amp;from=paste&amp;height=270&amp;id=u25d20957&amp;originHeight=405&amp;originWidth=972&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=49122&amp;status=done&amp;style=none&amp;taskId=u334d202c-4afb-4d91-b6a6-13c0c189c27&amp;title=&amp;width=648" alt="image.png"></p> <ol><li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li> <li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li> <li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li> <li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ol> <h2 id="如何设定线程池的大小"><a href="#如何设定线程池的大小" class="header-anchor">#</a> 如何设定线程池的大小</h2> <p>线程池大小设置过大或者过小都会有问题，合适的才是最好。</p> <ul><li>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的，CPU 根本没有得到充分利用。</li> <li>如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</li></ul> <p>有一个简单并且适用面比较广的公式：</p> <ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li> <li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul> <h1 id="aqs"><a href="#aqs" class="header-anchor">#</a> AQS</h1> <h2 id="aqs-是什么"><a href="#aqs-是什么" class="header-anchor">#</a> AQS 是什么？</h2> <p>AQS 的全称为 AbstractQueuedSynchronizer ，翻译过来的意思就是抽象队列同步器。这个类在 java.util.concurrent.locks 包下面。<br> <img src="https://cdn.nlark.com/yuque/0/2023/png/21516648/1676877363270-595a5429-4127-4933-97b5-0009088be828.png#averageHue=%23fbf6f4&amp;clientId=u610db969-cba4-4&amp;from=paste&amp;height=356&amp;id=ud31264f8&amp;originHeight=534&amp;originWidth=519&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=100495&amp;status=done&amp;style=none&amp;taskId=ue57e7c8c-667e-416f-9d21-bc287afe97a&amp;title=&amp;width=346" alt="image.png">
AQS 就是一个抽象类，主要用来构建锁和同步器</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractOwnableSynchronizer</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

</code></pre></div><p>AQS 为构建锁和同步器提供了一些通用功能的是实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue等等皆是基于 AQS 的。</p> <h2 id="aqs的原理是什么"><a href="#aqs的原理是什么" class="header-anchor">#</a> AQS的原理是什么</h2> <p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong> 实现的，即将暂时获取不到锁的线程加入到队列中。</p></div></div> <!----> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023/11/14, 06:07:31</span></div></div> <div class="page-nav-wapper"><!----> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/java-notes/pages/346648/" class="prev">Java 集合 面试题</a></span> <span class="next"><a href="/java-notes/pages/89ee48/">Java 新特性面试题</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><!----> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2023-2023
    <span>xiong201 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/java-notes/assets/js/app.d397b22c.js" defer></script><script src="/java-notes/assets/js/2.f70b3895.js" defer></script><script src="/java-notes/assets/js/58.b86ff1af.js" defer></script>
  </body>
</html>
