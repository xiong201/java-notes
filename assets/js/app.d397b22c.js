(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var a,o,l=e[0],s=e[1],c=e[2],u=0,p=[];u<l.length;u++)o=l[u],Object.prototype.hasOwnProperty.call(r,o)&&r[o]&&p.push(r[o][0]),r[o]=0;for(a in s)Object.prototype.hasOwnProperty.call(s,a)&&(n[a]=s[a]);for(d&&d(e);p.length;)p.shift()();return i.push.apply(i,c||[]),t()}function t(){for(var n,e=0;e<i.length;e++){for(var t=i[e],a=!0,l=1;l<t.length;l++){var s=t[l];0!==r[s]&&(a=!1)}a&&(i.splice(e--,1),n=o(o.s=t[0]))}return n}var a={},r={1:0},i=[];function o(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var a=new Promise((function(e,a){t=r[n]=[e,a]}));e.push(t[2]=a);var i,l=document.createElement("script");l.charset="utf-8",l.timeout=120,o.nc&&l.setAttribute("nonce",o.nc),l.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"f70b3895",3:"68505a47",4:"79b93306",5:"d7e4c5f6",6:"ad13b64c",7:"8e50d771",8:"a2306c4b",9:"7e1ead44",10:"2adfc515",11:"28dcb787",12:"2a292b61",13:"3f1dfbd4",14:"337236bc",15:"7637f176",16:"dc014ebd",17:"d0e4e790",18:"a5049df9",19:"346aa9f6",20:"ea34675a",21:"72feca8c",22:"5aa91d64",23:"f5dc3702",24:"ede98ecc",25:"96dad39b",26:"da17699a",27:"09d5fc3b",28:"d82616db",29:"e1686044",30:"86d62f2d",31:"8b9dad5a",32:"3588a7d0",33:"3dbbfd6b",34:"9adfa464",35:"a8146fb2",36:"4bbba0d8",37:"3d247b0f",38:"d0c2890b",39:"a1e26461",40:"33e37909",41:"b22b997f",42:"af86b93f",43:"c88942c6",44:"864ea6c7",45:"37e9acf1",46:"2a8ee5fe",47:"13102c5d",48:"5e02063f",49:"5902bf17",50:"5ed3edee",51:"7760a883",52:"f14b692e",53:"df43b82d",54:"391d2efe",55:"e1d64285",56:"12d3c417",57:"465c2ade",58:"b86ff1af",59:"a2969c73",60:"3970fce2",61:"69a94672",62:"94da23dc",63:"f2950404",64:"895ba847",65:"bb29c100",66:"70d3b479",67:"a242cece",68:"abd94893",69:"60cece2e",70:"0b44f657",71:"c324bf57",72:"8aa10de8",73:"1e7220c4",74:"d1c0ce09",75:"42ffe6a2",76:"e92e283d",77:"0f7fadf2",78:"2a59eb91"}[n]+".js"}(n);var s=new Error;i=function(e){l.onerror=l.onload=null,clearTimeout(c);var t=r[n];if(0!==t){if(t){var a=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;s.message="Loading chunk "+n+" failed.\n("+a+": "+i+")",s.name="ChunkLoadError",s.type=a,s.request=i,t[1](s)}r[n]=void 0}};var c=setTimeout((function(){i({type:"timeout",target:l})}),12e4);l.onerror=l.onload=i,document.head.appendChild(l)}return Promise.all(e)},o.m=n,o.c=a,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)o.d(t,a,function(e){return n[e]}.bind(null,a));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/java-notes/",o.oe=function(n){throw console.error(n),n};var l=window.webpackJsonp=window.webpackJsonp||[],s=l.push.bind(l);l.push=e,l=l.slice();for(var c=0;c<l.length;c++)e(l[c]);var d=s;i.push([106,0]),t()}([function(n,e,t){"use strict";var a=t(55),r=a.all;n.exports=a.IS_HTMLDDA?function(n){return"function"==typeof n||n===r}:function(n){return"function"==typeof n}},function(n,e,t){"use strict";var a=function(n){return n&&n.Math===Math&&n};n.exports=a("object"==typeof globalThis&&globalThis)||a("object"==typeof window&&window)||a("object"==typeof self&&self)||a("object"==typeof global&&global)||function(){return this}()||this||Function("return this")()},function(n,e,t){"use strict";var a=t(27),r=Function.prototype,i=r.call,o=a&&r.bind.bind(i,i);n.exports=a?o:function(n){return function(){return i.apply(n,arguments)}}},function(n,e,t){"use strict";n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";var a=t(3);n.exports=!a((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var a=t(69),r="object"==typeof self&&self&&self.Object===Object&&self,i=a||r||Function("return this")();n.exports=i},function(n,e,t){"use strict";function a(n,e,t,a,r,i,o,l){var s,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),a&&(c.functional=!0),i&&(c._scopeId="data-v-"+i),o?(s=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},c._ssrRegister=s):r&&(s=l?function(){r.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:r),s)if(c.functional){c._injectStyles=s;var d=c.render;c.render=function(n,e){return s.call(e),d(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,s):[s]}return{exports:n,options:c}}t.d(e,"a",(function(){return a}))},function(n,e,t){"use strict";var a=t(2),r=t(32),i=a({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return i(r(n),e)}},function(n,e,t){"use strict";var a=t(0),r=t(55),i=r.all;n.exports=r.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:a(n)||n===i}:function(n){return"object"==typeof n?null!==n:a(n)}},function(n,e,t){var a=t(164),r=t(167);n.exports=function(n,e){var t=r(n,e);return a(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return a})),t.d(e,"b",(function(){return i})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return s})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return x}));t(16);const a=/#.*$/,r=/\.(md|html)$/,i=/\/$/,o=/^[a-z]+:/i;function l(n){return decodeURI(n).replace(a,"").replace(r,"")}function s(n){return o.test(n)}function c(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function u(n){if(s(n))return n;if(!n)return"404";const e=n.match(a),t=e?e[0]:"",r=l(n);return i.test(r)?n:r+".html"+t}function p(n,e){const t=n.hash,r=function(n){const e=n&&n.match(a);if(e)return e[0]}(e);if(r&&t!==r)return!1;return l(n.path)===l(e)}function m(n,e,t){if(s(e))return{type:"external",path:e};t&&(e=function(n,e,t){const a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;const r=e.split("/");t&&r[r.length-1]||r.pop();const i=n.replace(/^\//,"").split("/");for(let n=0;n<i.length;n++){const e=i[n];".."===e?r.pop():"."!==e&&r.push(e)}""!==r[0]&&r.unshift("");return r.join("/")}(e,t));const a=l(e);for(let e=0;e<n.length;e++)if(l(n[e].regularPath)===a)return Object.assign({},n[e],{type:"page",path:u(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,a){const{pages:r,themeConfig:i}=t,o=a&&i.locales&&i.locales[a]||i;if("auto"===(n.frontmatter.sidebar||o.sidebar||i.sidebar))return f(n);const l=o.sidebar||i.sidebar;if(l){const{base:t,config:a}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const a in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(a)))return{base:a,config:e[a]};var t;return{}}(e,l);return"auto"===a?f(n):a?a.map(n=>function n(e,t,a,r=1){if("string"==typeof e)return m(t,e,a);if(Array.isArray(e))return Object.assign(m(t,e[0],a),{title:e[1]});{r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const i=e.children||[];return 0===i.length&&e.path?Object.assign(m(t,e.path,a),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:i.map(e=>n(e,t,a,r+1)),collapsable:!1!==e.collapsable}}}(n,r,t)):[]}return[]}function f(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return y(e)-y(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var a=t(15),r=t(149),i=t(150),o=a?a.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?r(n):i(n)}},function(n,e,t){"use strict";var a=t(4),r=t(17),i=t(35);n.exports=a?function(n,e,t){return r.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var a=t(6).Symbol;n.exports=a},function(n,e,t){"use strict";var a=t(26),r=t(32),i=t(33),o=t(129),l=t(131);a({target:"Array",proto:!0,arity:1,forced:t(3)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=r(this),t=i(e),a=arguments.length;l(t+a);for(var s=0;s<a;s++)e[t]=arguments[s],t++;return o(e,t),t}})},function(n,e,t){"use strict";var a=t(4),r=t(64),i=t(101),o=t(25),l=t(54),s=TypeError,c=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=a?i?function(n,e,t){if(o(n),e=l(e),o(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var a=d(n,e);a&&a.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(o(n),e=l(e),o(t),r)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw new s("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){"use strict";var a=t(2),r=a({}.toString),i=a("".slice);n.exports=function(n){return i(r(n),8,-1)}},function(n,e,t){var a=t(154),r=t(155),i=t(156),o=t(157),l=t(158);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}s.prototype.clear=a,s.prototype.delete=r,s.prototype.get=i,s.prototype.has=o,s.prototype.set=l,n.exports=s},function(n,e,t){var a=t(71);n.exports=function(n,e){for(var t=n.length;t--;)if(a(n[t][0],e))return t;return-1}},function(n,e,t){var a=t(10)(Object,"create");n.exports=a},function(n,e,t){var a=t(176);n.exports=function(n,e){var t=n.__data__;return a(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var a=t(45);n.exports=function(n){if("string"==typeof n||a(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var a,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(a=function(){var n,e,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function i(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(a[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,a.minimum,1),t.status=1===n?null:n;var s=t.render(!e),c=s.querySelector(a.barSelector),d=a.speed,u=a.easing;return s.offsetWidth,o((function(e){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),l(c,function(n,e,t){var r;return(r="translate3d"===a.positionUsing?{transform:"translate3d("+i(n)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+i(n)+"%,0)"}:{"margin-left":i(n)+"%"}).transition="all "+e+"ms "+t,r}(n,d,u)),1===n?(l(s,{transition:"none",opacity:1}),s.offsetWidth,setTimeout((function(){l(s,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),a.trickleSpeed)};return a.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},n=0,e=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===e&&t.start(),n++,e++,a.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=a.template;var r,o=e.querySelector(a.barSelector),s=n?"-100":i(t.status||0),d=document.querySelector(a.parent);return l(o,{transition:"all 0 linear",transform:"translate3d("+s+"%,0,0)"}),a.showSpinner||(r=e.querySelector(a.spinnerSelector))&&p(r),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(a.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),l=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var a,r=n.length,i=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((a=n[r]+i)in t)return a;return e}(t))}function a(n,e,a){e=t(e),n.style[e]=a}return function(n,e){var t,r,i=arguments;if(2==i.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&a(n,t,r);else a(n,i[1],i[2])}}();function s(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),a=t+e;s(t,e)||(n.className=a.substring(1))}function d(n,e){var t,a=u(n);s(n,e)&&(t=a.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?a.call(e,t,e,n):a)||(n.exports=r)},function(n,e,t){"use strict";var a=t(9),r=String,i=TypeError;n.exports=function(n){if(a(n))return n;throw new i(r(n)+" is not an object")}},function(n,e,t){"use strict";var a=t(1),r=t(51).f,i=t(14),o=t(97),l=t(37),s=t(65),c=t(125);n.exports=function(n,e){var t,d,u,p,m,h=n.target,f=n.global,g=n.stat;if(t=f?a:g?a[h]||l(h,{}):(a[h]||{}).prototype)for(d in e){if(p=e[d],u=n.dontCallGetSet?(m=r(t,d))&&m.value:t[d],!c(f?d:h+(g?".":"#")+d,n.forced)&&void 0!==u){if(typeof p==typeof u)continue;s(p,u)}(n.sham||u&&u.sham)&&i(p,"sham",!0),o(t,d,p,n)}}},function(n,e,t){"use strict";var a=t(3);n.exports=!a((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){"use strict";var a=t(47),r=t(52);n.exports=function(n){return a(r(n))}},function(n,e,t){"use strict";var a=t(1),r=t(0),i=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?i(a[n]):a[n]&&a[n][e]}},function(n,e,t){"use strict";var a=t(0),r=t(112),i=TypeError;n.exports=function(n){if(a(n))return n;throw new i(r(n)+" is not a function")}},function(n,e,t){"use strict";var a=t(1),r=t(61),i=t(8),o=t(63),l=t(59),s=t(58),c=a.Symbol,d=r("wks"),u=s?c.for||c:c&&c.withoutSetter||o;n.exports=function(n){return i(d,n)||(d[n]=l&&i(c,n)?c[n]:u("Symbol."+n)),d[n]}},function(n,e,t){"use strict";var a=t(52),r=Object;n.exports=function(n){return r(a(n))}},function(n,e,t){"use strict";var a=t(123);n.exports=function(n){return a(n.length)}},function(n,e,t){"use strict";var a=t(27),r=Function.prototype.call;n.exports=a?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e,t){"use strict";n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){"use strict";var a=t(1),r=t(37),i=a["__core-js_shared__"]||r("__core-js_shared__",{});n.exports=i},function(n,e,t){"use strict";var a=t(1),r=Object.defineProperty;n.exports=function(n,e){try{r(a,n,{value:e,configurable:!0,writable:!0})}catch(t){a[n]=e}return e}},function(n,e,t){var a=t(148),r=t(12),i=Object.prototype,o=i.hasOwnProperty,l=i.propertyIsEnumerable,s=a(function(){return arguments}())?a:function(n){return r(n)&&o.call(n,"callee")&&!l.call(n,"callee")};n.exports=s},function(n,e,t){var a=t(10)(t(6),"Map");n.exports=a},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var a=t(168),r=t(175),i=t(177),o=t(178),l=t(179);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}s.prototype.clear=a,s.prototype.delete=r,s.prototype.get=i,s.prototype.has=o,s.prototype.set=l,n.exports=s},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var a=t(5),r=t(45),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!r(n))||(o.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var a=t(13),r=t(12);n.exports=function(n){return"symbol"==typeof n||r(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";var a=t(2),r=t(3),i=t(18),o=Object,l=a("".split);n.exports=r((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"===i(n)?l(n,""):o(n)}:o},function(n,e,t){"use strict";n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,i=/^0o[0-7]+$/i,o=parseInt,l="object"==typeof global&&global&&global.Object===Object&&global,s="object"==typeof self&&self&&self.Object===Object&&self,c=l||s||Function("return this")(),d=Object.prototype.toString,u=Math.max,p=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var l=r.test(n);return l||i.test(n)?o(n.slice(2),l?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var a,r,i,o,l,s,c=0,d=!1,g=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=a,i=r;return a=r=void 0,c=e,o=n.apply(i,t)}function y(n){return c=n,l=setTimeout(E,e),d?b(n):o}function x(n){var t=n-s;return void 0===s||t>=e||t<0||g&&n-c>=i}function E(){var n=m();if(x(n))return T(n);l=setTimeout(E,function(n){var t=e-(n-s);return g?p(t,i-(n-c)):t}(n))}function T(n){return l=void 0,v&&a?b(n):(a=r=void 0,o)}function _(){var n=m(),t=x(n);if(a=arguments,r=this,s=n,t){if(void 0===l)return y(s);if(g)return l=setTimeout(E,e),b(s)}return void 0===l&&(l=setTimeout(E,e)),o}return e=f(e)||0,h(t)&&(d=!!t.leading,i=(g="maxWait"in t)?u(f(t.maxWait)||0,e):i,v="trailing"in t?!!t.trailing:v),_.cancel=function(){void 0!==l&&clearTimeout(l),c=0,a=s=r=l=void 0},_.flush=function(){return void 0===l?o:T(m())},_}},function(n,e,t){"use strict";var a=t(4),r=t(34),i=t(108),o=t(35),l=t(28),s=t(54),c=t(8),d=t(64),u=Object.getOwnPropertyDescriptor;e.f=a?u:function(n,e){if(n=l(n),e=s(e),d)try{return u(n,e)}catch(n){}if(c(n,e))return o(!r(i.f,n,e),n[e])}},function(n,e,t){"use strict";var a=t(53),r=TypeError;n.exports=function(n){if(a(n))throw new r("Can't call method on "+n);return n}},function(n,e,t){"use strict";n.exports=function(n){return null==n}},function(n,e,t){"use strict";var a=t(109),r=t(56);n.exports=function(n){var e=a(n,"string");return r(e)?e:e+""}},function(n,e,t){"use strict";var a="object"==typeof document&&document.all,r=void 0===a&&void 0!==a;n.exports={all:a,IS_HTMLDDA:r}},function(n,e,t){"use strict";var a=t(29),r=t(0),i=t(57),o=t(58),l=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return r(e)&&i(e.prototype,l(n))}},function(n,e,t){"use strict";var a=t(2);n.exports=a({}.isPrototypeOf)},function(n,e,t){"use strict";var a=t(59);n.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){"use strict";var a=t(60),r=t(3),i=t(1).String;n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol("symbol detection");return!i(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(n,e,t){"use strict";var a,r,i=t(1),o=t(110),l=i.process,s=i.Deno,c=l&&l.versions||s&&s.version,d=c&&c.v8;d&&(r=(a=d.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!r&&o&&(!(a=o.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=o.match(/Chrome\/(\d+)/))&&(r=+a[1]),n.exports=r},function(n,e,t){"use strict";var a=t(62),r=t(36);(n.exports=function(n,e){return r[n]||(r[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.33.2",mode:a?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.33.2/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){"use strict";n.exports=!1},function(n,e,t){"use strict";var a=t(2),r=0,i=Math.random(),o=a(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++r+i,36)}},function(n,e,t){"use strict";var a=t(4),r=t(3),i=t(100);n.exports=!a&&!r((function(){return 7!==Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){"use strict";var a=t(8),r=t(118),i=t(51),o=t(17);n.exports=function(n,e,t){for(var l=r(e),s=o.f,c=i.f,d=0;d<l.length;d++){var u=l[d];a(n,u)||t&&a(t,u)||s(n,u,c(e,u))}}},function(n,e,t){"use strict";var a=t(122);n.exports=function(n){var e=+n;return e!=e||0===e?0:a(e)}},function(n,e,t){"use strict";var a=t(135),r=t(25),i=t(136);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=a(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return r(t),i(a),e?n(t,a):t.__proto__=a,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,a=e.length,r=n.length;++t<a;)n[r+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var a=t(19),r=t(159),i=t(160),o=t(161),l=t(162),s=t(163);function c(n){var e=this.__data__=new a(n);this.size=e.size}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=l,c.prototype.set=s,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var a=t(13),r=t(40);n.exports=function(n){if(!r(n))return!1;var e=a(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var a=t(180),r=t(12);n.exports=function n(e,t,i,o,l){return e===t||(null==e||null==t||!r(e)&&!r(t)?e!=e&&t!=t:a(e,t,i,o,n,l))}},function(n,e,t){var a=t(76),r=t(183),i=t(77);n.exports=function(n,e,t,o,l,s){var c=1&t,d=n.length,u=e.length;if(d!=u&&!(c&&u>d))return!1;var p=s.get(n),m=s.get(e);if(p&&m)return p==e&&m==n;var h=-1,f=!0,g=2&t?new a:void 0;for(s.set(n,e),s.set(e,n);++h<d;){var v=n[h],b=e[h];if(o)var y=c?o(b,v,h,e,n,s):o(v,b,h,n,e,s);if(void 0!==y){if(y)continue;f=!1;break}if(g){if(!r(e,(function(n,e){if(!i(g,e)&&(v===n||l(v,n,t,o,s)))return g.push(e)}))){f=!1;break}}else if(v!==b&&!l(v,b,t,o,s)){f=!1;break}}return s.delete(n),s.delete(e),f}},function(n,e,t){var a=t(41),r=t(181),i=t(182);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new a;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=r,o.prototype.has=i,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var a=t(193),r=t(199),i=t(82);n.exports=function(n){return i(n)?a(n):r(n)}},function(n,e,t){(function(n){var a=t(6),r=t(195),i=e&&!e.nodeType&&e,o=i&&"object"==typeof n&&n&&!n.nodeType&&n,l=o&&o.exports===i?a.Buffer:void 0,s=(l?l.isBuffer:void 0)||r;n.exports=s}).call(this,t(49)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var a=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==a||"symbol"!=a&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var a=t(196),r=t(197),i=t(198),o=i&&i.isTypedArray,l=o?r(o):a;n.exports=l},function(n,e,t){var a=t(72),r=t(43);n.exports=function(n){return null!=n&&r(n.length)&&!a(n)}},function(n,e,t){var a=t(10)(t(6),"Set");n.exports=a},function(n,e,t){var a=t(40);n.exports=function(n){return n==n&&!a(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var a=t(87),r=t(23);n.exports=function(n,e){for(var t=0,i=(e=a(e,n)).length;null!=n&&t<i;)n=n[r(e[t++])];return t&&t==i?n:void 0}},function(n,e,t){var a=t(5),r=t(44),i=t(210),o=t(213);n.exports=function(n,e){return a(n)?n:r(n,e)?[n]:i(o(n))}},function(n,e){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(146),r=t(151),i=t(222),o=t(230),l=t(239),s=t(105),c=i((function(n){var e=s(n);return l(e)&&(e=void 0),o(a(n,1,l,!0),r(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;n.exports=function(n){var e,t=""+n,r=a.exec(t);if(!r)return t;var i="",o=0,l=0;for(o=r.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}l!==o&&(i+=t.substring(l,o)),l=o+1,i+=e}return l!==o?i+t.substring(l,o):i}},function(n,e,t){"use strict";t.r(e);var a={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},r=(t(242),t(7)),i=Object(r.a)(a,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=i.exports},function(n,e,t){"use strict";t.r(e);var a={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},r=(t(243),t(7)),i=Object(r.a)(a,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,a){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":a===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(a)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=i.exports},function(n,e,t){"use strict";var a=t(0),r=t(17),i=t(102),o=t(37);n.exports=function(n,e,t,l){l||(l={});var s=l.enumerable,c=void 0!==l.name?l.name:e;if(a(t)&&i(t,c,l),l.global)s?n[e]=t:o(e,t);else{try{l.unsafe?n[e]&&(s=!0):delete n[e]}catch(n){}s?n[e]=t:r.f(n,e,{value:t,enumerable:!1,configurable:!l.nonConfigurable,writable:!l.nonWritable})}return n}},function(n,e,t){"use strict";n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var a=t(140),r=String;n.exports=function(n){if("Symbol"===a(n))throw new TypeError("Cannot convert a Symbol value to a string");return r(n)}},function(n,e,t){"use strict";var a=t(1),r=t(9),i=a.document,o=r(i)&&r(i.createElement);n.exports=function(n){return o?i.createElement(n):{}}},function(n,e,t){"use strict";var a=t(4),r=t(3);n.exports=a&&r((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){"use strict";var a=t(2),r=t(3),i=t(0),o=t(8),l=t(4),s=t(114).CONFIGURABLE,c=t(115),d=t(116),u=d.enforce,p=d.get,m=String,h=Object.defineProperty,f=a("".slice),g=a("".replace),v=a([].join),b=l&&!r((function(){return 8!==h((function(){}),"length",{value:8}).length})),y=String(String).split("String"),x=n.exports=function(n,e,t){"Symbol("===f(m(e),0,7)&&(e="["+g(m(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!o(n,"name")||s&&n.name!==e)&&(l?h(n,"name",{value:e,configurable:!0}):n.name=e),b&&t&&o(t,"arity")&&n.length!==t.arity&&h(n,"length",{value:t.arity});try{t&&o(t,"constructor")&&t.constructor?l&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var a=u(n);return o(a,"source")||(a.source=v(y,"string"==typeof e?e:"")),n};Function.prototype.toString=x((function(){return i(this)&&p(this).source||c(this)}),"toString")},function(n,e,t){"use strict";var a=t(61),r=t(63),i=a("keys");n.exports=function(n){return i[n]||(i[n]=r(n))}},function(n,e,t){"use strict";var a=t(2),r=t(8),i=t(28),o=t(120).indexOf,l=t(48),s=a([].push);n.exports=function(n,e){var t,a=i(n),c=0,d=[];for(t in a)!r(l,t)&&r(a,t)&&s(d,t);for(;e.length>c;)r(a,t=e[c++])&&(~o(d,t)||s(d,t));return d}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(248)},function(n,e,t){"use strict";var a=t(26),r=t(126).left,i=t(127),o=t(60);a({target:"Array",proto:!0,forced:!t(128)&&o>79&&o<83||!i("reduce")},{reduce:function(n){var e=arguments.length;return r(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var a={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,i=r&&!a.call({1:2},1);e.f=i?function(n){var e=r(this,n);return!!e&&e.enumerable}:a},function(n,e,t){"use strict";var a=t(34),r=t(9),i=t(56),o=t(111),l=t(113),s=t(31),c=TypeError,d=s("toPrimitive");n.exports=function(n,e){if(!r(n)||i(n))return n;var t,s=o(n,d);if(s){if(void 0===e&&(e="default"),t=a(s,n,e),!r(t)||i(t))return t;throw new c("Can't convert object to primitive value")}return void 0===e&&(e="number"),l(n,e)}},function(n,e,t){"use strict";n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){"use strict";var a=t(30),r=t(53);n.exports=function(n,e){var t=n[e];return r(t)?void 0:a(t)}},function(n,e,t){"use strict";var a=String;n.exports=function(n){try{return a(n)}catch(n){return"Object"}}},function(n,e,t){"use strict";var a=t(34),r=t(0),i=t(9),o=TypeError;n.exports=function(n,e){var t,l;if("string"===e&&r(t=n.toString)&&!i(l=a(t,n)))return l;if(r(t=n.valueOf)&&!i(l=a(t,n)))return l;if("string"!==e&&r(t=n.toString)&&!i(l=a(t,n)))return l;throw new o("Can't convert object to primitive value")}},function(n,e,t){"use strict";var a=t(4),r=t(8),i=Function.prototype,o=a&&Object.getOwnPropertyDescriptor,l=r(i,"name"),s=l&&"something"===function(){}.name,c=l&&(!a||a&&o(i,"name").configurable);n.exports={EXISTS:l,PROPER:s,CONFIGURABLE:c}},function(n,e,t){"use strict";var a=t(2),r=t(0),i=t(36),o=a(Function.toString);r(i.inspectSource)||(i.inspectSource=function(n){return o(n)}),n.exports=i.inspectSource},function(n,e,t){"use strict";var a,r,i,o=t(117),l=t(1),s=t(9),c=t(14),d=t(8),u=t(36),p=t(103),m=t(48),h=l.TypeError,f=l.WeakMap;if(o||u.state){var g=u.state||(u.state=new f);g.get=g.get,g.has=g.has,g.set=g.set,a=function(n,e){if(g.has(n))throw new h("Object already initialized");return e.facade=n,g.set(n,e),e},r=function(n){return g.get(n)||{}},i=function(n){return g.has(n)}}else{var v=p("state");m[v]=!0,a=function(n,e){if(d(n,v))throw new h("Object already initialized");return e.facade=n,c(n,v,e),e},r=function(n){return d(n,v)?n[v]:{}},i=function(n){return d(n,v)}}n.exports={set:a,get:r,has:i,enforce:function(n){return i(n)?r(n):a(n,{})},getterFor:function(n){return function(e){var t;if(!s(e)||(t=r(e)).type!==n)throw new h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){"use strict";var a=t(1),r=t(0),i=a.WeakMap;n.exports=r(i)&&/native code/.test(String(i))},function(n,e,t){"use strict";var a=t(29),r=t(2),i=t(119),o=t(124),l=t(25),s=r([].concat);n.exports=a("Reflect","ownKeys")||function(n){var e=i.f(l(n)),t=o.f;return t?s(e,t(n)):e}},function(n,e,t){"use strict";var a=t(104),r=t(98).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return a(n,r)}},function(n,e,t){"use strict";var a=t(28),r=t(121),i=t(33),o=function(n){return function(e,t,o){var l,s=a(e),c=i(s),d=r(o,c);if(n&&t!=t){for(;c>d;)if((l=s[d++])!=l)return!0}else for(;c>d;d++)if((n||d in s)&&s[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){"use strict";var a=t(66),r=Math.max,i=Math.min;n.exports=function(n,e){var t=a(n);return t<0?r(t+e,0):i(t,e)}},function(n,e,t){"use strict";var a=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:a)(e)}},function(n,e,t){"use strict";var a=t(66),r=Math.min;n.exports=function(n){return n>0?r(a(n),9007199254740991):0}},function(n,e,t){"use strict";e.f=Object.getOwnPropertySymbols},function(n,e,t){"use strict";var a=t(3),r=t(0),i=/#|\.prototype\./,o=function(n,e){var t=s[l(n)];return t===d||t!==c&&(r(e)?a(e):!!e)},l=o.normalize=function(n){return String(n).replace(i,".").toLowerCase()},s=o.data={},c=o.NATIVE="N",d=o.POLYFILL="P";n.exports=o},function(n,e,t){"use strict";var a=t(30),r=t(32),i=t(47),o=t(33),l=TypeError,s=function(n){return function(e,t,s,c){a(t);var d=r(e),u=i(d),p=o(d),m=n?p-1:0,h=n?-1:1;if(s<2)for(;;){if(m in u){c=u[m],m+=h;break}if(m+=h,n?m<0:p<=m)throw new l("Reduce of empty array with no initial value")}for(;n?m>=0:p>m;m+=h)m in u&&(c=t(c,u[m],m,d));return c}};n.exports={left:s(!1),right:s(!0)}},function(n,e,t){"use strict";var a=t(3);n.exports=function(n,e){var t=[][n];return!!t&&a((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){"use strict";var a=t(1),r=t(18);n.exports="process"===r(a.process)},function(n,e,t){"use strict";var a=t(4),r=t(130),i=TypeError,o=Object.getOwnPropertyDescriptor,l=a&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=l?function(n,e){if(r(n)&&!o(n,"length").writable)throw new i("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){"use strict";var a=t(18);n.exports=Array.isArray||function(n){return"Array"===a(n)}},function(n,e,t){"use strict";var a=TypeError;n.exports=function(n){if(n>9007199254740991)throw a("Maximum allowed index exceeded");return n}},function(n,e,t){"use strict";var a=t(26),r=t(1),i=t(133),o=t(134),l=r.WebAssembly,s=7!==new Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=o(n,e,s),a({global:!0,constructor:!0,arity:1,forced:s},t)},d=function(n,e){if(l&&l[n]){var t={};t[n]=o("WebAssembly."+n,e,s),a({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:s},t)}};c("Error",(function(n){return function(e){return i(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return i(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return i(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return i(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return i(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return i(n,this,arguments)}})),c("URIError",(function(n){return function(e){return i(n,this,arguments)}})),d("CompileError",(function(n){return function(e){return i(n,this,arguments)}})),d("LinkError",(function(n){return function(e){return i(n,this,arguments)}})),d("RuntimeError",(function(n){return function(e){return i(n,this,arguments)}}))},function(n,e,t){"use strict";var a=t(27),r=Function.prototype,i=r.apply,o=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(a?o.bind(i):function(){return o.apply(i,arguments)})},function(n,e,t){"use strict";var a=t(29),r=t(8),i=t(14),o=t(57),l=t(67),s=t(65),c=t(137),d=t(138),u=t(139),p=t(142),m=t(143),h=t(4),f=t(62);n.exports=function(n,e,t,g){var v=g?2:1,b=n.split("."),y=b[b.length-1],x=a.apply(null,b);if(x){var E=x.prototype;if(!f&&r(E,"cause")&&delete E.cause,!t)return x;var T=a("Error"),_=e((function(n,e){var t=u(g?e:n,void 0),a=g?new x(n):new x;return void 0!==t&&i(a,"message",t),m(a,_,a.stack,2),this&&o(E,this)&&d(a,this,_),arguments.length>v&&p(a,arguments[v]),a}));if(_.prototype=E,"Error"!==y?l?l(_,T):s(_,T,{name:!0}):h&&"stackTraceLimit"in x&&(c(_,x,"stackTraceLimit"),c(_,x,"prepareStackTrace")),s(_,x),!f)try{E.name!==y&&i(E,"name",y),E.constructor=_}catch(n){}return _}}},function(n,e,t){"use strict";var a=t(2),r=t(30);n.exports=function(n,e,t){try{return a(r(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){"use strict";var a=t(0),r=String,i=TypeError;n.exports=function(n){if("object"==typeof n||a(n))return n;throw new i("Can't set "+r(n)+" as a prototype")}},function(n,e,t){"use strict";var a=t(17).f;n.exports=function(n,e,t){t in n||a(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var a=t(0),r=t(9),i=t(67);n.exports=function(n,e,t){var o,l;return i&&a(o=e.constructor)&&o!==t&&r(l=o.prototype)&&l!==t.prototype&&i(n,l),n}},function(n,e,t){"use strict";var a=t(99);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:a(n)}},function(n,e,t){"use strict";var a=t(141),r=t(0),i=t(18),o=t(31)("toStringTag"),l=Object,s="Arguments"===i(function(){return arguments}());n.exports=a?i:function(n){var e,t,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=l(n),o))?t:s?i(e):"Object"===(a=i(e))&&r(e.callee)?"Arguments":a}},function(n,e,t){"use strict";var a={};a[t(31)("toStringTag")]="z",n.exports="[object z]"===String(a)},function(n,e,t){"use strict";var a=t(9),r=t(14);n.exports=function(n,e){a(e)&&"cause"in e&&r(n,"cause",e.cause)}},function(n,e,t){"use strict";var a=t(14),r=t(144),i=t(145),o=Error.captureStackTrace;n.exports=function(n,e,t,l){i&&(o?o(n,e):a(n,"stack",r(t,l)))}},function(n,e,t){"use strict";var a=t(2),r=Error,i=a("".replace),o=String(new r("zxcasd").stack),l=/\n\s*at [^:]*:[^\n]*/,s=l.test(o);n.exports=function(n,e){if(s&&"string"==typeof n&&!r.prepareStackTrace)for(;e--;)n=i(n,l,"");return n}},function(n,e,t){"use strict";var a=t(3),r=t(35);n.exports=!a((function(){var n=new Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",r(1,7)),7!==n.stack)}))},function(n,e,t){var a=t(68),r=t(147);n.exports=function n(e,t,i,o,l){var s=-1,c=e.length;for(i||(i=r),l||(l=[]);++s<c;){var d=e[s];t>0&&i(d)?t>1?n(d,t-1,i,o,l):a(l,d):o||(l[l.length]=d)}return l}},function(n,e,t){var a=t(15),r=t(38),i=t(5),o=a?a.isConcatSpreadable:void 0;n.exports=function(n){return i(n)||r(n)||!!(o&&n&&n[o])}},function(n,e,t){var a=t(13),r=t(12);n.exports=function(n){return r(n)&&"[object Arguments]"==a(n)}},function(n,e,t){var a=t(15),r=Object.prototype,i=r.hasOwnProperty,o=r.toString,l=a?a.toStringTag:void 0;n.exports=function(n){var e=i.call(n,l),t=n[l];try{n[l]=void 0;var a=!0}catch(n){}var r=o.call(n);return a&&(e?n[l]=t:delete n[l]),r}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var a=t(152),r=t(208),i=t(46),o=t(5),l=t(219);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==typeof n?o(n)?r(n[0],n[1]):a(n):l(n)}},function(n,e,t){var a=t(153),r=t(207),i=t(85);n.exports=function(n){var e=r(n);return 1==e.length&&e[0][2]?i(e[0][0],e[0][1]):function(t){return t===n||a(t,n,e)}}},function(n,e,t){var a=t(70),r=t(74);n.exports=function(n,e,t,i){var o=t.length,l=o,s=!i;if(null==n)return!l;for(n=Object(n);o--;){var c=t[o];if(s&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++o<l;){var d=(c=t[o])[0],u=n[d],p=c[1];if(s&&c[2]){if(void 0===u&&!(d in n))return!1}else{var m=new a;if(i)var h=i(u,p,d,n,e,m);if(!(void 0===h?r(p,u,3,i,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var a=t(20),r=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=a(e,n);return!(t<0)&&(t==e.length-1?e.pop():r.call(e,t,1),--this.size,!0)}},function(n,e,t){var a=t(20);n.exports=function(n){var e=this.__data__,t=a(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var a=t(20);n.exports=function(n){return a(this.__data__,n)>-1}},function(n,e,t){var a=t(20);n.exports=function(n,e){var t=this.__data__,r=a(t,n);return r<0?(++this.size,t.push([n,e])):t[r][1]=e,this}},function(n,e,t){var a=t(19);n.exports=function(){this.__data__=new a,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var a=t(19),r=t(39),i=t(41);n.exports=function(n,e){var t=this.__data__;if(t instanceof a){var o=t.__data__;if(!r||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new i(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var a=t(72),r=t(165),i=t(40),o=t(73),l=/^\[object .+?Constructor\]$/,s=Function.prototype,c=Object.prototype,d=s.toString,u=c.hasOwnProperty,p=RegExp("^"+d.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!i(n)||r(n))&&(a(n)?p:l).test(o(n))}},function(n,e,t){var a,r=t(166),i=(a=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";n.exports=function(n){return!!i&&i in n}},function(n,e,t){var a=t(6)["__core-js_shared__"];n.exports=a},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var a=t(169),r=t(19),i=t(39);n.exports=function(){this.size=0,this.__data__={hash:new a,map:new(i||r),string:new a}}},function(n,e,t){var a=t(170),r=t(171),i=t(172),o=t(173),l=t(174);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}s.prototype.clear=a,s.prototype.delete=r,s.prototype.get=i,s.prototype.has=o,s.prototype.set=l,n.exports=s},function(n,e,t){var a=t(21);n.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var a=t(21),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(a){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return r.call(e,n)?e[n]:void 0}},function(n,e,t){var a=t(21),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return a?void 0!==e[n]:r.call(e,n)}},function(n,e,t){var a=t(21);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=a&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var a=t(22);n.exports=function(n){var e=a(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var a=t(22);n.exports=function(n){return a(this,n).get(n)}},function(n,e,t){var a=t(22);n.exports=function(n){return a(this,n).has(n)}},function(n,e,t){var a=t(22);n.exports=function(n,e){var t=a(this,n),r=t.size;return t.set(n,e),this.size+=t.size==r?0:1,this}},function(n,e,t){var a=t(70),r=t(75),i=t(184),o=t(187),l=t(203),s=t(5),c=t(79),d=t(81),u="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,f){var g=s(n),v=s(e),b=g?"[object Array]":l(n),y=v?"[object Array]":l(e),x=(b="[object Arguments]"==b?u:b)==u,E=(y="[object Arguments]"==y?u:y)==u,T=b==y;if(T&&c(n)){if(!c(e))return!1;g=!0,x=!1}if(T&&!x)return f||(f=new a),g||d(n)?r(n,e,t,m,h,f):i(n,e,b,t,m,h,f);if(!(1&t)){var _=x&&p.call(n,"__wrapped__"),S=E&&p.call(e,"__wrapped__");if(_||S){var k=_?n.value():n,w=S?e.value():e;return f||(f=new a),h(k,w,t,m,f)}}return!!T&&(f||(f=new a),o(n,e,t,m,h,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length;++t<a;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var a=t(15),r=t(185),i=t(71),o=t(75),l=t(186),s=t(42),c=a?a.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,a,c,u,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new r(n),new r(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=l;case"[object Set]":var h=1&a;if(m||(m=s),n.size!=e.size&&!h)return!1;var f=p.get(n);if(f)return f==e;a|=2,p.set(n,e);var g=o(m(n),m(e),a,c,u,p);return p.delete(n),g;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var a=t(6).Uint8Array;n.exports=a},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,a){t[++e]=[a,n]})),t}},function(n,e,t){var a=t(188),r=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,i,o,l){var s=1&t,c=a(n),d=c.length;if(d!=a(e).length&&!s)return!1;for(var u=d;u--;){var p=c[u];if(!(s?p in e:r.call(e,p)))return!1}var m=l.get(n),h=l.get(e);if(m&&h)return m==e&&h==n;var f=!0;l.set(n,e),l.set(e,n);for(var g=s;++u<d;){var v=n[p=c[u]],b=e[p];if(i)var y=s?i(b,v,p,e,n,l):i(v,b,p,n,e,l);if(!(void 0===y?v===b||o(v,b,t,i,l):y)){f=!1;break}g||(g="constructor"==p)}if(f&&!g){var x=n.constructor,E=e.constructor;x==E||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof E&&E instanceof E||(f=!1)}return l.delete(n),l.delete(e),f}},function(n,e,t){var a=t(189),r=t(190),i=t(78);n.exports=function(n){return a(n,i,r)}},function(n,e,t){var a=t(68),r=t(5);n.exports=function(n,e,t){var i=e(n);return r(n)?i:a(i,t(n))}},function(n,e,t){var a=t(191),r=t(192),i=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,l=o?function(n){return null==n?[]:(n=Object(n),a(o(n),(function(e){return i.call(n,e)})))}:r;n.exports=l},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=0,i=[];++t<a;){var o=n[t];e(o,t,n)&&(i[r++]=o)}return i}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var a=t(194),r=t(38),i=t(5),o=t(79),l=t(80),s=t(81),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=i(n),d=!t&&r(n),u=!t&&!d&&o(n),p=!t&&!d&&!u&&s(n),m=t||d||u||p,h=m?a(n.length,String):[],f=h.length;for(var g in n)!e&&!c.call(n,g)||m&&("length"==g||u&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||l(g,f))||h.push(g);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,a=Array(n);++t<n;)a[t]=e(t);return a}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var a=t(13),r=t(43),i=t(12),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return i(n)&&r(n.length)&&!!o[a(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var a=t(69),r=e&&!e.nodeType&&e,i=r&&"object"==typeof n&&n&&!n.nodeType&&n,o=i&&i.exports===r&&a.process,l=function(){try{var n=i&&i.require&&i.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=l}).call(this,t(49)(n))},function(n,e,t){var a=t(200),r=t(201),i=Object.prototype.hasOwnProperty;n.exports=function(n){if(!a(n))return r(n);var e=[];for(var t in Object(n))i.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var a=t(202)(Object.keys,Object);n.exports=a},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var a=t(204),r=t(39),i=t(205),o=t(83),l=t(206),s=t(13),c=t(73),d=c(a),u=c(r),p=c(i),m=c(o),h=c(l),f=s;(a&&"[object DataView]"!=f(new a(new ArrayBuffer(1)))||r&&"[object Map]"!=f(new r)||i&&"[object Promise]"!=f(i.resolve())||o&&"[object Set]"!=f(new o)||l&&"[object WeakMap]"!=f(new l))&&(f=function(n){var e=s(n),t="[object Object]"==e?n.constructor:void 0,a=t?c(t):"";if(a)switch(a){case d:return"[object DataView]";case u:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=f},function(n,e,t){var a=t(10)(t(6),"DataView");n.exports=a},function(n,e,t){var a=t(10)(t(6),"Promise");n.exports=a},function(n,e,t){var a=t(10)(t(6),"WeakMap");n.exports=a},function(n,e,t){var a=t(84),r=t(78);n.exports=function(n){for(var e=r(n),t=e.length;t--;){var i=e[t],o=n[i];e[t]=[i,o,a(o)]}return e}},function(n,e,t){var a=t(74),r=t(209),i=t(216),o=t(44),l=t(84),s=t(85),c=t(23);n.exports=function(n,e){return o(n)&&l(e)?s(c(n),e):function(t){var o=r(t,n);return void 0===o&&o===e?i(t,n):a(e,o,3)}}},function(n,e,t){var a=t(86);n.exports=function(n,e,t){var r=null==n?void 0:a(n,e);return void 0===r?t:r}},function(n,e,t){var a=t(211),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,o=a((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(r,(function(n,t,a,r){e.push(a?r.replace(i,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var a=t(212);n.exports=function(n){var e=a(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var a=t(41);function r(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var a=arguments,r=e?e.apply(this,a):a[0],i=t.cache;if(i.has(r))return i.get(r);var o=n.apply(this,a);return t.cache=i.set(r,o)||i,o};return t.cache=new(r.Cache||a),t}r.Cache=a,n.exports=r},function(n,e,t){var a=t(214);n.exports=function(n){return null==n?"":a(n)}},function(n,e,t){var a=t(15),r=t(215),i=t(5),o=t(45),l=a?a.prototype:void 0,s=l?l.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(i(e))return r(e,n)+"";if(o(e))return s?s.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=Array(a);++t<a;)r[t]=e(n[t],t,n);return r}},function(n,e,t){var a=t(217),r=t(218);n.exports=function(n,e){return null!=n&&r(n,e,a)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var a=t(87),r=t(38),i=t(5),o=t(80),l=t(43),s=t(23);n.exports=function(n,e,t){for(var c=-1,d=(e=a(e,n)).length,u=!1;++c<d;){var p=s(e[c]);if(!(u=null!=n&&t(n,p)))break;n=n[p]}return u||++c!=d?u:!!(d=null==n?0:n.length)&&l(d)&&o(p,d)&&(i(n)||r(n))}},function(n,e,t){var a=t(220),r=t(221),i=t(44),o=t(23);n.exports=function(n){return i(n)?a(o(n)):r(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var a=t(86);n.exports=function(n){return function(e){return a(e,n)}}},function(n,e,t){var a=t(46),r=t(223),i=t(225);n.exports=function(n,e){return i(r(n,e,a),n+"")}},function(n,e,t){var a=t(224),r=Math.max;n.exports=function(n,e,t){return e=r(void 0===e?n.length-1:e,0),function(){for(var i=arguments,o=-1,l=r(i.length-e,0),s=Array(l);++o<l;)s[o]=i[e+o];o=-1;for(var c=Array(e+1);++o<e;)c[o]=i[o];return c[e]=t(s),a(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var a=t(226),r=t(229)(a);n.exports=r},function(n,e,t){var a=t(227),r=t(228),i=t(46),o=r?function(n,e){return r(n,"toString",{configurable:!0,enumerable:!1,value:a(e),writable:!0})}:i;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var a=t(10),r=function(){try{var n=a(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=r},function(n,e){var t=Date.now;n.exports=function(n){var e=0,a=0;return function(){var r=t(),i=16-(r-a);if(a=r,i>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var a=t(76),r=t(231),i=t(236),o=t(77),l=t(237),s=t(42);n.exports=function(n,e,t){var c=-1,d=r,u=n.length,p=!0,m=[],h=m;if(t)p=!1,d=i;else if(u>=200){var f=e?null:l(n);if(f)return s(f);p=!1,d=o,h=new a}else h=e?[]:m;n:for(;++c<u;){var g=n[c],v=e?e(g):g;if(g=t||0!==g?g:0,p&&v==v){for(var b=h.length;b--;)if(h[b]===v)continue n;e&&h.push(v),m.push(g)}else d(h,v,t)||(h!==m&&h.push(v),m.push(g))}return m}},function(n,e,t){var a=t(232);n.exports=function(n,e){return!!(null==n?0:n.length)&&a(n,e,0)>-1}},function(n,e,t){var a=t(233),r=t(234),i=t(235);n.exports=function(n,e,t){return e==e?i(n,e,t):a(n,r,t)}},function(n,e){n.exports=function(n,e,t,a){for(var r=n.length,i=t+(a?1:-1);a?i--:++i<r;)if(e(n[i],i,n))return i;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var a=t-1,r=n.length;++a<r;)if(n[a]===e)return a;return-1}},function(n,e){n.exports=function(n,e,t){for(var a=-1,r=null==n?0:n.length;++a<r;)if(t(e,n[a]))return!0;return!1}},function(n,e,t){var a=t(83),r=t(238),i=t(42),o=a&&1/i(new a([,-0]))[1]==1/0?function(n){return new a(n)}:r;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var a=t(82),r=t(12);n.exports=function(n){return r(n)&&a(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t(90)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t(92)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.15
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
var a=Object.freeze({}),r=Array.isArray;function i(n){return null==n}function o(n){return null!=n}function l(n){return!0===n}function s(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function d(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function p(n){return"[object Object]"===u.call(n)}function m(n){return"[object RegExp]"===u.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),a=n.split(","),r=0;r<a.length;r++)t[a[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var y=b("key,ref,slot,slot-scope,is");function x(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var a=n.indexOf(e);if(a>-1)return n.splice(a,1)}}var E=Object.prototype.hasOwnProperty;function T(n,e){return E.call(n,e)}function _(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var S=/-(\w)/g,k=_((function(n){return n.replace(S,(function(n,e){return e?e.toUpperCase():""}))})),w=_((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),C=/\B([A-Z])/g,A=_((function(n){return n.replace(C,"-$1").toLowerCase()}));var I=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var a=arguments.length;return a?a>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function z(n,e){e=e||0;for(var t=n.length-e,a=new Array(t);t--;)a[t]=n[t+e];return a}function L(n,e){for(var t in e)n[t]=e[t];return n}function M(n){for(var e={},t=0;t<n.length;t++)n[t]&&L(e,n[t]);return e}function j(n,e,t){}var B=function(n,e,t){return!1},P=function(n){return n};function O(n,e){if(n===e)return!0;var t=d(n),a=d(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var r=Array.isArray(n),i=Array.isArray(e);if(r&&i)return n.length===e.length&&n.every((function(n,t){return O(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||i)return!1;var o=Object.keys(n),l=Object.keys(e);return o.length===l.length&&o.every((function(t){return O(n[t],e[t])}))}catch(n){return!1}}function R(n,e){for(var t=0;t<n.length;t++)if(O(n[t],e))return t;return-1}function D(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function J(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var F=["component","directive","filter"],q=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],N={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:B,isReservedAttr:B,isUnknownElement:B,getTagNamespace:j,parsePlatformTagName:P,mustUseProp:B,async:!0,_lifecycleHooks:q},U=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function G(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function V(n,e,t,a){Object.defineProperty(n,e,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var Q=new RegExp("[^".concat(U.source,".$_\\d]"));var H="__proto__"in{},$="undefined"!=typeof window,X=$&&window.navigator.userAgent.toLowerCase(),K=X&&/msie|trident/.test(X),W=X&&X.indexOf("msie 9.0")>0,Z=X&&X.indexOf("edge/")>0;X&&X.indexOf("android");var Y=X&&/iphone|ipad|ipod|ios/.test(X);X&&/chrome\/\d+/.test(X),X&&/phantomjs/.test(X);var nn,en=X&&X.match(/firefox\/(\d+)/),tn={}.watch,an=!1;if($)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){an=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var on=function(){return void 0===nn&&(nn=!$&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},ln=$&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function sn(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,dn="undefined"!=typeof Symbol&&sn(Symbol)&&"undefined"!=typeof Reflect&&sn(Reflect.ownKeys);cn="undefined"!=typeof Set&&sn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=null;function pn(n){void 0===n&&(n=null),n||un&&un._scope.off(),un=n,n&&n._scope.on()}var mn=function(){function n(n,e,t,a,r,i,o,l){this.tag=n,this.data=e,this.children=t,this.text=a,this.elm=r,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=l,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),hn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function fn(n){return new mn(void 0,void 0,void 0,String(n))}function gn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var vn=0,bn=[],yn=function(){function n(){this._pending=!1,this.id=vn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,bn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,a=e.length;t<a;t++){0,e[t].update()}},n}();yn.target=null;var xn=[];function En(n){xn.push(n),yn.target=n}function Tn(){xn.pop(),yn.target=xn[xn.length-1]}var _n=Array.prototype,Sn=Object.create(_n);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=_n[n];V(Sn,n,(function(){for(var t=[],a=0;a<arguments.length;a++)t[a]=arguments[a];var r,i=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&o.observeArray(r),o.dep.notify(),i}))}));var kn=Object.getOwnPropertyNames(Sn),wn={},Cn=!0;function An(n){Cn=n}var In={notify:j,depend:j,addSub:j,removeSub:j},zn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?In:new yn,this.vmCount=0,V(n,"__ob__",this),r(n)){if(!t)if(H)n.__proto__=Sn;else for(var a=0,i=kn.length;a<i;a++){V(n,l=kn[a],Sn[l])}e||this.observeArray(n)}else{var o=Object.keys(n);for(a=0;a<o.length;a++){var l;Mn(n,l=o[a],wn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Ln(n[e],!1,this.mock)},n}();function Ln(n,e,t){return n&&T(n,"__ob__")&&n.__ob__ instanceof zn?n.__ob__:!Cn||!t&&on()||!r(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||Jn(n)||n instanceof mn?void 0:new zn(n,e,t)}function Mn(n,e,t,a,i,o){var l=new yn,s=Object.getOwnPropertyDescriptor(n,e);if(!s||!1!==s.configurable){var c=s&&s.get,d=s&&s.set;c&&!d||t!==wn&&2!==arguments.length||(t=n[e]);var u=!i&&Ln(t,!1,o);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return yn.target&&(l.depend(),u&&(u.dep.depend(),r(e)&&Pn(e))),Jn(e)&&!i?e.value:e},set:function(e){var a=c?c.call(n):t;if(J(a,e)){if(d)d.call(n,e);else{if(c)return;if(!i&&Jn(a)&&!Jn(e))return void(a.value=e);t=e}u=!i&&Ln(e,!1,o),l.notify()}}}),l}}function jn(n,e,t){if(!Dn(n)){var a=n.__ob__;return r(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),a&&!a.shallow&&a.mock&&Ln(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||a&&a.vmCount?t:a?(Mn(a.value,e,t,void 0,a.shallow,a.mock),a.dep.notify(),t):(n[e]=t,t)}}function Bn(n,e){if(r(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Dn(n)||T(n,e)&&(delete n[e],t&&t.dep.notify())}}function Pn(n){for(var e=void 0,t=0,a=n.length;t<a;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),r(e)&&Pn(e)}function On(n){return Rn(n,!0),V(n,"__v_isShallow",!0),n}function Rn(n,e){if(!Dn(n)){Ln(n,e,on());0}}function Dn(n){return!(!n||!n.__v_isReadonly)}function Jn(n){return!(!n||!0!==n.__v_isRef)}function Fn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Jn(n))return n.value;var a=n&&n.__ob__;return a&&a.dep.depend(),n},set:function(n){var a=e[t];Jn(a)&&!Jn(n)?a.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var qn;var Nn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=qn,!n&&qn&&(this.index=(qn.scopes||(qn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=qn;try{return qn=this,n()}finally{qn=e}}else 0},n.prototype.on=function(){qn=this},n.prototype.off=function(){qn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Un(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Gn=_((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),a="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=a?n.slice(1):n,once:t,capture:a,passive:e}}));function Vn(n,e){function t(){var n=t.fns;if(!r(n))return Ce(n,null,arguments,e,"v-on handler");for(var a=n.slice(),i=0;i<a.length;i++)Ce(a[i],null,arguments,e,"v-on handler")}return t.fns=n,t}function Qn(n,e,t,a,r,o){var s,c,d,u;for(s in n)c=n[s],d=e[s],u=Gn(s),i(c)||(i(d)?(i(c.fns)&&(c=n[s]=Vn(c,o)),l(u.once)&&(c=n[s]=r(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==d&&(d.fns=c,n[s]=d));for(s in e)i(n[s])&&a((u=Gn(s)).name,e[s],u.capture)}function Hn(n,e,t){var a;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var r=n[e];function s(){t.apply(this,arguments),x(a.fns,s)}i(r)?a=Vn([s]):o(r.fns)&&l(r.merged)?(a=r).fns.push(s):a=Vn([r,s]),a.merged=!0,n[e]=a}function $n(n,e,t,a,r){if(o(e)){if(T(e,t))return n[t]=e[t],r||delete e[t],!0;if(T(e,a))return n[t]=e[a],r||delete e[a],!0}return!1}function Xn(n){return s(n)?[fn(n)]:r(n)?function n(e,t){var a,c,d,u,p=[];for(a=0;a<e.length;a++)i(c=e[a])||"boolean"==typeof c||(d=p.length-1,u=p[d],r(c)?c.length>0&&(Kn((c=n(c,"".concat(t||"","_").concat(a)))[0])&&Kn(u)&&(p[d]=fn(u.text+c[0].text),c.shift()),p.push.apply(p,c)):s(c)?Kn(u)?p[d]=fn(u.text+c):""!==c&&p.push(fn(c)):Kn(c)&&Kn(u)?p[d]=fn(u.text+c.text):(l(e._isVList)&&o(c.tag)&&i(c.key)&&o(t)&&(c.key="__vlist".concat(t,"_").concat(a,"__")),p.push(c)));return p}(n):void 0}function Kn(n){return o(n)&&o(n.text)&&!1===n.isComment}function Wn(n,e){var t,a,i,l,s=null;if(r(n)||"string"==typeof n)for(s=new Array(n.length),t=0,a=n.length;t<a;t++)s[t]=e(n[t],t);else if("number"==typeof n)for(s=new Array(n),t=0;t<n;t++)s[t]=e(t+1,t);else if(d(n))if(dn&&n[Symbol.iterator]){s=[];for(var c=n[Symbol.iterator](),u=c.next();!u.done;)s.push(e(u.value,s.length)),u=c.next()}else for(i=Object.keys(n),s=new Array(i.length),t=0,a=i.length;t<a;t++)l=i[t],s[t]=e(n[l],l,t);return o(s)||(s=[]),s._isVList=!0,s}function Zn(n,e,t,a){var r,i=this.$scopedSlots[n];i?(t=t||{},a&&(t=L(L({},a),t)),r=i(t)||(c(e)?e():e)):r=this.$slots[n]||(c(e)?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},r):r}function Yn(n){return zt(this.$options,"filters",n,!0)||P}function ne(n,e){return r(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,a,r){var i=N.keyCodes[e]||t;return r&&a&&!N.keyCodes[e]?ne(r,a):i?ne(i,n):a?A(a)!==e:void 0===n}function te(n,e,t,a,i){if(t)if(d(t)){r(t)&&(t=M(t));var o=void 0,l=function(r){if("class"===r||"style"===r||y(r))o=n;else{var l=n.attrs&&n.attrs.type;o=a||N.mustUseProp(e,l,r)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var s=k(r),c=A(r);s in o||c in o||(o[r]=t[r],i&&((n.on||(n.on={}))["update:".concat(r)]=function(n){t[r]=n}))};for(var s in t)l(s)}else;return n}function ae(n,e){var t=this._staticTrees||(this._staticTrees=[]),a=t[n];return a&&!e||ie(a=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),a}function re(n,e,t){return ie(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function ie(n,e,t){if(r(n))for(var a=0;a<n.length;a++)n[a]&&"string"!=typeof n[a]&&oe(n[a],"".concat(e,"_").concat(a),t);else oe(n,e,t)}function oe(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function le(n,e){if(e)if(p(e)){var t=n.on=n.on?L({},n.on):{};for(var a in e){var r=t[a],i=e[a];t[a]=r?[].concat(r,i):i}}else;return n}function se(n,e,t,a){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var o=n[i];r(o)?se(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return a&&(e.$key=a),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var a=e[t];"string"==typeof a&&a&&(n[e[t]]=e[t+1])}return n}function de(n,e){return"string"==typeof n?e+n:n}function ue(n){n._o=re,n._n=v,n._s=g,n._l=Wn,n._t=Zn,n._q=O,n._i=R,n._m=ae,n._f=Yn,n._k=ee,n._b=te,n._v=fn,n._e=hn,n._u=se,n._g=le,n._d=ce,n._p=de}function pe(n,e){if(!n||!n.length)return{};for(var t={},a=0,r=n.length;a<r;a++){var i=n[a],o=i.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,i.context!==e&&i.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(i);else{var l=o.slot,s=t[l]||(t[l]=[]);"template"===i.tag?s.push.apply(s,i.children||[]):s.push(i)}}for(var c in t)t[c].every(me)&&delete t[c];return t}function me(n){return n.isComment&&!n.asyncFactory||" "===n.text}function he(n){return n.isComment&&n.asyncFactory}function fe(n,e,t,r){var i,o=Object.keys(t).length>0,l=e?!!e.$stable:!o,s=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(l&&r&&r!==a&&s===r.$key&&!o&&!r.$hasNormal)return r;for(var c in i={},e)e[c]&&"$"!==c[0]&&(i[c]=ge(n,t,c,e[c]))}else i={};for(var d in t)d in i||(i[d]=ve(t,d));return e&&Object.isExtensible(e)&&(e._normalized=i),V(i,"$stable",l),V(i,"$key",s),V(i,"$hasNormal",o),i}function ge(n,e,t,a){var i=function(){var e=un;pn(n);var t=arguments.length?a.apply(null,arguments):a({}),i=(t=t&&"object"==typeof t&&!r(t)?[t]:Xn(t))&&t[0];return pn(e),t&&(!i||1===t.length&&i.isComment&&!he(i))?void 0:t};return a.proxy&&Object.defineProperty(e,t,{get:i,enumerable:!0,configurable:!0}),i}function ve(n,e){return function(){return n[e]}}function be(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};V(e,"_v_attr_proxy",!0),ye(e,n.$attrs,a,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ye(n._listenersProxy={},n.$listeners,a,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||Ee(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:I(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Fn(n,e,t)}))}}}function ye(n,e,t,a,r){var i=!1;for(var o in e)o in n?e[o]!==t[o]&&(i=!0):(i=!0,xe(n,o,a,r));for(var o in n)o in e||(i=!0,delete n[o]);return i}function xe(n,e,t,a){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[a][e]}})}function Ee(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var Te=null;function _e(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),d(n)?e.extend(n):n}function Se(n){if(r(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||he(t)))return t}}function ke(n,e,t,a,u,p){return(r(t)||s(t))&&(u=a,a=t,t=void 0),l(p)&&(u=2),function(n,e,t,a,s){if(o(t)&&o(t.__ob__))return hn();o(t)&&o(t.is)&&(e=t.is);if(!e)return hn();0;r(a)&&c(a[0])&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===s?a=Xn(a):1===s&&(a=function(n){for(var e=0;e<n.length;e++)if(r(n[e]))return Array.prototype.concat.apply([],n);return n}(a));var u,p;if("string"==typeof e){var m=void 0;p=n.$vnode&&n.$vnode.ns||N.getTagNamespace(e),u=N.isReservedTag(e)?new mn(N.parsePlatformTagName(e),t,a,void 0,void 0,n):t&&t.pre||!o(m=zt(n.$options,"components",e))?new mn(e,t,a,void 0,void 0,n):xt(m,t,n,a,e)}else u=xt(e,t,n,a);return r(u)?u:o(u)?(o(p)&&function n(e,t,a){e.ns=t,"foreignObject"===e.tag&&(t=void 0,a=!0);if(o(e.children))for(var r=0,s=e.children.length;r<s;r++){var c=e.children[r];o(c.tag)&&(i(c.ns)||l(a)&&"svg"!==c.tag)&&n(c,t,a)}}(u,p),o(t)&&function(n){d(n.style)&&Ne(n.style);d(n.class)&&Ne(n.class)}(t),u):hn()}(n,e,t,a,u)}function we(n,e,t){En();try{if(e)for(var a=e;a=a.$parent;){var r=a.$options.errorCaptured;if(r)for(var i=0;i<r.length;i++)try{if(!1===r[i].call(a,n,e,t))return}catch(n){Ae(n,a,"errorCaptured hook")}}Ae(n,e,t)}finally{Tn()}}function Ce(n,e,t,a,r){var i;try{(i=t?n.apply(e,t):n.call(e))&&!i._isVue&&f(i)&&!i._handled&&(i.catch((function(n){return we(n,a,r+" (Promise/async)")})),i._handled=!0)}catch(n){we(n,a,r)}return i}function Ae(n,e,t){if(N.errorHandler)try{return N.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ie(e,null,"config.errorHandler")}Ie(n,e,t)}function Ie(n,e,t){if(!$||"undefined"==typeof console)throw n;console.error(n)}var ze,Le=!1,Me=[],je=!1;function Be(){je=!1;var n=Me.slice(0);Me.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&sn(Promise)){var Pe=Promise.resolve();ze=function(){Pe.then(Be),Y&&setTimeout(j)},Le=!0}else if(K||"undefined"==typeof MutationObserver||!sn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())ze="undefined"!=typeof setImmediate&&sn(setImmediate)?function(){setImmediate(Be)}:function(){setTimeout(Be,0)};else{var Oe=1,Re=new MutationObserver(Be),De=document.createTextNode(String(Oe));Re.observe(De,{characterData:!0}),ze=function(){Oe=(Oe+1)%2,De.data=String(Oe)},Le=!0}function Je(n,e){var t;if(Me.push((function(){if(n)try{n.call(e)}catch(n){we(n,e,"nextTick")}else t&&t(e)})),je||(je=!0,ze()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Fe(n){return function(e,t){if(void 0===t&&(t=un),t)return function(n,e,t){var a=n.$options;a[e]=wt(a[e],t)}(t,n,e)}}Fe("beforeMount"),Fe("mounted"),Fe("beforeUpdate"),Fe("updated"),Fe("beforeDestroy"),Fe("destroyed"),Fe("activated"),Fe("deactivated"),Fe("serverPrefetch"),Fe("renderTracked"),Fe("renderTriggered"),Fe("errorCaptured");var qe=new cn;function Ne(n){return function n(e,t){var a,i,o=r(e);if(!o&&!d(e)||e.__v_skip||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var l=e.__ob__.dep.id;if(t.has(l))return;t.add(l)}if(o)for(a=e.length;a--;)n(e[a],t);else if(Jn(e))n(e.value,t);else for(i=Object.keys(e),a=i.length;a--;)n(e[i[a]],t)}(n,qe),qe.clear(),n}var Ue,Ge=0,Ve=function(){function n(n,e,t,a,r){var i,o;i=this,void 0===(o=qn&&!qn._vm?qn:n?n._scope:void 0)&&(o=qn),o&&o.active&&o.effects.push(i),(this.vm=n)&&r&&(n._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ge,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!Q.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=j)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;En(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;we(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Ne(n),Tn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():pt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||d(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ce(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&x(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Qe(n,e){Ue.$on(n,e)}function He(n,e){Ue.$off(n,e)}function $e(n,e){var t=Ue;return function a(){var r=e.apply(null,arguments);null!==r&&t.$off(n,a)}}function Xe(n,e,t){Ue=n,Qn(e,t||{},Qe,He,$e,n),Ue=void 0}var Ke=null;function We(n){var e=Ke;return Ke=n,function(){Ke=e}}function Ze(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Ye(n,e){if(e){if(n._directInactive=!1,Ze(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Ye(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,a){void 0===a&&(a=!0),En();var r=un,i=qn;a&&pn(n);var o=n.$options[e],l="".concat(e," hook");if(o)for(var s=0,c=o.length;s<c;s++)Ce(o[s],n,t||null,n,l);n._hasHookEvent&&n.$emit("hook:"+e),a&&(pn(r),i&&i.on()),Tn()}var et=[],tt=[],at={},rt=!1,it=!1,ot=0;var lt=0,st=Date.now;if($&&!K){var ct=window.performance;ct&&"function"==typeof ct.now&&st()>document.createEvent("Event").timeStamp&&(st=function(){return ct.now()})}var dt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function ut(){var n,e;for(lt=st(),it=!0,et.sort(dt),ot=0;ot<et.length;ot++)(n=et[ot]).before&&n.before(),e=n.id,at[e]=null,n.run();var t=tt.slice(),a=et.slice();ot=et.length=tt.length=0,at={},rt=it=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Ye(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],a=t.vm;a&&a._watcher===t&&a._isMounted&&!a._isDestroyed&&nt(a,"updated")}}(a),function(){for(var n=0;n<bn.length;n++){var e=bn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}bn.length=0}(),ln&&N.devtools&&ln.emit("flush")}function pt(n){var e=n.id;if(null==at[e]&&(n!==yn.target||!n.noRecurse)){if(at[e]=!0,it){for(var t=et.length-1;t>ot&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);rt||(rt=!0,Je(ut))}}function mt(n,e){if(n){for(var t=Object.create(null),a=dn?Reflect.ownKeys(n):Object.keys(n),r=0;r<a.length;r++){var i=a[r];if("__ob__"!==i){var o=n[i].from;if(o in e._provided)t[i]=e._provided[o];else if("default"in n[i]){var l=n[i].default;t[i]=c(l)?l.call(e):l}else 0}}return t}}function ht(n,e,t,i,o){var s,c=this,d=o.options;T(i,"_uid")?(s=Object.create(i))._original=i:(s=i,i=i._original);var u=l(d._compiled),p=!u;this.data=n,this.props=e,this.children=t,this.parent=i,this.listeners=n.on||a,this.injections=mt(d.inject,i),this.slots=function(){return c.$slots||fe(i,n.scopedSlots,c.$slots=pe(t,i)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return fe(i,n.scopedSlots,this.slots())}}),u&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=fe(i,n.scopedSlots,this.$slots)),d._scopeId?this._c=function(n,e,t,a){var o=ke(s,n,e,t,a,p);return o&&!r(o)&&(o.fnScopeId=d._scopeId,o.fnContext=i),o}:this._c=function(n,e,t,a){return ke(s,n,e,t,a,p)}}function ft(n,e,t,a,r){var i=gn(n);return i.fnContext=t,i.fnOptions=a,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function gt(n,e){for(var t in e)n[k(t)]=e[t]}function vt(n){return n.name||n.__name||n._componentTag}ue(ht.prototype);var bt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;bt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},a=n.data.inlineTemplate;o(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ke)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,i){var o=r.data.scopedSlots,l=n.$scopedSlots,s=!!(o&&!o.$stable||l!==a&&!l.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),c=!!(i||n.$options._renderChildren||s),d=n.$vnode;n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r),n.$options._renderChildren=i;var u=r.data.attrs||a;n._attrsProxy&&ye(n._attrsProxy,u,d.data&&d.data.attrs||a,n,"$attrs")&&(c=!0),n.$attrs=u,t=t||a;var p=n.$options._parentListeners;if(n._listenersProxy&&ye(n._listenersProxy,t,p||a,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Xe(n,t,p),e&&n.$options.props){An(!1);for(var m=n._props,h=n.$options._propKeys||[],f=0;f<h.length;f++){var g=h[f],v=n.$options.props;m[g]=Lt(g,v,e,n)}An(!0),n.$options.propsData=e}c&&(n.$slots=pe(i,r.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,a=n.componentInstance;a._isMounted||(a._isMounted=!0,nt(a,"mounted")),n.data.keepAlive&&(t._isMounted?((e=a)._inactive=!1,tt.push(e)):Ye(a,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ze(e))||e._inactive)){e._inactive=!0;for(var a=0;a<e.$children.length;a++)n(e.$children[a]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},yt=Object.keys(bt);function xt(n,e,t,s,c){if(!i(n)){var u=t.$options._base;if(d(n)&&(n=u.extend(n)),"function"==typeof n){var p;if(i(n.cid)&&void 0===(n=function(n,e){if(l(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=Te;if(t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),l(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var a=n.owners=[t],r=!0,s=null,c=null;t.$on("hook:destroyed",(function(){return x(a,t)}));var u=function(n){for(var e=0,t=a.length;e<t;e++)a[e].$forceUpdate();n&&(a.length=0,null!==s&&(clearTimeout(s),s=null),null!==c&&(clearTimeout(c),c=null))},p=D((function(t){n.resolved=_e(t,e),r?a.length=0:u(!0)})),m=D((function(e){o(n.errorComp)&&(n.error=!0,u(!0))})),h=n(p,m);return d(h)&&(f(h)?i(n.resolved)&&h.then(p,m):f(h.component)&&(h.component.then(p,m),o(h.error)&&(n.errorComp=_e(h.error,e)),o(h.loading)&&(n.loadingComp=_e(h.loading,e),0===h.delay?n.loading=!0:s=setTimeout((function(){s=null,i(n.resolved)&&i(n.error)&&(n.loading=!0,u(!1))}),h.delay||200)),o(h.timeout)&&(c=setTimeout((function(){c=null,i(n.resolved)&&m(null)}),h.timeout)))),r=!1,n.loading?n.loadingComp:n.resolved}}(p=n,u)))return function(n,e,t,a,r){var i=hn();return i.asyncFactory=n,i.asyncMeta={data:e,context:t,children:a,tag:r},i}(p,e,t,s,c);e=e||{},Vt(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",a=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),l=i[a],s=e.model.callback;o(l)?(r(l)?-1===l.indexOf(s):l!==s)&&(i[a]=[s].concat(l)):i[a]=s}(n.options,e);var m=function(n,e,t){var a=e.options.props;if(!i(a)){var r={},l=n.attrs,s=n.props;if(o(l)||o(s))for(var c in a){var d=A(c);$n(r,s,c,d,!0)||$n(r,l,c,d,!1)}return r}}(e,n);if(l(n.options.functional))return function(n,e,t,i,l){var s=n.options,c={},d=s.props;if(o(d))for(var u in d)c[u]=Lt(u,d,e||a);else o(t.attrs)&&gt(c,t.attrs),o(t.props)&&gt(c,t.props);var p=new ht(t,c,l,i,n),m=s.render.call(null,p._c,p);if(m instanceof mn)return ft(m,t,p.parent,s,p);if(r(m)){for(var h=Xn(m)||[],f=new Array(h.length),g=0;g<h.length;g++)f[g]=ft(h[g],t,p.parent,s,p);return f}}(n,m,e,t,s);var h=e.on;if(e.on=e.nativeOn,l(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<yt.length;t++){var a=yt[t],r=e[a],i=bt[a];r===i||r&&r._merged||(e[a]=r?Et(i,r):i)}}(e);var v=vt(n.options)||c;return new mn("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:c,children:s},p)}}}function Et(n,e){var t=function(t,a){n(t,a),e(t,a)};return t._merged=!0,t}var Tt=j,_t=N.optionMergeStrategies;function St(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var a,r,i,o=dn?Reflect.ownKeys(e):Object.keys(e),l=0;l<o.length;l++)"__ob__"!==(a=o[l])&&(r=n[a],i=e[a],t&&T(n,a)?r!==i&&p(r)&&p(i)&&St(r,i):jn(n,a,i));return n}function kt(n,e,t){return t?function(){var a=c(e)?e.call(t,t):e,r=c(n)?n.call(t,t):n;return a?St(a,r):r}:e?n?function(){return St(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function wt(n,e){var t=e?n?n.concat(e):r(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Ct(n,e,t,a){var r=Object.create(n||null);return e?L(r,e):r}_t.data=function(n,e,t){return t?kt(n,e,t):e&&"function"!=typeof e?n:kt(n,e)},q.forEach((function(n){_t[n]=wt})),F.forEach((function(n){_t[n+"s"]=Ct})),_t.watch=function(n,e,t,a){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var o in L(i,n),e){var l=i[o],s=e[o];l&&!r(l)&&(l=[l]),i[o]=l?l.concat(s):r(s)?s:[s]}return i},_t.props=_t.methods=_t.inject=_t.computed=function(n,e,t,a){if(!n)return e;var r=Object.create(null);return L(r,n),e&&L(r,e),r},_t.provide=function(n,e){return n?function(){var t=Object.create(null);return St(t,c(n)?n.call(this):n),e&&St(t,c(e)?e.call(this):e,!1),t}:e};var At=function(n,e){return void 0===e?n:e};function It(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var a,i,o={};if(r(t))for(a=t.length;a--;)"string"==typeof(i=t[a])&&(o[k(i)]={type:null});else if(p(t))for(var l in t)i=t[l],o[k(l)]=p(i)?i:{type:i};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var a=n.inject={};if(r(t))for(var i=0;i<t.length;i++)a[t[i]]={from:t[i]};else if(p(t))for(var o in t){var l=t[o];a[o]=p(l)?L({from:o},l):{from:l}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var a=e[t];c(a)&&(e[t]={bind:a,update:a})}}(e),!e._base&&(e.extends&&(n=It(n,e.extends,t)),e.mixins))for(var a=0,i=e.mixins.length;a<i;a++)n=It(n,e.mixins[a],t);var o,l={};for(o in n)s(o);for(o in e)T(n,o)||s(o);function s(a){var r=_t[a]||At;l[a]=r(n[a],e[a],t,a)}return l}function zt(n,e,t,a){if("string"==typeof t){var r=n[e];if(T(r,t))return r[t];var i=k(t);if(T(r,i))return r[i];var o=w(i);return T(r,o)?r[o]:r[t]||r[i]||r[o]}}function Lt(n,e,t,a){var r=e[n],i=!T(t,n),o=t[n],l=Pt(Boolean,r.type);if(l>-1)if(i&&!T(r,"default"))o=!1;else if(""===o||o===A(n)){var s=Pt(String,r.type);(s<0||l<s)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!T(e,"default"))return;var a=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(a)&&"Function"!==jt(e.type)?a.call(n):a}(a,r,n);var d=Cn;An(!0),Ln(o),An(d)}return o}var Mt=/^\s*function (\w+)/;function jt(n){var e=n&&n.toString().match(Mt);return e?e[1]:""}function Bt(n,e){return jt(n)===jt(e)}function Pt(n,e){if(!r(e))return Bt(e,n)?0:-1;for(var t=0,a=e.length;t<a;t++)if(Bt(e[t],n))return t;return-1}var Ot={enumerable:!0,configurable:!0,get:j,set:j};function Rt(n,e,t){Ot.get=function(){return this[e][t]},Ot.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Ot)}function Dt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},a=n._props=On({}),r=n.$options._propKeys=[];n.$parent&&An(!1);var i=function(i){r.push(i);var o=Lt(i,e,t,n);Mn(a,i,o),i in n||Rt(n,"_props",i)};for(var o in e)i(o);An(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var a=n._setupContext=be(n);pn(n),En();var r=Ce(t,null,[n._props||On({}),a],n,"setup");if(Tn(),pn(),c(r))e.render=r;else if(d(r))if(n._setupState=r,r.__sfc){var i=n._setupProxy={};for(var o in r)"__sfc"!==o&&Fn(i,r,o)}else for(var o in r)G(o)||Fn(n,r,o);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?j:I(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=c(e)?function(n,e){En();try{return n.call(e,e)}catch(n){return we(n,e,"data()"),{}}finally{Tn()}}(e,n):e||{})||(e={});var t=Object.keys(e),a=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var i=t[r];0,a&&T(a,i)||G(i)||Rt(n,"_data",i)}var o=Ln(e);o&&o.vmCount++}(n);else{var t=Ln(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),a=on();for(var r in e){var i=e[r],o=c(i)?i:i.get;0,a||(t[r]=new Ve(n,o||j,j,Jt)),r in n||Ft(n,r,i)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var a=e[t];if(r(a))for(var i=0;i<a.length;i++)Ut(n,t,a[i]);else Ut(n,t,a)}}(n,e.watch)}var Jt={lazy:!0};function Ft(n,e,t){var a=!on();c(t)?(Ot.get=a?qt(e):Nt(t),Ot.set=j):(Ot.get=t.get?a&&!1!==t.cache?qt(e):Nt(t.get):j,Ot.set=t.set||j),Object.defineProperty(n,e,Ot)}function qt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),yn.target&&e.depend(),e.value}}function Nt(n){return function(){return n.call(this,this)}}function Ut(n,e,t,a){return p(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,a)}var Gt=0;function Vt(n){var e=n.options;if(n.super){var t=Vt(n.super);if(t!==n.superOptions){n.superOptions=t;var a=function(n){var e,t=n.options,a=n.sealedOptions;for(var r in t)t[r]!==a[r]&&(e||(e={}),e[r]=t[r]);return e}(n);a&&L(n.extendOptions,a),(e=n.options=It(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Qt(n){this._init(n)}function Ht(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,a=t.cid,r=n._Ctor||(n._Ctor={});if(r[a])return r[a];var i=vt(n)||vt(t.options);var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=It(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)Rt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)Ft(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,F.forEach((function(n){o[n]=t[n]})),i&&(o.options.components[i]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=L({},o.options),r[a]=o,o}}function $t(n){return n&&(vt(n.Ctor.options)||n.tag)}function Xt(n,e){return r(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Kt(n,e){var t=n.cache,a=n.keys,r=n._vnode;for(var i in t){var o=t[i];if(o){var l=o.name;l&&!e(l)&&Wt(t,i,a,r)}}}function Wt(n,e,t,a){var r=n[e];!r||a&&r.tag===a.tag||r.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Gt++,e._isVue=!0,e.__v_skip=!0,e._scope=new Nn(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),a=e._parentVnode;t.parent=e.parent,t._parentVnode=a;var r=a.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=It(Vt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Xe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=pe(e._renderChildren,r),n.$scopedSlots=t?fe(n.$parent,t.data.scopedSlots,n.$slots):a,n._c=function(e,t,a,r){return ke(n,e,t,a,r,!1)},n.$createElement=function(e,t,a,r){return ke(n,e,t,a,r,!0)};var i=t&&t.data;Mn(n,"$attrs",i&&i.attrs||a,null,!0),Mn(n,"$listeners",e._parentListeners||a,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=mt(n.$options.inject,n);e&&(An(!1),Object.keys(e).forEach((function(t){Mn(n,t,e[t])})),An(!0))}(e),Dt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!d(t))return;for(var a=Un(n),r=dn?Reflect.ownKeys(t):Object.keys(t),i=0;i<r.length;i++){var o=r[i];Object.defineProperty(a,o,Object.getOwnPropertyDescriptor(t,o))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Qt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=jn,n.prototype.$delete=Bn,n.prototype.$watch=function(n,e,t){if(p(e))return Ut(this,n,e,t);(t=t||{}).user=!0;var a=new Ve(this,n,e,t);if(t.immediate){var r='callback for immediate watcher "'.concat(a.expression,'"');En(),Ce(e,this,[a.value],this,r),Tn()}return function(){a.teardown()}}}(Qt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var a=this;if(r(n))for(var i=0,o=n.length;i<o;i++)a.$on(n[i],t);else(a._events[n]||(a._events[n]=[])).push(t),e.test(n)&&(a._hasHookEvent=!0);return a},n.prototype.$once=function(n,e){var t=this;function a(){t.$off(n,a),e.apply(t,arguments)}return a.fn=e,t.$on(n,a),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(r(n)){for(var a=0,i=n.length;a<i;a++)t.$off(n[a],e);return t}var o,l=t._events[n];if(!l)return t;if(!e)return t._events[n]=null,t;for(var s=l.length;s--;)if((o=l[s])===e||o.fn===e){l.splice(s,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?z(t):t;for(var a=z(arguments,1),r='event handler for "'.concat(n,'"'),i=0,o=t.length;i<o;i++)Ce(t[i],e,a,e,r)}return e}}(Qt),function(n){n.prototype._update=function(n,e){var t=this,a=t.$el,r=t._vnode,i=We(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),i(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var o=t;o&&o.$vnode&&o.$parent&&o.$vnode===o.$parent._vnode;)o.$parent.$el=o.$el,o=o.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Qt),function(n){ue(n.prototype),n.prototype.$nextTick=function(n){return Je(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,a=t.render,i=t._parentVnode;i&&e._isMounted&&(e.$scopedSlots=fe(e.$parent,i.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&Ee(e._slotsProxy,e.$scopedSlots)),e.$vnode=i;try{pn(e),Te=e,n=a.call(e._renderProxy,e.$createElement)}catch(t){we(t,e,"render"),n=e._vnode}finally{Te=null,pn()}return r(n)&&1===n.length&&(n=n[0]),n instanceof mn||(n=hn()),n.parent=i,n}}(Qt);var Zt=[String,RegExp,Array],Yt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Zt,exclude:Zt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var r=t.tag,i=t.componentInstance,o=t.componentOptions;n[a]={name:$t(o),tag:r,componentInstance:i},e.push(a),this.max&&e.length>parseInt(this.max)&&Wt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Wt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Kt(n,(function(n){return Xt(e,n)}))})),this.$watch("exclude",(function(e){Kt(n,(function(n){return!Xt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Se(n),t=e&&e.componentOptions;if(t){var a=$t(t),r=this.include,i=this.exclude;if(r&&(!a||!Xt(r,a))||i&&a&&Xt(i,a))return e;var o=this.cache,l=this.keys,s=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;o[s]?(e.componentInstance=o[s].componentInstance,x(l,s),l.push(s)):(this.vnodeToCache=e,this.keyToCache=s),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return N}};Object.defineProperty(n,"config",e),n.util={warn:Tt,extend:L,mergeOptions:It,defineReactive:Mn},n.set=jn,n.delete=Bn,n.nextTick=Je,n.observable=function(n){return Ln(n),n},n.options=Object.create(null),F.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,L(n.options.components,Yt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=z(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=It(this.options,n),this}}(n),Ht(n),function(n){F.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Qt),Object.defineProperty(Qt.prototype,"$isServer",{get:on}),Object.defineProperty(Qt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Qt,"FunctionalRenderContext",{value:ht}),Qt.version="2.7.15";var na=b("style,class"),ea=b("input,textarea,option,select,progress"),ta=b("contenteditable,draggable,spellcheck"),aa=b("events,caret,typing,plaintext-only"),ra=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ia="http://www.w3.org/1999/xlink",oa=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},la=function(n){return oa(n)?n.slice(6,n.length):""},sa=function(n){return null==n||!1===n};function ca(n){for(var e=n.data,t=n,a=n;o(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(e=da(a.data,e));for(;o(t=t.parent);)t&&t.data&&(e=da(e,t.data));return function(n,e){if(o(n)||o(e))return ua(n,pa(e));return""}(e.staticClass,e.class)}function da(n,e){return{staticClass:ua(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function ua(n,e){return n?e?n+" "+e:n:e||""}function pa(n){return Array.isArray(n)?function(n){for(var e,t="",a=0,r=n.length;a<r;a++)o(e=pa(n[a]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):d(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var ma={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ha=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),fa=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),ga=function(n){return ha(n)||fa(n)};var va=Object.create(null);var ba=b("text,number,password,search,email,tel,url");var ya=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(ma[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),xa={create:function(n,e){Ea(e)},update:function(n,e){n.data.ref!==e.data.ref&&(Ea(n,!0),Ea(e))},destroy:function(n){Ea(n,!0)}};function Ea(n,e){var t=n.data.ref;if(o(t)){var a=n.context,i=n.componentInstance||n.elm,l=e?null:i,s=e?void 0:i;if(c(t))Ce(t,a,[l],a,"template ref function");else{var d=n.data.refInFor,u="string"==typeof t||"number"==typeof t,p=Jn(t),m=a.$refs;if(u||p)if(d){var h=u?m[t]:t.value;e?r(h)&&x(h,i):r(h)?h.includes(i)||h.push(i):u?(m[t]=[i],Ta(a,t,m[t])):t.value=[i]}else if(u){if(e&&m[t]!==i)return;m[t]=s,Ta(a,t,l)}else if(p){if(e&&t.value!==i)return;t.value=l}else 0}}}function Ta(n,e,t){var a=n._setupState;a&&T(a,e)&&(Jn(a[e])?a[e].value=t:a[e]=t)}var _a=new mn("",{},[]),Sa=["create","activate","update","remove","destroy"];function ka(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,a=o(t=n.data)&&o(t=t.attrs)&&t.type,r=o(t=e.data)&&o(t=t.attrs)&&t.type;return a===r||ba(a)&&ba(r)}(n,e)||l(n.isAsyncPlaceholder)&&i(e.asyncFactory.error))}function wa(n,e,t){var a,r,i={};for(a=e;a<=t;++a)o(r=n[a].key)&&(i[r]=a);return i}var Ca={create:Aa,update:Aa,destroy:function(n){Aa(n,_a)}};function Aa(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,a,r,i=n===_a,o=e===_a,l=za(n.data.directives,n.context),s=za(e.data.directives,e.context),c=[],d=[];for(t in s)a=l[t],r=s[t],a?(r.oldValue=a.value,r.oldArg=a.arg,Ma(r,"update",e,n),r.def&&r.def.componentUpdated&&d.push(r)):(Ma(r,"bind",e,n),r.def&&r.def.inserted&&c.push(r));if(c.length){var u=function(){for(var t=0;t<c.length;t++)Ma(c[t],"inserted",e,n)};i?Hn(e,"insert",u):u()}d.length&&Hn(e,"postpatch",(function(){for(var t=0;t<d.length;t++)Ma(d[t],"componentUpdated",e,n)}));if(!i)for(t in l)s[t]||Ma(l[t],"unbind",n,n,o)}(n,e)}var Ia=Object.create(null);function za(n,e){var t,a,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++){if((a=n[t]).modifiers||(a.modifiers=Ia),r[La(a)]=a,e._setupState&&e._setupState.__sfc){var i=a.def||zt(e,"_setupState","v-"+a.name);a.def="function"==typeof i?{bind:i,update:i}:i}a.def=a.def||zt(e.$options,"directives",a.name)}return r}function La(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Ma(n,e,t,a,r){var i=n.def&&n.def[e];if(i)try{i(t.elm,n,t,a,r)}catch(a){we(a,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var ja=[xa,Ca];function Ba(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||i(n.data.attrs)&&i(e.data.attrs))){var a,r,s=e.elm,c=n.data.attrs||{},d=e.data.attrs||{};for(a in(o(d.__ob__)||l(d._v_attr_proxy))&&(d=e.data.attrs=L({},d)),d)r=d[a],c[a]!==r&&Pa(s,a,r,e.data.pre);for(a in(K||Z)&&d.value!==c.value&&Pa(s,"value",d.value),c)i(d[a])&&(oa(a)?s.removeAttributeNS(ia,la(a)):ta(a)||s.removeAttribute(a))}}function Pa(n,e,t,a){a||n.tagName.indexOf("-")>-1?Oa(n,e,t):ra(e)?sa(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):ta(e)?n.setAttribute(e,function(n,e){return sa(e)||"false"===e?"false":"contenteditable"===n&&aa(e)?e:"true"}(e,t)):oa(e)?sa(t)?n.removeAttributeNS(ia,la(e)):n.setAttributeNS(ia,e,t):Oa(n,e,t)}function Oa(n,e,t){if(sa(t))n.removeAttribute(e);else{if(K&&!W&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var a=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",a)};n.addEventListener("input",a),n.__ieph=!0}n.setAttribute(e,t)}}var Ra={create:Ba,update:Ba};function Da(n,e){var t=e.elm,a=e.data,r=n.data;if(!(i(a.staticClass)&&i(a.class)&&(i(r)||i(r.staticClass)&&i(r.class)))){var l=ca(e),s=t._transitionClasses;o(s)&&(l=ua(l,pa(s))),l!==t._prevClass&&(t.setAttribute("class",l),t._prevClass=l)}}var Ja,Fa={create:Da,update:Da};function qa(n,e,t){var a=Ja;return function r(){var i=e.apply(null,arguments);null!==i&&Ga(n,r,t,a)}}var Na=Le&&!(en&&Number(en[1])<=53);function Ua(n,e,t,a){if(Na){var r=lt,i=e;e=i._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return i.apply(this,arguments)}}Ja.addEventListener(n,e,an?{capture:t,passive:a}:t)}function Ga(n,e,t,a){(a||Ja).removeEventListener(n,e._wrapper||e,t)}function Va(n,e){if(!i(n.data.on)||!i(e.data.on)){var t=e.data.on||{},a=n.data.on||{};Ja=e.elm||n.elm,function(n){if(o(n.__r)){var e=K?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Qn(t,a,Ua,Ga,qa,e.context),Ja=void 0}}var Qa,Ha={create:Va,update:Va,destroy:function(n){return Va(n,_a)}};function $a(n,e){if(!i(n.data.domProps)||!i(e.data.domProps)){var t,a,r=e.elm,s=n.data.domProps||{},c=e.data.domProps||{};for(t in(o(c.__ob__)||l(c._v_attr_proxy))&&(c=e.data.domProps=L({},c)),s)t in c||(r[t]="");for(t in c){if(a=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),a===s[t])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===t&&"PROGRESS"!==r.tagName){r._value=a;var d=i(a)?"":String(a);Xa(r,d)&&(r.value=d)}else if("innerHTML"===t&&fa(r.tagName)&&i(r.innerHTML)){(Qa=Qa||document.createElement("div")).innerHTML="<svg>".concat(a,"</svg>");for(var u=Qa.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;u.firstChild;)r.appendChild(u.firstChild)}else if(a!==s[t])try{r[t]=a}catch(n){}}}}function Xa(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,a=n._vModifiers;if(o(a)){if(a.number)return v(t)!==v(e);if(a.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Ka={create:$a,update:$a},Wa=_((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var a=n.split(t);a.length>1&&(e[a[0].trim()]=a[1].trim())}})),e}));function Za(n){var e=Ya(n.style);return n.staticStyle?L(n.staticStyle,e):e}function Ya(n){return Array.isArray(n)?M(n):"string"==typeof n?Wa(n):n}var nr,er=/^--/,tr=/\s*!important$/,ar=function(n,e,t){if(er.test(e))n.style.setProperty(e,t);else if(tr.test(t))n.style.setProperty(A(e),t.replace(tr,""),"important");else{var a=ir(e);if(Array.isArray(t))for(var r=0,i=t.length;r<i;r++)n.style[a]=t[r];else n.style[a]=t}},rr=["Webkit","Moz","ms"],ir=_((function(n){if(nr=nr||document.createElement("div").style,"filter"!==(n=k(n))&&n in nr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<rr.length;t++){var a=rr[t]+e;if(a in nr)return a}}));function or(n,e){var t=e.data,a=n.data;if(!(i(t.staticStyle)&&i(t.style)&&i(a.staticStyle)&&i(a.style))){var r,l,s=e.elm,c=a.staticStyle,d=a.normalizedStyle||a.style||{},u=c||d,p=Ya(e.data.style)||{};e.data.normalizedStyle=o(p.__ob__)?L({},p):p;var m=function(n,e){var t,a={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=Za(r.data))&&L(a,t);(t=Za(n.data))&&L(a,t);for(var i=n;i=i.parent;)i.data&&(t=Za(i.data))&&L(a,t);return a}(e,!0);for(l in u)i(m[l])&&ar(s,l,"");for(l in m)(r=m[l])!==u[l]&&ar(s,l,null==r?"":r)}}var lr={create:or,update:or},sr=/\s+/;function cr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(sr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function dr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(sr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),a=" "+e+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ur(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&L(e,pr(n.name||"v")),L(e,n),e}return"string"==typeof n?pr(n):void 0}}var pr=_((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),mr=$&&!W,hr="transition",fr="transitionend",gr="animation",vr="animationend";mr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(hr="WebkitTransition",fr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(gr="WebkitAnimation",vr="webkitAnimationEnd"));var br=$?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function yr(n){br((function(){br(n)}))}function xr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),cr(n,e))}function Er(n,e){n._transitionClasses&&x(n._transitionClasses,e),dr(n,e)}function Tr(n,e,t){var a=Sr(n,e),r=a.type,i=a.timeout,o=a.propCount;if(!r)return t();var l="transition"===r?fr:vr,s=0,c=function(){n.removeEventListener(l,d),t()},d=function(e){e.target===n&&++s>=o&&c()};setTimeout((function(){s<o&&c()}),i+1),n.addEventListener(l,d)}var _r=/\b(transform|all)(,|$)/;function Sr(n,e){var t,a=window.getComputedStyle(n),r=(a[hr+"Delay"]||"").split(", "),i=(a[hr+"Duration"]||"").split(", "),o=kr(r,i),l=(a[gr+"Delay"]||"").split(", "),s=(a[gr+"Duration"]||"").split(", "),c=kr(l,s),d=0,u=0;return"transition"===e?o>0&&(t="transition",d=o,u=i.length):"animation"===e?c>0&&(t="animation",d=c,u=s.length):u=(t=(d=Math.max(o,c))>0?o>c?"transition":"animation":null)?"transition"===t?i.length:s.length:0,{type:t,timeout:d,propCount:u,hasTransform:"transition"===t&&_r.test(a[hr+"Property"])}}function kr(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return wr(e)+wr(n[t])})))}function wr(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Cr(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=ur(n.data.transition);if(!i(a)&&!o(t._enterCb)&&1===t.nodeType){for(var r=a.css,l=a.type,s=a.enterClass,u=a.enterToClass,p=a.enterActiveClass,m=a.appearClass,h=a.appearToClass,f=a.appearActiveClass,g=a.beforeEnter,b=a.enter,y=a.afterEnter,x=a.enterCancelled,E=a.beforeAppear,T=a.appear,_=a.afterAppear,S=a.appearCancelled,k=a.duration,w=Ke,C=Ke.$vnode;C&&C.parent;)w=C.context,C=C.parent;var A=!w._isMounted||!n.isRootInsert;if(!A||T||""===T){var I=A&&m?m:s,z=A&&f?f:p,L=A&&h?h:u,M=A&&E||g,j=A&&c(T)?T:b,B=A&&_||y,P=A&&S||x,O=v(d(k)?k.enter:k);0;var R=!1!==r&&!W,J=zr(j),F=t._enterCb=D((function(){R&&(Er(t,L),Er(t,z)),F.cancelled?(R&&Er(t,I),P&&P(t)):B&&B(t),t._enterCb=null}));n.data.show||Hn(n,"insert",(function(){var e=t.parentNode,a=e&&e._pending&&e._pending[n.key];a&&a.tag===n.tag&&a.elm._leaveCb&&a.elm._leaveCb(),j&&j(t,F)})),M&&M(t),R&&(xr(t,I),xr(t,z),yr((function(){Er(t,I),F.cancelled||(xr(t,L),J||(Ir(O)?setTimeout(F,O):Tr(t,l,F)))}))),n.data.show&&(e&&e(),j&&j(t,F)),R||J||F()}}}function Ar(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=ur(n.data.transition);if(i(a)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var r=a.css,l=a.type,s=a.leaveClass,c=a.leaveToClass,u=a.leaveActiveClass,p=a.beforeLeave,m=a.leave,h=a.afterLeave,f=a.leaveCancelled,g=a.delayLeave,b=a.duration,y=!1!==r&&!W,x=zr(m),E=v(d(b)?b.leave:b);0;var T=t._leaveCb=D((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(Er(t,c),Er(t,u)),T.cancelled?(y&&Er(t,s),f&&f(t)):(e(),h&&h(t)),t._leaveCb=null}));g?g(_):_()}function _(){T.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),y&&(xr(t,s),xr(t,u),yr((function(){Er(t,s),T.cancelled||(xr(t,c),x||(Ir(E)?setTimeout(T,E):Tr(t,l,T)))}))),m&&m(t,T),y||x||T())}}function Ir(n){return"number"==typeof n&&!isNaN(n)}function zr(n){if(i(n))return!1;var e=n.fns;return o(e)?zr(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Lr(n,e){!0!==e.data.show&&Cr(e)}var Mr=function(n){var e,t,a={},c=n.modules,d=n.nodeOps;for(e=0;e<Sa.length;++e)for(a[Sa[e]]=[],t=0;t<c.length;++t)o(c[t][Sa[e]])&&a[Sa[e]].push(c[t][Sa[e]]);function u(n){var e=d.parentNode(n);o(e)&&d.removeChild(e,n)}function p(n,e,t,r,i,s,c){if(o(n.elm)&&o(s)&&(n=s[c]=gn(n)),n.isRootInsert=!i,!function(n,e,t,r){var i=n.data;if(o(i)){var s=o(n.componentInstance)&&i.keepAlive;if(o(i=i.hook)&&o(i=i.init)&&i(n,!1),o(n.componentInstance))return m(n,e),h(t,n.elm,r),l(s)&&function(n,e,t,r){var i,l=n;for(;l.componentInstance;)if(l=l.componentInstance._vnode,o(i=l.data)&&o(i=i.transition)){for(i=0;i<a.activate.length;++i)a.activate[i](_a,l);e.push(l);break}h(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var u=n.data,p=n.children,g=n.tag;o(g)?(n.elm=n.ns?d.createElementNS(n.ns,g):d.createElement(g,n),y(n),f(n,p,e),o(u)&&v(n,e),h(t,n.elm,r)):l(n.isComment)?(n.elm=d.createComment(n.text),h(t,n.elm,r)):(n.elm=d.createTextNode(n.text),h(t,n.elm,r))}}function m(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(v(n,e),y(n)):(Ea(n),e.push(n))}function h(n,e,t){o(n)&&(o(t)?d.parentNode(t)===n&&d.insertBefore(n,e,t):d.appendChild(n,e))}function f(n,e,t){if(r(e)){0;for(var a=0;a<e.length;++a)p(e[a],t,n.elm,null,!0,e,a)}else s(n.text)&&d.appendChild(n.elm,d.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function v(n,t){for(var r=0;r<a.create.length;++r)a.create[r](_a,n);o(e=n.data.hook)&&(o(e.create)&&e.create(_a,n),o(e.insert)&&t.push(n))}function y(n){var e;if(o(e=n.fnScopeId))d.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e),t=t.parent;o(e=Ke)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e)}function x(n,e,t,a,r,i){for(;a<=r;++a)p(t[a],i,n,e,!1,t,a)}function E(n){var e,t,r=n.data;if(o(r))for(o(e=r.hook)&&o(e=e.destroy)&&e(n),e=0;e<a.destroy.length;++e)a.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)E(n.children[t])}function T(n,e,t){for(;e<=t;++e){var a=n[e];o(a)&&(o(a.tag)?(_(a),E(a)):u(a.elm))}}function _(n,e){if(o(e)||o(n.data)){var t,r=a.remove.length+1;for(o(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,r),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&_(t,e),t=0;t<a.remove.length;++t)a.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else u(n.elm)}function S(n,e,t,a){for(var r=t;r<a;r++){var i=e[r];if(o(i)&&ka(n,i))return r}}function k(n,e,t,r,s,c){if(n!==e){o(e.elm)&&o(r)&&(e=r[s]=gn(e));var u=e.elm=n.elm;if(l(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?A(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(l(e.isStatic)&&l(n.isStatic)&&e.key===n.key&&(l(e.isCloned)||l(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;o(h)&&o(m=h.hook)&&o(m=m.prepatch)&&m(n,e);var f=n.children,v=e.children;if(o(h)&&g(e)){for(m=0;m<a.update.length;++m)a.update[m](n,e);o(m=h.hook)&&o(m=m.update)&&m(n,e)}i(e.text)?o(f)&&o(v)?f!==v&&function(n,e,t,a,r){var l,s,c,u=0,m=0,h=e.length-1,f=e[0],g=e[h],v=t.length-1,b=t[0],y=t[v],E=!r;for(0;u<=h&&m<=v;)i(f)?f=e[++u]:i(g)?g=e[--h]:ka(f,b)?(k(f,b,a,t,m),f=e[++u],b=t[++m]):ka(g,y)?(k(g,y,a,t,v),g=e[--h],y=t[--v]):ka(f,y)?(k(f,y,a,t,v),E&&d.insertBefore(n,f.elm,d.nextSibling(g.elm)),f=e[++u],y=t[--v]):ka(g,b)?(k(g,b,a,t,m),E&&d.insertBefore(n,g.elm,f.elm),g=e[--h],b=t[++m]):(i(l)&&(l=wa(e,u,h)),i(s=o(b.key)?l[b.key]:S(b,e,u,h))?p(b,a,n,f.elm,!1,t,m):ka(c=e[s],b)?(k(c,b,a,t,m),e[s]=void 0,E&&d.insertBefore(n,c.elm,f.elm)):p(b,a,n,f.elm,!1,t,m),b=t[++m]);u>h?x(n,i(t[v+1])?null:t[v+1].elm,t,m,v,a):m>v&&T(e,u,h)}(u,f,v,t,c):o(v)?(o(n.text)&&d.setTextContent(u,""),x(u,null,v,0,v.length-1,t)):o(f)?T(f,0,f.length-1):o(n.text)&&d.setTextContent(u,""):n.text!==e.text&&d.setTextContent(u,e.text),o(h)&&o(m=h.hook)&&o(m=m.postpatch)&&m(n,e)}}}function w(n,e,t){if(l(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var a=0;a<e.length;++a)e[a].data.hook.insert(e[a])}var C=b("attrs,class,staticClass,staticStyle,key");function A(n,e,t,a){var r,i=e.tag,s=e.data,c=e.children;if(a=a||s&&s.pre,e.elm=n,l(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(s)&&(o(r=s.hook)&&o(r=r.init)&&r(e,!0),o(r=e.componentInstance)))return m(e,t),!0;if(o(i)){if(o(c))if(n.hasChildNodes())if(o(r=s)&&o(r=r.domProps)&&o(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var d=!0,u=n.firstChild,p=0;p<c.length;p++){if(!u||!A(u,c[p],t,a)){d=!1;break}u=u.nextSibling}if(!d||u)return!1}else f(e,c,t);if(o(s)){var h=!1;for(var g in s)if(!C(g)){h=!0,v(e,t);break}!h&&s.class&&Ne(s.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,r){if(!i(e)){var s,c=!1,u=[];if(i(n))c=!0,p(e,u);else{var m=o(n.nodeType);if(!m&&ka(n,e))k(n,e,u,null,null,r);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),l(t)&&A(n,e,u))return w(e,u,!0),n;s=n,n=new mn(d.tagName(s).toLowerCase(),{},[],void 0,s)}var h=n.elm,f=d.parentNode(h);if(p(e,u,h._leaveCb?null:f,d.nextSibling(h)),o(e.parent))for(var v=e.parent,b=g(e);v;){for(var y=0;y<a.destroy.length;++y)a.destroy[y](v);if(v.elm=e.elm,b){for(var x=0;x<a.create.length;++x)a.create[x](_a,v);var _=v.data.hook.insert;if(_.merged)for(var S=_.fns.slice(1),C=0;C<S.length;C++)S[C]()}else Ea(v);v=v.parent}o(f)?T([n],0,0):o(n.tag)&&E(n)}}return w(e,u,c),e.elm}o(n)&&E(n)}}({nodeOps:ya,modules:[Ra,Fa,Ha,Ka,lr,$?{create:Lr,activate:Lr,remove:function(n,e){!0!==n.data.show?Ar(n,e):e()}}:{}].concat(ja)});W&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Fr(n,"input")}));var jr={inserted:function(n,e,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?Hn(t,"postpatch",(function(){jr.componentUpdated(n,e,t)})):Br(n,e,t.context),n._vOptions=[].map.call(n.options,Rr)):("textarea"===t.tag||ba(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Dr),n.addEventListener("compositionend",Jr),n.addEventListener("change",Jr),W&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Br(n,e,t.context);var a=n._vOptions,r=n._vOptions=[].map.call(n.options,Rr);if(r.some((function(n,e){return!O(n,a[e])})))(n.multiple?e.value.some((function(n){return Or(n,r)})):e.value!==e.oldValue&&Or(e.value,r))&&Fr(n,"change")}}};function Br(n,e,t){Pr(n,e,t),(K||Z)&&setTimeout((function(){Pr(n,e,t)}),0)}function Pr(n,e,t){var a=e.value,r=n.multiple;if(!r||Array.isArray(a)){for(var i,o,l=0,s=n.options.length;l<s;l++)if(o=n.options[l],r)i=R(a,Rr(o))>-1,o.selected!==i&&(o.selected=i);else if(O(Rr(o),a))return void(n.selectedIndex!==l&&(n.selectedIndex=l));r||(n.selectedIndex=-1)}}function Or(n,e){return e.every((function(e){return!O(e,n)}))}function Rr(n){return"_value"in n?n._value:n.value}function Dr(n){n.target.composing=!0}function Jr(n){n.target.composing&&(n.target.composing=!1,Fr(n.target,"input"))}function Fr(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function qr(n){return!n.componentInstance||n.data&&n.data.transition?n:qr(n.componentInstance._vnode)}var Nr={model:jr,show:{bind:function(n,e,t){var a=e.value,r=(t=qr(t)).data&&t.data.transition,i=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;a&&r?(t.data.show=!0,Cr(t,(function(){n.style.display=i}))):n.style.display=a?i:"none"},update:function(n,e,t){var a=e.value;!a!=!e.oldValue&&((t=qr(t)).data&&t.data.transition?(t.data.show=!0,a?Cr(t,(function(){n.style.display=n.__vOriginalDisplay})):Ar(t,(function(){n.style.display="none"}))):n.style.display=a?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,a,r){r||(n.style.display=n.__vOriginalDisplay)}}},Ur={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Gr(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Gr(Se(e.children)):n}function Vr(n){var e={},t=n.$options;for(var a in t.propsData)e[a]=n[a];var r=t._parentListeners;for(var a in r)e[k(a)]=r[a];return e}function Qr(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Hr=function(n){return n.tag||he(n)},$r=function(n){return"show"===n.name},Xr={name:"transition",props:Ur,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Hr)).length){0;var a=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var i=Gr(r);if(!i)return r;if(this._leaving)return Qr(n,r);var o="__transition-".concat(this._uid,"-");i.key=null==i.key?i.isComment?o+"comment":o+i.tag:s(i.key)?0===String(i.key).indexOf(o)?i.key:o+i.key:i.key;var l=(i.data||(i.data={})).transition=Vr(this),c=this._vnode,d=Gr(c);if(i.data.directives&&i.data.directives.some($r)&&(i.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(i,d)&&!he(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var u=d.data.transition=L({},l);if("out-in"===a)return this._leaving=!0,Hn(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Qr(n,r);if("in-out"===a){if(he(i))return c;var p,m=function(){p()};Hn(l,"afterEnter",m),Hn(l,"enterCancelled",m),Hn(u,"delayLeave",(function(n){p=n}))}}return r}}},Kr=L({tag:String,moveClass:String},Ur);function Wr(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Zr(n){n.data.newPos=n.elm.getBoundingClientRect()}function Yr(n){var e=n.data.pos,t=n.data.newPos,a=e.left-t.left,r=e.top-t.top;if(a||r){n.data.moved=!0;var i=n.elm.style;i.transform=i.WebkitTransform="translate(".concat(a,"px,").concat(r,"px)"),i.transitionDuration="0s"}}delete Kr.mode;var ni={Transition:Xr,TransitionGroup:{props:Kr,beforeMount:function(){var n=this,e=this._update;this._update=function(t,a){var r=We(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,a)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,r=this.$slots.default||[],i=this.children=[],o=Vr(this),l=0;l<r.length;l++){if((d=r[l]).tag)if(null!=d.key&&0!==String(d.key).indexOf("__vlist"))i.push(d),t[d.key]=d,(d.data||(d.data={})).transition=o;else;}if(a){var s=[],c=[];for(l=0;l<a.length;l++){var d;(d=a[l]).data.transition=o,d.data.pos=d.elm.getBoundingClientRect(),t[d.key]?s.push(d):c.push(d)}this.kept=n(e,null,s),this.removed=c}return n(e,null,i)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Wr),n.forEach(Zr),n.forEach(Yr),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,a=t.style;xr(t,e),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener(fr,t._moveCb=function n(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener(fr,n),t._moveCb=null,Er(t,e))})}})))},methods:{hasMove:function(n,e){if(!mr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){dr(t,n)})),cr(t,e),t.style.display="none",this.$el.appendChild(t);var a=Sr(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};function ei(n,e){for(var t in e)n[t]=e[t];return n}Qt.config.mustUseProp=function(n,e,t){return"value"===t&&ea(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Qt.config.isReservedTag=ga,Qt.config.isReservedAttr=na,Qt.config.getTagNamespace=function(n){return fa(n)?"svg":"math"===n?"math":void 0},Qt.config.isUnknownElement=function(n){if(!$)return!0;if(ga(n))return!1;if(n=n.toLowerCase(),null!=va[n])return va[n];var e=document.createElement(n);return n.indexOf("-")>-1?va[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:va[n]=/HTMLUnknownElement/.test(e.toString())},L(Qt.options.directives,Nr),L(Qt.options.components,ni),Qt.prototype.__patch__=$?Mr:j,Qt.prototype.$mount=function(n,e){return function(n,e,t){var a;n.$el=e,n.$options.render||(n.$options.render=hn),nt(n,"beforeMount"),a=function(){n._update(n._render(),t)},new Ve(n,a,j,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var r=n._preWatchers;if(r)for(var i=0;i<r.length;i++)r[i].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&$?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},$&&setTimeout((function(){N.devtools&&ln&&ln.emit("init",Qt)}),0);var ti=/[!'()*]/g,ai=function(n){return"%"+n.charCodeAt(0).toString(16)},ri=/%2C/g,ii=function(n){return encodeURIComponent(n).replace(ti,ai).replace(ri,",")};function oi(n){try{return decodeURIComponent(n)}catch(n){0}return n}var li=function(n){return null==n||"object"==typeof n?n:String(n)};function si(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),a=oi(t.shift()),r=t.length>0?oi(t.join("=")):null;void 0===e[a]?e[a]=r:Array.isArray(e[a])?e[a].push(r):e[a]=[e[a],r]})),e):e}function ci(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return ii(e);if(Array.isArray(t)){var a=[];return t.forEach((function(n){void 0!==n&&(null===n?a.push(ii(e)):a.push(ii(e)+"="+ii(n)))})),a.join("&")}return ii(e)+"="+ii(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var di=/\/?$/;function ui(n,e,t,a){var r=a&&a.options.stringifyQuery,i=e.query||{};try{i=pi(i)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:i,params:e.params||{},fullPath:fi(e,r),matched:n?hi(n):[]};return t&&(o.redirectedFrom=fi(t,r)),Object.freeze(o)}function pi(n){if(Array.isArray(n))return n.map(pi);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=pi(n[t]);return e}return n}var mi=ui(null,{path:"/"});function hi(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function fi(n,e){var t=n.path,a=n.query;void 0===a&&(a={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||ci)(a)+r}function gi(n,e,t){return e===mi?n===e:!!e&&(n.path&&e.path?n.path.replace(di,"")===e.path.replace(di,"")&&(t||n.hash===e.hash&&vi(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&vi(n.query,e.query)&&vi(n.params,e.params))))}function vi(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),a=Object.keys(e).sort();return t.length===a.length&&t.every((function(t,r){var i=n[t];if(a[r]!==t)return!1;var o=e[t];return null==i||null==o?i===o:"object"==typeof i&&"object"==typeof o?vi(i,o):String(i)===String(o)}))}function bi(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var a in t.instances){var r=t.instances[a],i=t.enteredCbs[a];if(r&&i){delete t.enteredCbs[a];for(var o=0;o<i.length;o++)r._isBeingDestroyed||i[o](r)}}}}var yi={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,a=e.children,r=e.parent,i=e.data;i.routerView=!0;for(var o=r.$createElement,l=t.name,s=r.$route,c=r._routerViewCache||(r._routerViewCache={}),d=0,u=!1;r&&r._routerRoot!==r;){var p=r.$vnode?r.$vnode.data:{};p.routerView&&d++,p.keepAlive&&r._directInactive&&r._inactive&&(u=!0),r=r.$parent}if(i.routerViewDepth=d,u){var m=c[l],h=m&&m.component;return h?(m.configProps&&xi(h,i,m.route,m.configProps),o(h,i,a)):o()}var f=s.matched[d],g=f&&f.components[l];if(!f||!g)return c[l]=null,o();c[l]={component:g},i.registerRouteInstance=function(n,e){var t=f.instances[l];(e&&t!==n||!e&&t===n)&&(f.instances[l]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){f.instances[l]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==f.instances[l]&&(f.instances[l]=n.componentInstance),bi(s)};var v=f.props&&f.props[l];return v&&(ei(c[l],{route:s,configProps:v}),xi(g,i,s,v)),o(g,i,a)}};function xi(n,e,t,a){var r=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,a);if(r){r=e.props=ei({},r);var i=e.attrs=e.attrs||{};for(var o in r)n.props&&o in n.props||(i[o]=r[o],delete r[o])}}function Ei(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var i=n.replace(/^\//,"").split("/"),o=0;o<i.length;o++){var l=i[o];".."===l?r.pop():"."!==l&&r.push(l)}return""!==r[0]&&r.unshift(""),r.join("/")}function Ti(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var _i=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},Si=Di,ki=zi,wi=function(n,e){return Mi(zi(n,e),e)},Ci=Mi,Ai=Ri,Ii=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function zi(n,e){for(var t,a=[],r=0,i=0,o="",l=e&&e.delimiter||"/";null!=(t=Ii.exec(n));){var s=t[0],c=t[1],d=t.index;if(o+=n.slice(i,d),i=d+s.length,c)o+=c[1];else{var u=n[i],p=t[2],m=t[3],h=t[4],f=t[5],g=t[6],v=t[7];o&&(a.push(o),o="");var b=null!=p&&null!=u&&u!==p,y="+"===g||"*"===g,x="?"===g||"*"===g,E=t[2]||l,T=h||f;a.push({name:m||r++,prefix:p||"",delimiter:E,optional:x,repeat:y,partial:b,asterisk:!!v,pattern:T?Bi(T):v?".*":"[^"+ji(E)+"]+?"})}}return i<n.length&&(o+=n.substr(i)),o&&a.push(o),a}function Li(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Mi(n,e){for(var t=new Array(n.length),a=0;a<n.length;a++)"object"==typeof n[a]&&(t[a]=new RegExp("^(?:"+n[a].pattern+")$",Oi(e)));return function(e,a){for(var r="",i=e||{},o=(a||{}).pretty?Li:encodeURIComponent,l=0;l<n.length;l++){var s=n[l];if("string"!=typeof s){var c,d=i[s.name];if(null==d){if(s.optional){s.partial&&(r+=s.prefix);continue}throw new TypeError('Expected "'+s.name+'" to be defined')}if(_i(d)){if(!s.repeat)throw new TypeError('Expected "'+s.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(s.optional)continue;throw new TypeError('Expected "'+s.name+'" to not be empty')}for(var u=0;u<d.length;u++){if(c=o(d[u]),!t[l].test(c))throw new TypeError('Expected all "'+s.name+'" to match "'+s.pattern+'", but received `'+JSON.stringify(c)+"`");r+=(0===u?s.prefix:s.delimiter)+c}}else{if(c=s.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(d),!t[l].test(c))throw new TypeError('Expected "'+s.name+'" to match "'+s.pattern+'", but received "'+c+'"');r+=s.prefix+c}}else r+=s}return r}}function ji(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Bi(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Pi(n,e){return n.keys=e,n}function Oi(n){return n&&n.sensitive?"":"i"}function Ri(n,e,t){_i(e)||(t=e||t,e=[]);for(var a=(t=t||{}).strict,r=!1!==t.end,i="",o=0;o<n.length;o++){var l=n[o];if("string"==typeof l)i+=ji(l);else{var s=ji(l.prefix),c="(?:"+l.pattern+")";e.push(l),l.repeat&&(c+="(?:"+s+c+")*"),i+=c=l.optional?l.partial?s+"("+c+")?":"(?:"+s+"("+c+"))?":s+"("+c+")"}}var d=ji(t.delimiter||"/"),u=i.slice(-d.length)===d;return a||(i=(u?i.slice(0,-d.length):i)+"(?:"+d+"(?=$))?"),i+=r?"$":a&&u?"":"(?="+d+"|$)",Pi(new RegExp("^"+i,Oi(t)),e)}function Di(n,e,t){return _i(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)e.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Pi(n,e)}(n,e):_i(n)?function(n,e,t){for(var a=[],r=0;r<n.length;r++)a.push(Di(n[r],e,t).source);return Pi(new RegExp("(?:"+a.join("|")+")",Oi(t)),e)}(n,e,t):function(n,e,t){return Ri(zi(n,t),e,t)}(n,e,t)}Si.parse=ki,Si.compile=wi,Si.tokensToFunction=Ci,Si.tokensToRegExp=Ai;var Ji=Object.create(null);function Fi(n,e,t){e=e||{};try{var a=Ji[n]||(Ji[n]=Si.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),a(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function qi(n,e,t,a){var r="string"==typeof n?{path:n}:n;if(r._normalized)return r;if(r.name){var i=(r=ei({},n)).params;return i&&"object"==typeof i&&(r.params=ei({},i)),r}if(!r.path&&r.params&&e){(r=ei({},r))._normalized=!0;var o=ei(ei({},e.params),r.params);if(e.name)r.name=e.name,r.params=o;else if(e.matched.length){var l=e.matched[e.matched.length-1].path;r.path=Fi(l,o,e.path)}else 0;return r}var s=function(n){var e="",t="",a=n.indexOf("#");a>=0&&(e=n.slice(a),n=n.slice(0,a));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(r.path||""),c=e&&e.path||"/",d=s.path?Ei(s.path,c,t||r.append):c,u=function(n,e,t){void 0===e&&(e={});var a,r=t||si;try{a=r(n||"")}catch(n){a={}}for(var i in e){var o=e[i];a[i]=Array.isArray(o)?o.map(li):li(o)}return a}(s.query,r.query,a&&a.options.parseQuery),p=r.hash||s.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:d,query:u,hash:p}}var Ni,Ui=function(){},Gi={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,a=this.$route,r=t.resolve(this.to,a,this.append),i=r.location,o=r.route,l=r.href,s={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,u=null==c?"router-link-active":c,p=null==d?"router-link-exact-active":d,m=null==this.activeClass?u:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,f=o.redirectedFrom?ui(null,qi(o.redirectedFrom),null,t):o;s[h]=gi(a,f,this.exactPath),s[m]=this.exact||this.exactPath?s[h]:function(n,e){return 0===n.path.replace(di,"/").indexOf(e.path.replace(di,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(a,f);var g=s[h]?this.ariaCurrentValue:null,v=function(n){Vi(n)&&(e.replace?t.replace(i,Ui):t.push(i,Ui))},b={click:Vi};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=v})):b[this.event]=v;var y={class:s},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:l,route:o,navigate:v,isActive:s[m],isExactActive:s[h]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)y.on=b,y.attrs={href:l,"aria-current":g};else{var E=function n(e){var t;if(e)for(var a=0;a<e.length;a++){if("a"===(t=e[a]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(E){E.isStatic=!1;var T=E.data=ei({},E.data);for(var _ in T.on=T.on||{},T.on){var S=T.on[_];_ in b&&(T.on[_]=Array.isArray(S)?S:[S])}for(var k in b)k in T.on?T.on[k].push(b[k]):T.on[k]=v;var w=E.data.attrs=ei({},E.data.attrs);w.href=l,w["aria-current"]=g}else y.on=b}return n(this.tag,y,this.$slots.default)}};function Vi(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Qi="undefined"!=typeof window;function Hi(n,e,t,a,r){var i=e||[],o=t||Object.create(null),l=a||Object.create(null);n.forEach((function(n){!function n(e,t,a,r,i,o){var l=r.path,s=r.name;0;var c=r.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return Ti(e.path+"/"+n)}(l,i,c.strict);"boolean"==typeof r.caseSensitive&&(c.sensitive=r.caseSensitive);var u={path:d,regex:$i(d,c),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:s,parent:i,matchAs:o,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var i=o?Ti(o+"/"+r.path):void 0;n(e,t,a,r,u,i)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==r.alias)for(var p=Array.isArray(r.alias)?r.alias:[r.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:r.children};n(e,t,a,h,i,u.path||"/")}s&&(a[s]||(a[s]=u))}(i,o,l,n,r)}));for(var s=0,c=i.length;s<c;s++)"*"===i[s]&&(i.push(i.splice(s,1)[0]),c--,s--);return{pathList:i,pathMap:o,nameMap:l}}function $i(n,e){return Si(n,[],e)}function Xi(n,e){var t=Hi(n),a=t.pathList,r=t.pathMap,i=t.nameMap;function o(n,t,o){var l=qi(n,t,!1,e),c=l.name;if(c){var d=i[c];if(!d)return s(null,l);var u=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof l.params&&(l.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in l.params)&&u.indexOf(p)>-1&&(l.params[p]=t.params[p]);return l.path=Fi(d.path,l.params),s(d,l,o)}if(l.path){l.params={};for(var m=0;m<a.length;m++){var h=a[m],f=r[h];if(Ki(f.regex,l.path,l.params))return s(f,l,o)}}return s(null,l)}function l(n,t){var a=n.redirect,r="function"==typeof a?a(ui(n,t,null,e)):a;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return s(null,t);var l=r,c=l.name,d=l.path,u=t.query,p=t.hash,m=t.params;if(u=l.hasOwnProperty("query")?l.query:u,p=l.hasOwnProperty("hash")?l.hash:p,m=l.hasOwnProperty("params")?l.params:m,c){i[c];return o({_normalized:!0,name:c,query:u,hash:p,params:m},void 0,t)}if(d){var h=function(n,e){return Ei(n,e.parent?e.parent.path:"/",!0)}(d,n);return o({_normalized:!0,path:Fi(h,m),query:u,hash:p},void 0,t)}return s(null,t)}function s(n,t,a){return n&&n.redirect?l(n,a||t):n&&n.matchAs?function(n,e,t){var a=o({_normalized:!0,path:Fi(t,e.params)});if(a){var r=a.matched,i=r[r.length-1];return e.params=a.params,s(i,e)}return s(null,e)}(0,t,n.matchAs):ui(n,t,a,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?i[n]:void 0;Hi([e||n],a,r,i,t),t&&t.alias.length&&Hi(t.alias.map((function(n){return{path:n,children:[e]}})),a,r,i,t)},getRoutes:function(){return a.map((function(n){return r[n]}))},addRoutes:function(n){Hi(n,a,r,i)}}}function Ki(n,e,t){var a=e.match(n);if(!a)return!1;if(!t)return!0;for(var r=1,i=a.length;r<i;++r){var o=n.keys[r-1];o&&(t[o.name||"pathMatch"]="string"==typeof a[r]?oi(a[r]):a[r])}return!0}var Wi=Qi&&window.performance&&window.performance.now?window.performance:Date;function Zi(){return Wi.now().toFixed(3)}var Yi=Zi();function no(){return Yi}function eo(n){return Yi=n}var to=Object.create(null);function ao(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ei({},window.history.state);return t.key=no(),window.history.replaceState(t,"",e),window.addEventListener("popstate",oo),function(){window.removeEventListener("popstate",oo)}}function ro(n,e,t,a){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var i=function(){var n=no();if(n)return to[n]}(),o=r.call(n,e,t,a?i:null);o&&("function"==typeof o.then?o.then((function(n){po(n,i)})).catch((function(n){0})):po(o,i))}))}}function io(){var n=no();n&&(to[n]={x:window.pageXOffset,y:window.pageYOffset})}function oo(n){io(),n.state&&n.state.key&&eo(n.state.key)}function lo(n){return co(n.x)||co(n.y)}function so(n){return{x:co(n.x)?n.x:window.pageXOffset,y:co(n.y)?n.y:window.pageYOffset}}function co(n){return"number"==typeof n}var uo=/^#\d/;function po(n,e){var t,a="object"==typeof n;if(a&&"string"==typeof n.selector){var r=uo.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var i=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),a=n.getBoundingClientRect();return{x:a.left-t.left-e.x,y:a.top-t.top-e.y}}(r,i={x:co((t=i).x)?t.x:0,y:co(t.y)?t.y:0})}else lo(n)&&(e=so(n))}else a&&lo(n)&&(e=so(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var mo,ho=Qi&&((-1===(mo=window.navigator.userAgent).indexOf("Android 2.")&&-1===mo.indexOf("Android 4.0")||-1===mo.indexOf("Mobile Safari")||-1!==mo.indexOf("Chrome")||-1!==mo.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function fo(n,e){io();var t=window.history;try{if(e){var a=ei({},t.state);a.key=no(),t.replaceState(a,"",n)}else t.pushState({key:eo(Zi())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function go(n){fo(n,!0)}var vo={redirected:2,aborted:4,cancelled:8,duplicated:16};function bo(n,e){return xo(n,e,vo.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return Eo.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function yo(n,e){return xo(n,e,vo.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function xo(n,e,t,a){var r=new Error(a);return r._isRouter=!0,r.from=n,r.to=e,r.type=t,r}var Eo=["params","query","hash"];function To(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function _o(n,e){return To(n)&&n._isRouter&&(null==e||n.type===e)}function So(n,e,t){var a=function(r){r>=n.length?t():n[r]?e(n[r],(function(){a(r+1)})):a(r+1)};a(0)}function ko(n){return function(e,t,a){var r=!1,i=0,o=null;wo(n,(function(n,e,t,l){if("function"==typeof n&&void 0===n.cid){r=!0,i++;var s,c=Io((function(e){var r;((r=e).__esModule||Ao&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Ni.extend(e),t.components[l]=e,--i<=0&&a()})),d=Io((function(n){var e="Failed to resolve async component "+l+": "+n;o||(o=To(n)?n:new Error(e),a(o))}));try{s=n(c,d)}catch(n){d(n)}if(s)if("function"==typeof s.then)s.then(c,d);else{var u=s.component;u&&"function"==typeof u.then&&u.then(c,d)}}})),r||a()}}function wo(n,e){return Co(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Co(n){return Array.prototype.concat.apply([],n)}var Ao="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Io(n){var e=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!e)return e=!0,n.apply(this,t)}}var zo=function(n,e){this.router=n,this.base=function(n){if(!n)if(Qi){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=mi,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Lo(n,e,t,a){var r=wo(n,(function(n,a,r,i){var o=function(n,e){"function"!=typeof n&&(n=Ni.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,a,r,i)})):t(o,a,r,i)}));return Co(a?r.reverse():r)}function Mo(n,e){if(e)return function(){return n.apply(e,arguments)}}zo.prototype.listen=function(n){this.cb=n},zo.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},zo.prototype.onError=function(n){this.errorCbs.push(n)},zo.prototype.transitionTo=function(n,e,t){var a,r=this;try{a=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var i=this.current;this.confirmTransition(a,(function(){r.updateRoute(a),e&&e(a),r.ensureURL(),r.router.afterHooks.forEach((function(n){n&&n(a,i)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(n){n(a)})))}),(function(n){t&&t(n),n&&!r.ready&&(_o(n,vo.redirected)&&i===mi||(r.ready=!0,r.readyErrorCbs.forEach((function(e){e(n)}))))}))},zo.prototype.confirmTransition=function(n,e,t){var a=this,r=this.current;this.pending=n;var i,o,l=function(n){!_o(n)&&To(n)&&(a.errorCbs.length?a.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},s=n.matched.length-1,c=r.matched.length-1;if(gi(n,r)&&s===c&&n.matched[s]===r.matched[c])return this.ensureURL(),n.hash&&ro(this.router,r,n,!1),l(((o=xo(i=r,n,vo.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",o));var d=function(n,e){var t,a=Math.max(n.length,e.length);for(t=0;t<a&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=d.updated,p=d.deactivated,m=d.activated,h=[].concat(function(n){return Lo(n,"beforeRouteLeave",Mo,!0)}(p),this.router.beforeHooks,function(n){return Lo(n,"beforeRouteUpdate",Mo)}(u),m.map((function(n){return n.beforeEnter})),ko(m)),f=function(e,t){if(a.pending!==n)return l(yo(r,n));try{e(n,r,(function(e){!1===e?(a.ensureURL(!0),l(function(n,e){return xo(n,e,vo.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(r,n))):To(e)?(a.ensureURL(!0),l(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(l(bo(r,n)),"object"==typeof e&&e.replace?a.replace(e):a.push(e)):t(e)}))}catch(n){l(n)}};So(h,f,(function(){So(function(n){return Lo(n,"beforeRouteEnter",(function(n,e,t,a){return function(n,e,t){return function(a,r,i){return n(a,r,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),i(n)}))}}(n,t,a)}))}(m).concat(a.router.resolveHooks),f,(function(){if(a.pending!==n)return l(yo(r,n));a.pending=null,e(n),a.router.app&&a.router.app.$nextTick((function(){bi(n)}))}))}))},zo.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},zo.prototype.setupListeners=function(){},zo.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=mi,this.pending=null};var jo=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Bo(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,a=ho&&t;a&&this.listeners.push(ao());var r=function(){var t=n.current,r=Bo(n.base);n.current===mi&&r===n._startLocation||n.transitionTo(r,(function(n){a&&ro(e,n,t,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){fo(Ti(a.base+n.fullPath)),ro(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){go(Ti(a.base+n.fullPath)),ro(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Bo(this.base)!==this.current.fullPath){var e=Ti(this.base+this.current.fullPath);n?fo(e):go(e)}},e.prototype.getCurrentLocation=function(){return Bo(this.base)},e}(zo);function Bo(n){var e=window.location.pathname,t=e.toLowerCase(),a=n.toLowerCase();return!n||t!==a&&0!==t.indexOf(Ti(a+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Po=function(n){function e(e,t,a){n.call(this,e,t),a&&function(n){var e=Bo(n);if(!/^\/#/.test(e))return window.location.replace(Ti(n+"/#"+e)),!0}(this.base)||Oo()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=ho&&e;t&&this.listeners.push(ao());var a=function(){var e=n.current;Oo()&&n.transitionTo(Ro(),(function(a){t&&ro(n.router,a,e,!0),ho||Fo(a.fullPath)}))},r=ho?"popstate":"hashchange";window.addEventListener(r,a),this.listeners.push((function(){window.removeEventListener(r,a)}))}},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){Jo(n.fullPath),ro(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){Fo(n.fullPath),ro(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Ro()!==e&&(n?Jo(e):Fo(e))},e.prototype.getCurrentLocation=function(){return Ro()},e}(zo);function Oo(){var n=Ro();return"/"===n.charAt(0)||(Fo("/"+n),!1)}function Ro(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Do(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Jo(n){ho?fo(Do(n)):window.location.hash=n}function Fo(n){ho?go(Do(n)):window.location.replace(Do(n))}var qo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index+1).concat(n),a.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var n=e.current;e.index=t,e.updateRoute(a),e.router.afterHooks.forEach((function(e){e&&e(a,n)}))}),(function(n){_o(n,vo.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(zo),No=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Xi(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!ho&&!1!==n.fallback,this.fallback&&(e="hash"),Qi||(e="abstract"),this.mode=e,e){case"history":this.history=new jo(this,n.base);break;case"hash":this.history=new Po(this,n.base,this.fallback);break;case"abstract":this.history=new qo(this,n.base);break;default:0}},Uo={currentRoute:{configurable:!0}};No.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Uo.currentRoute.get=function(){return this.history&&this.history.current},No.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof jo||t instanceof Po){var a=function(n){t.setupListeners(),function(n){var a=t.current,r=e.options.scrollBehavior;ho&&r&&"fullPath"in n&&ro(e,n,a,!1)}(n)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},No.prototype.beforeEach=function(n){return Vo(this.beforeHooks,n)},No.prototype.beforeResolve=function(n){return Vo(this.resolveHooks,n)},No.prototype.afterEach=function(n){return Vo(this.afterHooks,n)},No.prototype.onReady=function(n,e){this.history.onReady(n,e)},No.prototype.onError=function(n){this.history.onError(n)},No.prototype.push=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.push(n,e,t)}));this.history.push(n,e,t)},No.prototype.replace=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.replace(n,e,t)}));this.history.replace(n,e,t)},No.prototype.go=function(n){this.history.go(n)},No.prototype.back=function(){this.go(-1)},No.prototype.forward=function(){this.go(1)},No.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},No.prototype.resolve=function(n,e,t){var a=qi(n,e=e||this.history.current,t,this),r=this.match(a,e),i=r.redirectedFrom||r.fullPath;return{location:a,route:r,href:function(n,e,t){var a="hash"===t?"#"+e:e;return n?Ti(n+"/"+a):a}(this.history.base,i,this.mode),normalizedTo:a,resolved:r}},No.prototype.getRoutes=function(){return this.matcher.getRoutes()},No.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==mi&&this.history.transitionTo(this.history.getCurrentLocation())},No.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==mi&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(No.prototype,Uo);var Go=No;function Vo(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}No.install=function n(e){if(!n.installed||Ni!==e){n.installed=!0,Ni=e;var t=function(n){return void 0!==n},a=function(n,e){var a=n.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",yi),e.component("RouterLink",Gi);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},No.version="3.6.5",No.isNavigationFailure=_o,No.NavigationFailureType=vo,No.START_LOCATION=mi,Qi&&window.Vue&&window.Vue.use(No);t(107);t(16),t(132);var Qo={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,334)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,333))},Ho={"v-0752b88c":()=>t.e(5).then(t.bind(null,335)),"v-37120786":()=>t.e(6).then(t.bind(null,336)),"v-6b67a3c6":()=>t.e(8).then(t.bind(null,337)),"v-414ca65b":()=>t.e(11).then(t.bind(null,338)),"v-243cc8aa":()=>t.e(7).then(t.bind(null,339)),"v-59615ba1":()=>t.e(10).then(t.bind(null,340)),"v-90b1f352":()=>t.e(12).then(t.bind(null,341)),"v-73deb80f":()=>t.e(13).then(t.bind(null,342)),"v-618bf0bb":()=>t.e(9).then(t.bind(null,343)),"v-30655360":()=>t.e(15).then(t.bind(null,344)),"v-f91ab4be":()=>t.e(14).then(t.bind(null,345)),"v-f52dc942":()=>t.e(16).then(t.bind(null,346)),"v-558474a0":()=>t.e(17).then(t.bind(null,347)),"v-4d3b354d":()=>t.e(18).then(t.bind(null,348)),"v-f225e21e":()=>t.e(20).then(t.bind(null,349)),"v-09788617":()=>t.e(19).then(t.bind(null,350)),"v-8a778884":()=>t.e(21).then(t.bind(null,351)),"v-6cc42844":()=>t.e(22).then(t.bind(null,352)),"v-0322d41e":()=>t.e(23).then(t.bind(null,353)),"v-65476117":()=>t.e(24).then(t.bind(null,354)),"v-5ea26f44":()=>t.e(26).then(t.bind(null,355)),"v-7dc35ca5":()=>t.e(25).then(t.bind(null,356)),"v-770d0f42":()=>t.e(27).then(t.bind(null,357)),"v-854b12bc":()=>t.e(28).then(t.bind(null,358)),"v-76b6bfea":()=>t.e(30).then(t.bind(null,359)),"v-21848ec2":()=>t.e(31).then(t.bind(null,360)),"v-4cef543f":()=>t.e(34).then(t.bind(null,361)),"v-f445feb8":()=>t.e(29).then(t.bind(null,362)),"v-76d58b51":()=>t.e(33).then(t.bind(null,363)),"v-5c1cca71":()=>t.e(32).then(t.bind(null,364)),"v-17d22485":()=>t.e(35).then(t.bind(null,365)),"v-1b7e4ff2":()=>t.e(36).then(t.bind(null,366)),"v-4bab47ca":()=>t.e(37).then(t.bind(null,367)),"v-d97f40f6":()=>t.e(38).then(t.bind(null,368)),"v-3bafe364":()=>t.e(39).then(t.bind(null,369)),"v-af103070":()=>t.e(40).then(t.bind(null,370)),"v-0b8ed9f8":()=>t.e(42).then(t.bind(null,371)),"v-31eab8d8":()=>t.e(43).then(t.bind(null,372)),"v-d2430cca":()=>t.e(41).then(t.bind(null,373)),"v-2bf7dba4":()=>t.e(44).then(t.bind(null,374)),"v-2da3c232":()=>t.e(46).then(t.bind(null,375)),"v-27a25f92":()=>t.e(45).then(t.bind(null,376)),"v-d015cfc2":()=>t.e(48).then(t.bind(null,377)),"v-0173ec44":()=>t.e(47).then(t.bind(null,378)),"v-64b968d7":()=>t.e(49).then(t.bind(null,379)),"v-7cc9a2b6":()=>t.e(50).then(t.bind(null,380)),"v-39d6b1f3":()=>t.e(52).then(t.bind(null,381)),"v-193c5be4":()=>t.e(51).then(t.bind(null,382)),"v-8ad2cece":()=>t.e(54).then(t.bind(null,383)),"v-33cdacc0":()=>t.e(53).then(t.bind(null,384)),"v-6d7f8b89":()=>t.e(55).then(t.bind(null,385)),"v-6ced3d6b":()=>t.e(57).then(t.bind(null,386)),"v-01767fb0":()=>t.e(56).then(t.bind(null,387)),"v-74c22a5e":()=>t.e(58).then(t.bind(null,388)),"v-d4e3c634":()=>t.e(59).then(t.bind(null,389)),"v-4e4a101c":()=>t.e(60).then(t.bind(null,390)),"v-1b1c4248":()=>t.e(61).then(t.bind(null,391)),"v-23006aec":()=>t.e(63).then(t.bind(null,392)),"v-7550b988":()=>t.e(64).then(t.bind(null,393)),"v-4d5eaa9c":()=>t.e(62).then(t.bind(null,394)),"v-be1bac58":()=>t.e(65).then(t.bind(null,395)),"v-7fbbb95c":()=>t.e(66).then(t.bind(null,396)),"v-9499db24":()=>t.e(67).then(t.bind(null,397)),"v-4d6aaf62":()=>t.e(68).then(t.bind(null,398)),"v-9e602488":()=>t.e(69).then(t.bind(null,399)),"v-48671418":()=>t.e(70).then(t.bind(null,400)),"v-c049eb16":()=>t.e(71).then(t.bind(null,401)),"v-1f3e78d6":()=>t.e(72).then(t.bind(null,402)),"v-43b3065b":()=>t.e(74).then(t.bind(null,403)),"v-1d50b52b":()=>t.e(76).then(t.bind(null,404)),"v-0c243284":()=>t.e(73).then(t.bind(null,405)),"v-20089476":()=>t.e(77).then(t.bind(null,406)),"v-1ea7fe80":()=>t.e(75).then(t.bind(null,407)),"v-5ffddbde":()=>t.e(78).then(t.bind(null,408))};function $o(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Xo=/-(\w)/g,Ko=$o(n=>n.replace(Xo,(n,e)=>e?e.toUpperCase():"")),Wo=/\B([A-Z])/g,Zo=$o(n=>n.replace(Wo,"-$1").toLowerCase()),Yo=$o(n=>n.charAt(0).toUpperCase()+n.slice(1));function nl(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Yo(Ko(e))):n(Yo(e))||n(Zo(e))}const el=Object.assign({},Qo,Ho),tl=n=>el[n],al=n=>Ho[n],rl=n=>Qo[n],il=n=>Qt.component(n);function ol(n){return nl(al,n)}function ll(n){return nl(rl,n)}function sl(n){return nl(tl,n)}function cl(n){return nl(il,n)}function dl(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!cl(n)&&sl(n)){const e=await sl(n)();Qt.component(n,e.default)}}))}function ul(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var pl=t(93),ml=t.n(pl),hl=t(94),fl=t.n(hl),gl={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${fl()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=bl(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=yl(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ml()([{name:"description",content:this.$description}],n,this.siteMeta,xl)},updateCanonicalLink(){vl(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",bl(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){yl(null,this.currentMetaTags),vl()}};function vl(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function bl(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function yl(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function xl(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var El=t(50),Tl={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(El)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),r=window.innerHeight+t;for(let n=0;n<e.length;n++){const i=e[n],o=e[n+1],l=0===n&&0===t||t>=i.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),s=decodeURIComponent(this.$route.hash);if(l&&s!==decodeURIComponent(i.hash)){const t=i;if(r===a)for(let t=n+1;t<e.length;t++)if(s===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},_l=t(24),Sl=t.n(_l),kl={mounted(){Sl.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Qt.component(n.name)||Sl.a.start(),t()}),this.$router.afterEach(()=>{Sl.a.done(),this.isSidebarOpen=!1})}};t(240),t(241);class wl{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Cl={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new wl).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var a=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===t&&a.firstChild?a.insertBefore(r,a.firstChild):a.appendChild(r),r.styleSheet?r.styleSheet.cssText=n:r.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Al={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Il={},zl=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Ll=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Al[n]},Ml=function n(e,t,a){var r=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))r[n]=t[n];else{var e=n.replace("data","");r.dataset[e]=t[n]}})),a&&a.forEach((function(e){var t=e.tag,a=e.attrs,i=e.children;r.appendChild(n(t,a,i))})),r},jl=function(n,e,t){var a,r=(a=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(a));return 1!==r.length||t?r:r[0]},Bl=function(n,e){var t,a,r=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),l={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};l.htmlTpl=zl(l.html),l.jsTpl=(t=l.js,a=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(a,"\n})")),l.script=function(n,e){var t=n.split(/export\s+default/),a="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),r=window.Babel?window.Babel.transform(a,{presets:["es2015"]}).code:a,i=[eval][0](r);return i.template=e,i}(l.js,l.html);var s=Ll("vue");return l.jsLib.unshift(s),l},Pl=function(n,e){var t,a=n.match(/<style>([\s\S]+)<\/style>/),r=n.match(/<html>([\s\S]+)<\/html>/),i=n.match(/<script>([\s\S]+)<\/script>/),o={css:a&&a[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(t=o.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),o},Ol=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Rl(){var n=jl(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=jl(n,"vuepress-plugin-demo-block__code"),t=jl(n,"vuepress-plugin-demo-block__display"),a=jl(n,"vuepress-plugin-demo-block__footer"),r=jl(t,"vuepress-plugin-demo-block__app"),i=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),l=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var s=e.querySelector("div").clientHeight,c="react"===l?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,a="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),r=new Function("return ".concat(a))(),i={js:r,css:r.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Ol(n),htmlTpl:zl("")},o=Ll("react"),l=Ll("reactDOM");return i.jsLib.unshift(o,l),i}(i,o):"vanilla"===l?Pl(i,o):Bl(i,o),d=Ml("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(a.appendChild(d),d.addEventListener("click",Dl.bind(null,d,s,e,a)),Ll("jsfiddle")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,i=n.cssLib,o=r.concat(i).concat(Ll("cssLib")).concat(Ll("jsLib")).join(",");return Ml("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:a}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),Ll("codepen")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,i=n.cssLib,o=JSON.stringify({css:e,html:t,js:a,js_external:r.concat(Ll("jsLib")).join(";"),css_external:i.concat(Ll("cssLib")).join(";"),layout:Ll("codepenLayout"),js_pre_processor:Ll("codepenJsProcessor"),editors:Ll("codepenEditors")});return Ml("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==o.horizontal?o.horizontal:Ll("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var u=e.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(u)}if(c.css&&function(n){if(!Il[n]){var e=Ml("style",{innerHTML:n});document.body.appendChild(e),Il[n]=!0}}(c.css),"react"===l)ReactDOM.render(React.createElement(c.js),r);else if("vue"===l){var p=(new(Vue.extend(c.script))).$mount();r.appendChild(p.$el)}else"vanilla"===l&&(r.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Rl()}),300)}function Dl(n,e,t,a){var r="1"!==n.dataset.isExpand;t.style.height=r?"".concat(e,"px"):0,r?a.classList.add("vuepress-plugin-demo-block__show-link"):a.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=r?"1":"0"}var Jl={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Rl()},updated:function(){Rl()}},Fl="auto",ql="zoom-in",Nl="zoom-out",Ul="grab",Gl="move";function Vl(n,e,t){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r={passive:!1};a?n.addEventListener(e,t,r):n.removeEventListener(e,t,r)}function Ql(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Hl(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function $l(n,e,t){!function(n){var e=Xl,t=Kl;if(n.transition){var a=n.transition;delete n.transition,n[e]=a}if(n.transform){var r=n.transform;delete n.transform,n[t]=r}}(e);var a=n.style,r={};for(var i in e)t&&(r[i]=a[i]||""),a[i]=e[i];return r}var Xl="transition",Kl="transform",Wl="transform",Zl="transitionend";var Yl=function(){},ns={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Yl,onClose:Yl,onGrab:Yl,onMove:Yl,onRelease:Yl,onBeforeOpen:Yl,onBeforeClose:Yl,onBeforeGrab:Yl,onBeforeRelease:Yl,onImageLoading:Yl,onImageLoaded:Yl},es={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),as(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var a=this.lastScrollPosition.x-e,r=this.lastScrollPosition.y-t,i=this.options.scrollThreshold;(Math.abs(r)>=i||Math.abs(a)>=i)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(ts(n)&&!as(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){ts(n)&&!as(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,a=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,a)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,a=e.clientY;this.move(t,a)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function ts(n){return 0===n.button}function as(n){return n.metaKey||n.ctrlKey}var rs={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,$l(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Vl(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){$l(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},is="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},os=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),ls=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},ss={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Hl(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,a=n.transitionDuration,r=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Ul:Nl,transition:Wl+"\n        "+a+"s\n        "+r,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=$l(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,$l(this.el,{transform:"none"})},grab:function(n,e,t){var a=cs(),r=a.x-n,i=a.y-e;$l(this.el,{cursor:Gl,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var a=cs(),r=a.x-n,i=a.y-e;$l(this.el,{transition:Wl,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){$l(this.el,this.styleClose)},restoreOpenStyle:function(){$l(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=cs(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,a=this.instance.options,r=a.customSize,i=a.scaleBase;if(!r&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(r&&"object"===(void 0===r?"undefined":is(r)))return{x:r.width/this.rect.width,y:r.height/this.rect.height};var o=this.rect.width/2,l=this.rect.height/2,s=cs(),c={x:s.x-o,y:s.y-l},d=c.x/o,u=c.y/l,p=i+Math.min(d,u);if(r&&"string"==typeof r){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,f=parseFloat(r)*m/(100*this.rect.width),g=parseFloat(r)*h/(100*this.rect.height);if(p>f||p>g)return{x:f,y:g}}return{x:p,y:p}}};function cs(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function ds(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(a){Vl(n,a,e[a],t)}))}var us=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ss),this.overlay=Object.create(rs),this.handler=Object.create(es),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=ls({},ns,e),this.overlay.init(this),this.handler.init(this)}return os(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=ql,Vl(n,"click",this.handler.click),this.options.preloadImage&&Ql(Hl(n)));return this}},{key:"config",value:function(n){return n?(ls(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var a="string"==typeof n?document.querySelector(n):n;if("IMG"===a.tagName){if(this.options.onBeforeOpen(a),this.target.init(a,this),!this.options.preloadImage){var r=this.target.srcOriginal;null!=r&&(this.options.onImageLoading(a),Ql(r,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Vl(document,"scroll",this.handler.scroll),Vl(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Vl(window,"resize",this.handler.resizeWindow);var i=function n(){Vl(a,Zl,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&ds(document,e.handler,!0),t(a)};return Vl(a,Zl,i),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Fl,this.overlay.fadeOut(),this.target.zoomOut(),Vl(document,"scroll",this.handler.scroll,!1),Vl(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Vl(window,"resize",this.handler.resizeWindow,!1);var a=function a(){Vl(t,Zl,a,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&ds(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Vl(t,Zl,a),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var r=this.target.el;this.options.onBeforeGrab(r),this.released=!1,this.target.grab(n,e,t);var i=function n(){Vl(r,Zl,n,!1),a(r)};return Vl(r,Zl,i),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Gl,this.target.move(n,e,t);var r=this.target.el,i=function n(){Vl(r,Zl,n,!1),a(r)};return Vl(r,Zl,i),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Fl,this.target.restoreOpenStyle();var a=function a(){Vl(t,Zl,a,!1),n.lock=!1,n.released=!0,e(t)};return Vl(t,Zl,a),this}}}]),n}();const ps=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),ms=Number("500");class hs{constructor(){this.instance=new us(ps)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=ms){setTimeout(()=>this.update(n),e)}}var fs=[gl,Tl,kl,Cl,Jl,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new hs,this.$vuepress.zooming.updateDelay()}}],gs={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ul("layout",n),Qt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},vs=t(7),bs=Object(vs.a)(gs,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(bs,"mixins",fs);const ys=[{name:"v-0752b88c",path:"/pages/0e35d1/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-0752b88c").then(t)}},{path:"/pages/0e35d1/index.html",redirect:"/pages/0e35d1/"},{path:"/01.Java 知识体系/01.计算机基础/01.数据结构/01.线性数据结构——数组、链表、栈、队列.html",redirect:"/pages/0e35d1/"},{name:"v-37120786",path:"/pages/beb561/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-37120786").then(t)}},{path:"/pages/beb561/index.html",redirect:"/pages/beb561/"},{path:"/01.Java 知识体系/01.计算机基础/01.数据结构/02.哈希表.html",redirect:"/pages/beb561/"},{name:"v-6b67a3c6",path:"/pages/d2ac96/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-6b67a3c6").then(t)}},{path:"/pages/d2ac96/index.html",redirect:"/pages/d2ac96/"},{path:"/01.Java 知识体系/01.计算机基础/01.数据结构/04.树.html",redirect:"/pages/d2ac96/"},{name:"v-414ca65b",path:"/pages/74b53c/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-414ca65b").then(t)}},{path:"/pages/74b53c/index.html",redirect:"/pages/74b53c/"},{path:"/01.Java 知识体系/01.计算机基础/02.操作系统/01.Linux/02.Linux 常用命令.html",redirect:"/pages/74b53c/"},{name:"v-243cc8aa",path:"/pages/8751ef/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-243cc8aa").then(t)}},{path:"/pages/8751ef/index.html",redirect:"/pages/8751ef/"},{path:"/01.Java 知识体系/01.计算机基础/01.数据结构/03.图.html",redirect:"/pages/8751ef/"},{name:"v-59615ba1",path:"/pages/ee514b/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-59615ba1").then(t)}},{path:"/pages/ee514b/index.html",redirect:"/pages/ee514b/"},{path:"/01.Java 知识体系/01.计算机基础/02.操作系统/01.Linux/01.Linux.html",redirect:"/pages/ee514b/"},{name:"v-90b1f352",path:"/pages/67462f/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-90b1f352").then(t)}},{path:"/pages/67462f/index.html",redirect:"/pages/67462f/"},{path:"/01.Java 知识体系/02.数据库/01.数据库基础与SQL.html",redirect:"/pages/67462f/"},{name:"v-73deb80f",path:"/pages/c9b13a/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-73deb80f").then(t)}},{path:"/pages/c9b13a/index.html",redirect:"/pages/c9b13a/"},{path:"/01.Java 知识体系/02.数据库/02.MySQL/01.MySQL简介.html",redirect:"/pages/c9b13a/"},{name:"v-618bf0bb",path:"/pages/b5322d/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-618bf0bb").then(t)}},{path:"/pages/b5322d/index.html",redirect:"/pages/b5322d/"},{path:"/01.Java 知识体系/01.计算机基础/01.数据结构/05.红黑树.html",redirect:"/pages/b5322d/"},{name:"v-30655360",path:"/pages/17d468/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-30655360").then(t)}},{path:"/pages/17d468/index.html",redirect:"/pages/17d468/"},{path:"/01.Java 知识体系/02.数据库/02.MySQL/03.MySQL索引.html",redirect:"/pages/17d468/"},{name:"v-f91ab4be",path:"/pages/198df0/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-f91ab4be").then(t)}},{path:"/pages/198df0/index.html",redirect:"/pages/198df0/"},{path:"/01.Java 知识体系/02.数据库/02.MySQL/02.MySQL体系结构.html",redirect:"/pages/198df0/"},{name:"v-f52dc942",path:"/pages/ec5067/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-f52dc942").then(t)}},{path:"/pages/ec5067/index.html",redirect:"/pages/ec5067/"},{path:"/01.Java 知识体系/02.数据库/02.MySQL/04.MySQL调优.html",redirect:"/pages/ec5067/"},{name:"v-558474a0",path:"/pages/f7fcac/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-558474a0").then(t)}},{path:"/pages/f7fcac/index.html",redirect:"/pages/f7fcac/"},{path:"/01.Java 知识体系/02.数据库/02.MySQL/05.MySQL命令大全.html",redirect:"/pages/f7fcac/"},{name:"v-4d3b354d",path:"/pages/f7214d/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-4d3b354d").then(t)}},{path:"/pages/f7214d/index.html",redirect:"/pages/f7214d/"},{path:"/01.Java 知识体系/03.Java/01.Java 基础/01.BigDecimal 详解.html",redirect:"/pages/f7214d/"},{name:"v-f225e21e",path:"/pages/33fb2e/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-f225e21e").then(t)}},{path:"/pages/33fb2e/index.html",redirect:"/pages/33fb2e/"},{path:"/01.Java 知识体系/03.Java/02.Java 容器/01.Java 集合常用使用技巧.html",redirect:"/pages/33fb2e/"},{name:"v-09788617",path:"/pages/8f19aa/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-09788617").then(t)}},{path:"/pages/8f19aa/index.html",redirect:"/pages/8f19aa/"},{path:"/01.Java 知识体系/03.Java/01.Java 基础/02.Java 异常体系.html",redirect:"/pages/8f19aa/"},{name:"v-8a778884",path:"/pages/528ca4/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-8a778884").then(t)}},{path:"/pages/528ca4/index.html",redirect:"/pages/528ca4/"},{path:"/01.Java 知识体系/03.Java/02.Java 容器/02.ArrayList 源码分析及扩容机制.html",redirect:"/pages/528ca4/"},{name:"v-6cc42844",path:"/pages/a794bb/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-6cc42844").then(t)}},{path:"/pages/a794bb/index.html",redirect:"/pages/a794bb/"},{path:"/01.Java 知识体系/03.Java/02.Java 容器/03.HashMap 源码及底层数据结构分析.html",redirect:"/pages/a794bb/"},{name:"v-0322d41e",path:"/pages/571a8d/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-0322d41e").then(t)}},{path:"/pages/571a8d/index.html",redirect:"/pages/571a8d/"},{path:"/01.Java 知识体系/03.Java/03.Java 并发/01.并发编程基础.html",redirect:"/pages/571a8d/"},{name:"v-65476117",path:"/pages/adbda5/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-65476117").then(t)}},{path:"/pages/adbda5/index.html",redirect:"/pages/adbda5/"},{path:"/01.Java 知识体系/03.Java/03.Java 并发/02.Java 线程池详解.html",redirect:"/pages/adbda5/"},{name:"v-5ea26f44",path:"/pages/737a52/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-5ea26f44").then(t)}},{path:"/pages/737a52/index.html",redirect:"/pages/737a52/"},{path:"/01.Java 知识体系/03.Java/03.Java 并发/04.Java 锁.html",redirect:"/pages/737a52/"},{name:"v-7dc35ca5",path:"/pages/77c217/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-7dc35ca5").then(t)}},{path:"/pages/77c217/index.html",redirect:"/pages/77c217/"},{path:"/01.Java 知识体系/03.Java/03.Java 并发/03.CompletableFuture 详解.html",redirect:"/pages/77c217/"},{name:"v-770d0f42",path:"/pages/b6b76e/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-770d0f42").then(t)}},{path:"/pages/b6b76e/index.html",redirect:"/pages/b6b76e/"},{path:"/01.Java 知识体系/03.Java/04.Java 新特性/01.Java8 新特性/01.Java 8 新特性.html",redirect:"/pages/b6b76e/"},{name:"v-854b12bc",path:"/pages/f2f56b/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-854b12bc").then(t)}},{path:"/pages/f2f56b/index.html",redirect:"/pages/f2f56b/"},{path:"/01.Java 知识体系/03.Java/04.Java 新特性/01.Java8 新特性/02.Java 8 并行流.html",redirect:"/pages/f2f56b/"},{name:"v-76b6bfea",path:"/pages/5bf174/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-76b6bfea").then(t)}},{path:"/pages/5bf174/index.html",redirect:"/pages/5bf174/"},{path:"/01.Java 知识体系/03.Java/05.JVM/02.JVM 垃圾收集.html",redirect:"/pages/5bf174/"},{name:"v-21848ec2",path:"/pages/c5dfa7/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-21848ec2").then(t)}},{path:"/pages/c5dfa7/index.html",redirect:"/pages/c5dfa7/"},{path:"/01.Java 知识体系/03.Java/05.JVM/03.JVM 常用参数.html",redirect:"/pages/c5dfa7/"},{name:"v-4cef543f",path:"/pages/7bbf36/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-4cef543f").then(t)}},{path:"/pages/7bbf36/index.html",redirect:"/pages/7bbf36/"},{path:"/01.Java 知识体系/03.Java/05.JVM/06.JVM 问题排查及调优.html",redirect:"/pages/7bbf36/"},{name:"v-f445feb8",path:"/pages/ecd0f2/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-f445feb8").then(t)}},{path:"/pages/ecd0f2/index.html",redirect:"/pages/ecd0f2/"},{path:"/01.Java 知识体系/03.Java/05.JVM/01.Java 内存区域.html",redirect:"/pages/ecd0f2/"},{name:"v-76d58b51",path:"/pages/b8b917/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-76d58b51").then(t)}},{path:"/pages/b8b917/index.html",redirect:"/pages/b8b917/"},{path:"/01.Java 知识体系/03.Java/05.JVM/05.JVM 调优.html",redirect:"/pages/b8b917/"},{name:"v-5c1cca71",path:"/pages/2cdbc6/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-5c1cca71").then(t)}},{path:"/pages/2cdbc6/index.html",redirect:"/pages/2cdbc6/"},{path:"/01.Java 知识体系/03.Java/05.JVM/04.JVM 常用的调优工具.html",redirect:"/pages/2cdbc6/"},{name:"v-17d22485",path:"/pages/47235b/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-17d22485").then(t)}},{path:"/pages/47235b/index.html",redirect:"/pages/47235b/"},{path:"/01.Java 知识体系/04.系统设计/01.常用框架/01.Spring/01.Spring Bean.html",redirect:"/pages/47235b/"},{name:"v-1b7e4ff2",path:"/pages/5fcbaa/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-1b7e4ff2").then(t)}},{path:"/pages/5fcbaa/index.html",redirect:"/pages/5fcbaa/"},{path:"/01.Java 知识体系/04.系统设计/01.常用框架/01.Spring/02.Spring事务总结.html",redirect:"/pages/5fcbaa/"},{name:"v-4bab47ca",path:"/pages/4418d1/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-4bab47ca").then(t)}},{path:"/pages/4418d1/index.html",redirect:"/pages/4418d1/"},{path:"/01.Java 知识体系/04.系统设计/02.分布式/01.分布式锁/01.分布式锁介绍.html",redirect:"/pages/4418d1/"},{name:"v-d97f40f6",path:"/pages/d51c58/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-d97f40f6").then(t)}},{path:"/pages/d51c58/index.html",redirect:"/pages/d51c58/"},{path:"/01.Java 知识体系/04.系统设计/02.分布式/01.分布式锁/02.分布式锁常见实现方案总结.html",redirect:"/pages/d51c58/"},{name:"v-3bafe364",path:"/pages/8c09c7/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-3bafe364").then(t)}},{path:"/pages/8c09c7/index.html",redirect:"/pages/8c09c7/"},{path:"/01.Java 知识体系/04.系统设计/02.分布式/02.幂等性/01.幂等性介绍.html",redirect:"/pages/8c09c7/"},{name:"v-af103070",path:"/pages/126fc8/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-af103070").then(t)}},{path:"/pages/126fc8/index.html",redirect:"/pages/126fc8/"},{path:"/01.Java 知识体系/04.系统设计/02.分布式/03.RPC介绍.html",redirect:"/pages/126fc8/"},{name:"v-0b8ed9f8",path:"/pages/d2a1d0/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-0b8ed9f8").then(t)}},{path:"/pages/d2a1d0/index.html",redirect:"/pages/d2a1d0/"},{path:"/01.Java 知识体系/04.系统设计/03.微服务/01.SpringCloud/01.SpringCloud.html",redirect:"/pages/d2a1d0/"},{name:"v-31eab8d8",path:"/pages/a8e8ff/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-31eab8d8").then(t)}},{path:"/pages/a8e8ff/index.html",redirect:"/pages/a8e8ff/"},{path:"/01.Java 知识体系/04.系统设计/03.微服务/02.SpringCloudAlibaba/01.SpringCloudAlibaba.html",redirect:"/pages/a8e8ff/"},{name:"v-d2430cca",path:"/pages/80c6b1/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-d2430cca").then(t)}},{path:"/pages/80c6b1/index.html",redirect:"/pages/80c6b1/"},{path:"/01.Java 知识体系/04.系统设计/02.分布式/04.Dubbo.html",redirect:"/pages/80c6b1/"},{name:"v-2bf7dba4",path:"/pages/01d62e/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-2bf7dba4").then(t)}},{path:"/pages/01d62e/index.html",redirect:"/pages/01d62e/"},{path:"/01.Java 知识体系/04.系统设计/03.微服务/03.链路追踪SkyWalking.html",redirect:"/pages/01d62e/"},{name:"v-2da3c232",path:"/pages/ada754/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-2da3c232").then(t)}},{path:"/pages/ada754/index.html",redirect:"/pages/ada754/"},{path:"/01.Java 知识体系/04.系统设计/04.定时任务/02.分布式定时任务——Quartz.html",redirect:"/pages/ada754/"},{name:"v-27a25f92",path:"/pages/ae063e/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-27a25f92").then(t)}},{path:"/pages/ae063e/index.html",redirect:"/pages/ae063e/"},{path:"/01.Java 知识体系/04.系统设计/04.定时任务/01.Java 定时任务大全.html",redirect:"/pages/ae063e/"},{name:"v-d015cfc2",path:"/pages/56a50e/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-d015cfc2").then(t)}},{path:"/pages/56a50e/index.html",redirect:"/pages/56a50e/"},{path:"/01.Java 知识体系/05.代码质量/01.设计模式/01.设计模式简介.html",redirect:"/pages/56a50e/"},{name:"v-0173ec44",path:"/pages/dd97c6/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-0173ec44").then(t)}},{path:"/pages/dd97c6/index.html",redirect:"/pages/dd97c6/"},{path:"/01.Java 知识体系/04.系统设计/05.Web服务器/01.Nginx.html",redirect:"/pages/dd97c6/"},{name:"v-64b968d7",path:"/pages/62b3c2/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-64b968d7").then(t)}},{path:"/pages/62b3c2/index.html",redirect:"/pages/62b3c2/"},{path:"/01.Java 知识体系/05.代码质量/01.设计模式/02.责任链模式.html",redirect:"/pages/62b3c2/"},{name:"v-7cc9a2b6",path:"/pages/a2e658/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-7cc9a2b6").then(t)}},{path:"/pages/a2e658/index.html",redirect:"/pages/a2e658/"},{path:"/01.Java 知识体系/05.代码质量/01.设计模式/03.模版方法模式.html",redirect:"/pages/a2e658/"},{name:"v-39d6b1f3",path:"/pages/6281f2/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-39d6b1f3").then(t)}},{path:"/pages/6281f2/index.html",redirect:"/pages/6281f2/"},{path:"/01.Java 知识体系/05.代码质量/03.代码优化.html",redirect:"/pages/6281f2/"},{name:"v-193c5be4",path:"/pages/d83c14/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-193c5be4").then(t)}},{path:"/pages/d83c14/index.html",redirect:"/pages/d83c14/"},{path:"/01.Java 知识体系/05.代码质量/02.Java 命名规范.html",redirect:"/pages/d83c14/"},{name:"v-8ad2cece",path:"/pages/80654c/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-8ad2cece").then(t)}},{path:"/pages/80654c/index.html",redirect:"/pages/80654c/"},{path:"/02.Java 面试宝典/01.面试准备/02.简历制作.html",redirect:"/pages/80654c/"},{name:"v-33cdacc0",path:"/pages/5547aa/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-33cdacc0").then(t)}},{path:"/pages/5547aa/index.html",redirect:"/pages/5547aa/"},{path:"/02.Java 面试宝典/01.面试准备/01.面试准备.html",redirect:"/pages/5547aa/"},{name:"v-6d7f8b89",path:"/pages/5da9d3/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-6d7f8b89").then(t)}},{path:"/pages/5da9d3/index.html",redirect:"/pages/5da9d3/"},{path:"/02.Java 面试宝典/01.面试准备/03.Boss 直聘投简历技巧.html",redirect:"/pages/5da9d3/"},{name:"v-6ced3d6b",path:"/pages/346648/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-6ced3d6b").then(t)}},{path:"/pages/346648/index.html",redirect:"/pages/346648/"},{path:"/02.Java 面试宝典/02.Java 八股文/02.Java 集合 面试题.html",redirect:"/pages/346648/"},{name:"v-01767fb0",path:"/pages/b4d599/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-01767fb0").then(t)}},{path:"/pages/b4d599/index.html",redirect:"/pages/b4d599/"},{path:"/02.Java 面试宝典/02.Java 八股文/01.Java 基础面试题.html",redirect:"/pages/b4d599/"},{name:"v-74c22a5e",path:"/pages/f4f268/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-74c22a5e").then(t)}},{path:"/pages/f4f268/index.html",redirect:"/pages/f4f268/"},{path:"/02.Java 面试宝典/02.Java 八股文/03.Java 并发面试题.html",redirect:"/pages/f4f268/"},{name:"v-d4e3c634",path:"/pages/89ee48/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-d4e3c634").then(t)}},{path:"/pages/89ee48/index.html",redirect:"/pages/89ee48/"},{path:"/02.Java 面试宝典/02.Java 八股文/04.Java 新特性面试题.html",redirect:"/pages/89ee48/"},{name:"v-4e4a101c",path:"/pages/752c30/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-4e4a101c").then(t)}},{path:"/pages/752c30/index.html",redirect:"/pages/752c30/"},{path:"/02.Java 面试宝典/02.Java 八股文/05.JVM 面试题.html",redirect:"/pages/752c30/"},{name:"v-1b1c4248",path:"/pages/b23391/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-1b1c4248").then(t)}},{path:"/pages/b23391/index.html",redirect:"/pages/b23391/"},{path:"/02.Java 面试宝典/02.Java 八股文/06.MySQL 面试题.html",redirect:"/pages/b23391/"},{name:"v-23006aec",path:"/pages/330962/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-23006aec").then(t)}},{path:"/pages/330962/index.html",redirect:"/pages/330962/"},{path:"/02.Java 面试宝典/02.Java 八股文/08.Spring 面试题.html",redirect:"/pages/330962/"},{name:"v-7550b988",path:"/pages/e68641/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-7550b988").then(t)}},{path:"/pages/e68641/index.html",redirect:"/pages/e68641/"},{path:"/02.Java 面试宝典/02.Java 八股文/09.Mybatis&MybatisPlus 面试题.html",redirect:"/pages/e68641/"},{name:"v-4d5eaa9c",path:"/pages/b1ecc7/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-4d5eaa9c").then(t)}},{path:"/pages/b1ecc7/index.html",redirect:"/pages/b1ecc7/"},{path:"/02.Java 面试宝典/02.Java 八股文/07.Redis 面试题.html",redirect:"/pages/b1ecc7/"},{name:"v-be1bac58",path:"/pages/663a49/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-be1bac58").then(t)}},{path:"/pages/663a49/index.html",redirect:"/pages/663a49/"},{path:"/02.Java 面试宝典/02.Java 八股文/10.SpringBoot 面试题.html",redirect:"/pages/663a49/"},{name:"v-7fbbb95c",path:"/pages/3c9abe/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-7fbbb95c").then(t)}},{path:"/pages/3c9abe/index.html",redirect:"/pages/3c9abe/"},{path:"/02.Java 面试宝典/02.Java 八股文/11.SpringCloud 面试题.html",redirect:"/pages/3c9abe/"},{name:"v-9499db24",path:"/pages/4a2429/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-9499db24").then(t)}},{path:"/pages/4a2429/index.html",redirect:"/pages/4a2429/"},{path:"/02.Java 面试宝典/02.Java 八股文/12.SpringCloudAlibaba 面试题.html",redirect:"/pages/4a2429/"},{name:"v-4d6aaf62",path:"/pages/0d16b1/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-4d6aaf62").then(t)}},{path:"/pages/0d16b1/index.html",redirect:"/pages/0d16b1/"},{path:"/02.Java 面试宝典/02.Java 八股文/13.分布式.html",redirect:"/pages/0d16b1/"},{name:"v-9e602488",path:"/pages/d4abbd/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-9e602488").then(t)}},{path:"/pages/d4abbd/index.html",redirect:"/pages/d4abbd/"},{path:"/02.Java 面试宝典/02.Java 八股文/14.Nginx 面试题.html",redirect:"/pages/d4abbd/"},{name:"v-48671418",path:"/pages/1eb629/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-48671418").then(t)}},{path:"/pages/1eb629/index.html",redirect:"/pages/1eb629/"},{path:"/03.软技能/01.方法论/01.思考框架.html",redirect:"/pages/1eb629/"},{name:"v-c049eb16",path:"/pages/6fff61/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-c049eb16").then(t)}},{path:"/pages/6fff61/index.html",redirect:"/pages/6fff61/"},{path:"/03.软技能/01.方法论/02.时间管理GTD.html",redirect:"/pages/6fff61/"},{name:"v-1f3e78d6",path:"/pages/15a2bc/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-1f3e78d6").then(t)}},{path:"/pages/15a2bc/index.html",redirect:"/pages/15a2bc/"},{path:"/03.软技能/02.知识管理/01.搭建个人知识库.html",redirect:"/pages/15a2bc/"},{name:"v-43b3065b",path:"/pages/11d0b0/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-43b3065b").then(t)}},{path:"/pages/11d0b0/index.html",redirect:"/pages/11d0b0/"},{path:"/03.软技能/02.知识管理/03.如何高效的学习技术.html",redirect:"/pages/11d0b0/"},{name:"v-1d50b52b",path:"/pages/b7e1f4/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-1d50b52b").then(t)}},{path:"/pages/b7e1f4/index.html",redirect:"/pages/b7e1f4/"},{path:"/03.软技能/04.项目管理/01.初次走上技术管理岗位的思考总结 - 编码砖家 .html",redirect:"/pages/b7e1f4/"},{name:"v-0c243284",path:"/pages/feb22d/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-0c243284").then(t)}},{path:"/pages/feb22d/index.html",redirect:"/pages/feb22d/"},{path:"/03.软技能/02.知识管理/02.如何写一篇好的技术博客.html",redirect:"/pages/feb22d/"},{name:"v-20089476",path:"/blog/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-20089476").then(t)}},{path:"/blog/index.html",redirect:"/blog/"},{path:"/@pages/archivesPage.html",redirect:"/blog/"},{name:"v-1ea7fe80",path:"/pages/f28926/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-1ea7fe80").then(t)}},{path:"/pages/f28926/index.html",redirect:"/pages/f28926/"},{path:"/03.软技能/03.生活管理实用技能.html",redirect:"/pages/f28926/"},{name:"v-5ffddbde",path:"/",component:bs,beforeEnter:(n,e,t)=>{dl("Layout","v-5ffddbde").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:bs}],xs={title:"",description:"知识管理",base:"/java-notes/",headTags:[["link",{rel:"icon",href:"/java-notes/img/favicon.ico"}],["meta",{name:"keywords",content:"vuepress,theme,blog,vdoing"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"线性数据结构——数组、链表、栈、队列",frontmatter:{title:"线性数据结构——数组、链表、栈、队列",date:"2023-10-24T03:03:59.000Z",permalink:"/pages/0e35d1/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E3%80%81%E9%93%BE%E8%A1%A8%E3%80%81%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97.html",relativePath:"01.Java 知识体系/01.计算机基础/01.数据结构/01.线性数据结构——数组、链表、栈、队列.md",key:"v-0752b88c",path:"/pages/0e35d1/",headers:[{level:2,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:2},{level:2,title:"链表",slug:"链表",normalizedTitle:"链表",charIndex:227},{level:3,title:"单链表",slug:"单链表",normalizedTitle:"单链表",charIndex:530},{level:3,title:"双向链表",slug:"双向链表",normalizedTitle:"双向链表",charIndex:677},{level:3,title:"循环链表",slug:"循环链表",normalizedTitle:"循环链表",charIndex:729},{level:3,title:"双向循环链表",slug:"双向循环链表",normalizedTitle:"双向循环链表",charIndex:740},{level:3,title:"链表 vs 数组",slug:"链表-vs-数组",normalizedTitle:"链表 vs 数组",charIndex:805},{level:2,title:"栈",slug:"栈",normalizedTitle:"栈",charIndex:1081},{level:3,title:"栈的常见应用场景",slug:"栈的常见应用场景",normalizedTitle:"栈的常见应用场景",charIndex:1340},{level:4,title:"实现浏览器的回退和前进功能",slug:"实现浏览器的回退和前进功能",normalizedTitle:"实现浏览器的回退和前进功能",charIndex:1434},{level:4,title:"检查符号是否成对出现",slug:"检查符号是否成对出现",normalizedTitle:"检查符号是否成对出现",charIndex:1674},{level:4,title:"字符串反转",slug:"字符串反转",normalizedTitle:"字符串反转",charIndex:2880},{level:4,title:"维护函数调用",slug:"维护函数调用",normalizedTitle:"维护函数调用",charIndex:3340},{level:2,title:"队列",slug:"队列",normalizedTitle:"队列",charIndex:3409},{level:3,title:"队列简介",slug:"队列简介",normalizedTitle:"队列简介",charIndex:3416},{level:3,title:"队列分类",slug:"队列分类",normalizedTitle:"队列分类",charIndex:3676},{level:4,title:"单队列",slug:"单队列",normalizedTitle:"单队列",charIndex:3684},{level:4,title:"循环队列",slug:"循环队列",normalizedTitle:"循环队列",charIndex:4030},{level:4,title:"常见应用场景",slug:"常见应用场景",normalizedTitle:"常见应用场景",charIndex:1342}],headersStr:"数组 链表 单链表 双向链表 循环链表 双向循环链表 链表 vs 数组 栈 栈的常见应用场景 实现浏览器的回退和前进功能 检查符号是否成对出现 字符串反转 维护函数调用 队列 队列简介 队列分类 单队列 循环队列 常见应用场景",content:"# 数组\n\n**数组（Array）**是一种常见的数据结构。由相同类型的元素组成，并且使用一块连续的内存来存储。\n\n可以利用元素的索引计算出该元素对应的存储地址。\n\n数组的特点是：提供随机访问，并且容量有限。\n\n假如数组的长度为 n。\n访问：O（1）//访问特定位置的元素\n插入：O（n ）//最坏的情况发生在插入发生在数组的首部并需要移动所有元素时\n删除：O（n）//最坏的情况发生在删除数组的开头发生并需要移动第一元素后面所有的元素时\n\n\n\n\n\n# 链表\n\n**链表（LinkedList）**不会按线性的顺序存储数据，使用的不是连续的内存空间存储数据。\n\n链表的插入和删除操作的时间复杂度为 O(1)，只需要知道目标位置元素上一个元素就可以。但是，查找一个节点或者访问特定位置的节点时间复杂度为 O(n)。\n\n链表结构可以克服数组需要预知数据大小的缺点，充分利用计算机的内存空间，实现内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表每个节点还存放指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。\n\n假如链表中有n个元素。\n访问：O（n）//访问特定位置的元素\n插入删除：O（1）//必须要要知道插入元素的位置\n\n\n\n# 单链表\n\n单向链表只有一个方向，结点只有一个后继指针 next 指向后面的节点。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。\n\n\n\n\n# 双向链表\n\n包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。\n\n\n\n\n# 循环链表\n\n\n\n\n# 双向循环链表\n\n最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。\n\n\n\n\n# 链表 vs 数组\n\n * 数组支持随机访问，而链表不支持。\n * 数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。\n * 数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！\n\n应用场景：\n\n * 如果需要支持随机访问的话，链表没办法做到。\n * 如果需要存储的数据元素的个数不确定，并且需要经常添加和删除数据的话，使用链表比较合适。\n * 如果需要存储的数据元素的个数确定，并且不需要经常添加和删除数据的话，使用数组比较合适。\n\n\n# 栈\n\n栈 (stack)只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照 后进先出（LIFO, Last In First Out） 的原理运作。在栈中，push 和 pop 的操作都发生在栈顶。\n\n栈常用一维数组或链表来实现，用数组实现的栈叫作 顺序栈 ，用链表实现的栈叫作 链式栈 。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。\n\n假设堆栈中有n个元素。\n访问：O（n）//最坏情况\n插入删除：O（1）//顶端插入和删除元素\n\n\n\n\n\n# 栈的常见应用场景\n\n当我们我们要处理的数据只涉及在一端插入和删除数据，并且满足 后进先出（LIFO, Last In First Out） 的特性时，我们就可以使用栈这个数据结构。\n\n# 实现浏览器的回退和前进功能\n\n我们只需要使用两个栈(Stack1 和 Stack2)和就能实现这个功能。比如你按顺序查看了 1,2,3,4 这四个页面，我们依次把 1,2,3,4 这四个页面压入 Stack1 中。当你想回头看 2 这个页面的时候，你点击回退按钮，我们依次把 4,3 这两个页面从 Stack1 弹出，然后压入 Stack2 中。假如你又想回到页面 3，你点击前进按钮，我们将 3 页面从 Stack2 弹出，然后压入到 Stack1 中。示例图如下:\n\n\n\n# 检查符号是否成对出现\n\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断该字符串是否有效。\n\n有效字符串需满足：\n\n 1. 左括号必须用相同类型的右括号闭合。\n 2. 左括号必须以正确的顺序闭合。\n\n比如 \"()\"、\"()[]{}\"、\"{[]}\" 都是有效字符串，而 \"(]\" 、\"([)]\" 则不是。\n\n这个问题实际是 Leetcode 的一道题目，我们可以利用栈 Stack 来解决这个问题。\n\n 1. 首先我们将括号间的对应规则存放在 Map 中，这一点应该毋容置疑；\n 2. 创建一个栈。遍历字符串，如果字符是左括号就直接加入stack中，否则将stack 的栈顶元素与这个括号做比较，如果不相等就直接返回 false。遍历结束，如果stack为空，返回 true。\n\n  public boolean isVaild(String s) {\n        HashMap<Character, Character> characterHashMap = new HashMap<>();\n        characterHashMap.put(')', '(');\n        characterHashMap.put('}', '{');\n        characterHashMap.put(']', '[');\n        Stack<Character> stack = new Stack<>();\n        char[] chars = s.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            if(characterHashMap.containsKey(chars[i])) {\n                if(stack.isEmpty()) {\n                    return false;\n                }\n                Character character = characterHashMap.get(chars[i]);\n                Character pop = stack.pop();\n                if(!pop.equals(character)) {\n                    return false;\n                }\n            } else {\n                stack.push(chars[i]);\n            }\n        }\n        return stack.isEmpty();\n    }\n\n\n# 字符串反转\n\n将字符串中的每个字符先入栈再出栈就可以了。\n\npublic String revise(String s) {\n        Stack<Character> stack = new Stack<>();\n        char[] chars = s.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            stack.push(chars[i]);\n        }\n        int size = stack.size();\n        char[] copyChars = new char[size];\n        for (int i = 0; i < size; i++) {\n            copyChars[i] = stack.pop();\n        }\n\n        return new String(copyChars);\n    }\n\n\n# 维护函数调用\n\n最后一个被调用的函数必须先完成执行，符合栈的 后进先出（LIFO, Last In First Out） 特性。\n\n\n# 队列\n\n\n# 队列简介\n\n队列 是 先进先出( FIFO，First In, First Out) 的线性表。在具体应用中通常用链表或者数组来实现，用数组实现的队列叫作 顺序队列 ，用链表实现的队列叫作 链式队列 。队列只允许在后端（rear）进行插入操作也就是 入队 enqueue，在前端（front）进行删除操作也就是出队 dequeue\n\n队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。\n\n假设队列中有n个元素。\n访问：O（n）//最坏情况\n插入删除：O（1）//后端插入前端删除元素\n\n\n\n\n\n# 队列分类\n\n# 单队列\n\n单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为顺序队列（数组实现） 和 链式队列（链表实现）。\n\n顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况。\n\n假设下图是一个顺序队列，我们将前两个元素 1,2 出队，并入队两个元素 7,8。当进行入队、出队操作的时候，front 和 rear 都会持续往后移动（front 指针指向对头元素，rear 指针指向队列最后一个元素的下一位置），当 rear 移动到最后的时候,我们无法再往队列中添加数据，即使数组中还有空余空间，这种现象就是 ”假溢出“ 。除了假溢出问题之外，如下图所示，当添加元素 8 的时候，rear 指针移动到数组之外（越界）。\n\n当 front==rear 的时候队列为空。\n\n\n\n# 循环队列\n\n循环队列可以解决顺序队列的假溢出和越界问题。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。\n\n还是用上面的图，我们将 rear 指针指向数组下标为 0 的位置就不会有越界问题了。当我们再向队列中添加元素的时候， rear 向后移动。\n\n\n\n顺序队列中，我们说 front==rear 的时候队列为空，循环队列中则不一样，也可能为满。\n\n# 常见应用场景\n\n当我们需要按照一定顺序来处理数据的时候可以考虑使用队列这个数据结构。\n\n * 阻塞队列： 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。\n * 线程池中的请求/任务队列： 线程池中没有空闲线程时，新的任务请求线程资源时，线程池该如何处理呢？答案是将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列(基于链表)和有界队列(基于数组)。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如 ：FixedThreadPool 使用无界队列 LinkedBlockingQueue。但是有界队列就不一样了，当队列满的话后面再有任务/请求就会拒绝，在 Java 中的体现就是会抛出java.util.concurrent.RejectedExecutionException 异常。\n * Linux 内核进程队列（按优先级排队）\n * 现实生活中的派对，播放器上的播放列表;\n * 消息队列\n * 等等......",normalizedContent:"# 数组\n\n**数组（array）**是一种常见的数据结构。由相同类型的元素组成，并且使用一块连续的内存来存储。\n\n可以利用元素的索引计算出该元素对应的存储地址。\n\n数组的特点是：提供随机访问，并且容量有限。\n\n假如数组的长度为 n。\n访问：o（1）//访问特定位置的元素\n插入：o（n ）//最坏的情况发生在插入发生在数组的首部并需要移动所有元素时\n删除：o（n）//最坏的情况发生在删除数组的开头发生并需要移动第一元素后面所有的元素时\n\n\n\n\n\n# 链表\n\n**链表（linkedlist）**不会按线性的顺序存储数据，使用的不是连续的内存空间存储数据。\n\n链表的插入和删除操作的时间复杂度为 o(1)，只需要知道目标位置元素上一个元素就可以。但是，查找一个节点或者访问特定位置的节点时间复杂度为 o(n)。\n\n链表结构可以克服数组需要预知数据大小的缺点，充分利用计算机的内存空间，实现内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表每个节点还存放指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。\n\n假如链表中有n个元素。\n访问：o（n）//访问特定位置的元素\n插入删除：o（1）//必须要要知道插入元素的位置\n\n\n\n# 单链表\n\n单向链表只有一个方向，结点只有一个后继指针 next 指向后面的节点。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。\n\n\n\n\n# 双向链表\n\n包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。\n\n\n\n\n# 循环链表\n\n\n\n\n# 双向循环链表\n\n最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。\n\n\n\n\n# 链表 vs 数组\n\n * 数组支持随机访问，而链表不支持。\n * 数组使用的是连续内存空间对 cpu 的缓存机制友好，链表则相反。\n * 数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！\n\n应用场景：\n\n * 如果需要支持随机访问的话，链表没办法做到。\n * 如果需要存储的数据元素的个数不确定，并且需要经常添加和删除数据的话，使用链表比较合适。\n * 如果需要存储的数据元素的个数确定，并且不需要经常添加和删除数据的话，使用数组比较合适。\n\n\n# 栈\n\n栈 (stack)只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照 后进先出（lifo, last in first out） 的原理运作。在栈中，push 和 pop 的操作都发生在栈顶。\n\n栈常用一维数组或链表来实现，用数组实现的栈叫作 顺序栈 ，用链表实现的栈叫作 链式栈 。不管基于数组还是链表，入栈、出栈的时间复杂度都为 o(1)。\n\n假设堆栈中有n个元素。\n访问：o（n）//最坏情况\n插入删除：o（1）//顶端插入和删除元素\n\n\n\n\n\n# 栈的常见应用场景\n\n当我们我们要处理的数据只涉及在一端插入和删除数据，并且满足 后进先出（lifo, last in first out） 的特性时，我们就可以使用栈这个数据结构。\n\n# 实现浏览器的回退和前进功能\n\n我们只需要使用两个栈(stack1 和 stack2)和就能实现这个功能。比如你按顺序查看了 1,2,3,4 这四个页面，我们依次把 1,2,3,4 这四个页面压入 stack1 中。当你想回头看 2 这个页面的时候，你点击回退按钮，我们依次把 4,3 这两个页面从 stack1 弹出，然后压入 stack2 中。假如你又想回到页面 3，你点击前进按钮，我们将 3 页面从 stack2 弹出，然后压入到 stack1 中。示例图如下:\n\n\n\n# 检查符号是否成对出现\n\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断该字符串是否有效。\n\n有效字符串需满足：\n\n 1. 左括号必须用相同类型的右括号闭合。\n 2. 左括号必须以正确的顺序闭合。\n\n比如 \"()\"、\"()[]{}\"、\"{[]}\" 都是有效字符串，而 \"(]\" 、\"([)]\" 则不是。\n\n这个问题实际是 leetcode 的一道题目，我们可以利用栈 stack 来解决这个问题。\n\n 1. 首先我们将括号间的对应规则存放在 map 中，这一点应该毋容置疑；\n 2. 创建一个栈。遍历字符串，如果字符是左括号就直接加入stack中，否则将stack 的栈顶元素与这个括号做比较，如果不相等就直接返回 false。遍历结束，如果stack为空，返回 true。\n\n  public boolean isvaild(string s) {\n        hashmap<character, character> characterhashmap = new hashmap<>();\n        characterhashmap.put(')', '(');\n        characterhashmap.put('}', '{');\n        characterhashmap.put(']', '[');\n        stack<character> stack = new stack<>();\n        char[] chars = s.tochararray();\n        for (int i = 0; i < chars.length; i++) {\n            if(characterhashmap.containskey(chars[i])) {\n                if(stack.isempty()) {\n                    return false;\n                }\n                character character = characterhashmap.get(chars[i]);\n                character pop = stack.pop();\n                if(!pop.equals(character)) {\n                    return false;\n                }\n            } else {\n                stack.push(chars[i]);\n            }\n        }\n        return stack.isempty();\n    }\n\n\n# 字符串反转\n\n将字符串中的每个字符先入栈再出栈就可以了。\n\npublic string revise(string s) {\n        stack<character> stack = new stack<>();\n        char[] chars = s.tochararray();\n        for (int i = 0; i < chars.length; i++) {\n            stack.push(chars[i]);\n        }\n        int size = stack.size();\n        char[] copychars = new char[size];\n        for (int i = 0; i < size; i++) {\n            copychars[i] = stack.pop();\n        }\n\n        return new string(copychars);\n    }\n\n\n# 维护函数调用\n\n最后一个被调用的函数必须先完成执行，符合栈的 后进先出（lifo, last in first out） 特性。\n\n\n# 队列\n\n\n# 队列简介\n\n队列 是 先进先出( fifo，first in, first out) 的线性表。在具体应用中通常用链表或者数组来实现，用数组实现的队列叫作 顺序队列 ，用链表实现的队列叫作 链式队列 。队列只允许在后端（rear）进行插入操作也就是 入队 enqueue，在前端（front）进行删除操作也就是出队 dequeue\n\n队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。\n\n假设队列中有n个元素。\n访问：o（n）//最坏情况\n插入删除：o（1）//后端插入前端删除元素\n\n\n\n\n\n# 队列分类\n\n# 单队列\n\n单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为顺序队列（数组实现） 和 链式队列（链表实现）。\n\n顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况。\n\n假设下图是一个顺序队列，我们将前两个元素 1,2 出队，并入队两个元素 7,8。当进行入队、出队操作的时候，front 和 rear 都会持续往后移动（front 指针指向对头元素，rear 指针指向队列最后一个元素的下一位置），当 rear 移动到最后的时候,我们无法再往队列中添加数据，即使数组中还有空余空间，这种现象就是 ”假溢出“ 。除了假溢出问题之外，如下图所示，当添加元素 8 的时候，rear 指针移动到数组之外（越界）。\n\n当 front==rear 的时候队列为空。\n\n\n\n# 循环队列\n\n循环队列可以解决顺序队列的假溢出和越界问题。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。\n\n还是用上面的图，我们将 rear 指针指向数组下标为 0 的位置就不会有越界问题了。当我们再向队列中添加元素的时候， rear 向后移动。\n\n\n\n顺序队列中，我们说 front==rear 的时候队列为空，循环队列中则不一样，也可能为满。\n\n# 常见应用场景\n\n当我们需要按照一定顺序来处理数据的时候可以考虑使用队列这个数据结构。\n\n * 阻塞队列： 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。\n * 线程池中的请求/任务队列： 线程池中没有空闲线程时，新的任务请求线程资源时，线程池该如何处理呢？答案是将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列(基于链表)和有界队列(基于数组)。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如 ：fixedthreadpool 使用无界队列 linkedblockingqueue。但是有界队列就不一样了，当队列满的话后面再有任务/请求就会拒绝，在 java 中的体现就是会抛出java.util.concurrent.rejectedexecutionexception 异常。\n * linux 内核进程队列（按优先级排队）\n * 现实生活中的派对，播放器上的播放列表;\n * 消息队列\n * 等等......",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"哈希表",frontmatter:{title:"哈希表",date:"2023-10-24T03:03:59.000Z",permalink:"/pages/beb561/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E5%93%88%E5%B8%8C%E8%A1%A8.html",relativePath:"01.Java 知识体系/01.计算机基础/01.数据结构/02.哈希表.md",key:"v-37120786",path:"/pages/beb561/",headersStr:null,content:"使用哈希表可以进行快速的查找操作。\n\n哈希（散列）是电脑科学中一种对资料的处理方法，通过某种特定的函数/算法（称为散列函数/算法）将要检索的项与用来检索的索引（称为散列，或者散列值）关联起来，生成一种便于搜索的数据结构（称为散列表）。也译为散列（旧译哈希）。",normalizedContent:"使用哈希表可以进行快速的查找操作。\n\n哈希（散列）是电脑科学中一种对资料的处理方法，通过某种特定的函数/算法（称为散列函数/算法）将要检索的项与用来检索的索引（称为散列，或者散列值）关联起来，生成一种便于搜索的数据结构（称为散列表）。也译为散列（旧译哈希）。",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"树",frontmatter:{title:"树",date:"2023-10-24T03:03:59.000Z",permalink:"/pages/d2ac96/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E6%A0%91.html",relativePath:"01.Java 知识体系/01.计算机基础/01.数据结构/04.树.md",key:"v-6b67a3c6",path:"/pages/d2ac96/",headers:[{level:1,title:"二叉树的分类",slug:"二叉树的分类",normalizedTitle:"二叉树的分类",charIndex:567},{level:2,title:"满二叉树",slug:"满二叉树",normalizedTitle:"满二叉树",charIndex:734},{level:2,title:"完全二叉树",slug:"完全二叉树",normalizedTitle:"完全二叉树",charIndex:862},{level:2,title:"平衡二叉树",slug:"平衡二叉树",normalizedTitle:"平衡二叉树",charIndex:1148}],headersStr:"二叉树的分类 满二叉树 完全二叉树 平衡二叉树",content:"树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。\n\n一棵树具有以下特点：\n\n 1. 一棵树中的任意两个结点有且仅有唯一的一条路径连通。\n 2. 一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。\n 3. 一棵树不包含回路。\n\n下图就是一颗树，并且是一颗二叉树。\n\n\n\n如上图所示，通过上面这张图说明一下树中的常用概念：\n\n * 节点 ：树中的每个元素都可以统称为节点。\n * 根节点 ：顶层节点或者说没有父节点的节点。上图中 A 节点就是根节点。\n * 父节点 ：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 B 节点是 D 节点、E 节点的父节点。\n * 子节点 ：一个节点含有的子树的根节点称为该节点的子节点。上图中 D 节点、E 节点是 B 节点的子节点。\n * 兄弟节点 ：具有相同父节点的节点互称为兄弟节点。上图中 D 节点、E 节点的共同父节点是 B 节点，故 D 和 E 为兄弟节点。\n * 叶子节点 ：没有子节点的节点。上图中的 D、F、H、I 都是叶子节点。\n * 节点的高度 ：该节点到叶子节点的最长路径所包含的边数。\n * 节点的深度 ：根节点到该节点的路径所包含的边数\n * 节点的层数 ：节点的深度+1。\n * 树的高度 ：根节点的高度。\n\n\n# 二叉树的分类\n\n二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。\n\n二叉树 的分支通常被称作“左子树”或“右子树”。并且，二叉树 的分支具有左右次序，不能随意颠倒。\n\n二叉树 的第 i 层至多拥有 2^(i-1) 个节点，深度为 k 的二叉树至多总共有 2^(k+1)-1个节点（满二叉树的情况），至少有 2^(k)个节点。\n\n\n# 满二叉树\n\n一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 满二叉树。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是 满二叉树。如下图所示：\n\n\n\n\n# 完全二叉树\n\n除最后一层外，若其余层都是满的，并且最后一层可以是满的也可以是右边缺少连续的若干节点，则这个二叉树就是 完全二叉树 。\n\n大家可以想象为一棵树从根结点开始扩展，扩展完左子节点才能开始扩展右子节点，每扩展完一层，才能继续扩展下一层。如下图所示：\n\n\n\n完全二叉树有一个很好的性质：父结点和子节点的序号有着对应关系。\n\n如果根节点的序号为1，那么若父结点的序号是 i，那么左子节点的序号就是 2i，右子节点的序号是 2i+1。这个性质使得完全二叉树利用数组存储时可以极大地节省空间，以及利用序号找到某个节点的父结点和子节点，后续二叉树的存储会详细介绍。\n\n\n# 平衡二叉树\n\n平衡二叉树 是一棵二叉排序树，且具有以下性质：\n\n 1. 可以是一棵空树\n 2. 如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。\n\n平衡二叉树的常用实现方法有 红黑树、AVL 树、替罪羊树、加权平衡树、伸展树 等。\n\n",normalizedContent:"树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。\n\n一棵树具有以下特点：\n\n 1. 一棵树中的任意两个结点有且仅有唯一的一条路径连通。\n 2. 一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。\n 3. 一棵树不包含回路。\n\n下图就是一颗树，并且是一颗二叉树。\n\n\n\n如上图所示，通过上面这张图说明一下树中的常用概念：\n\n * 节点 ：树中的每个元素都可以统称为节点。\n * 根节点 ：顶层节点或者说没有父节点的节点。上图中 a 节点就是根节点。\n * 父节点 ：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 b 节点是 d 节点、e 节点的父节点。\n * 子节点 ：一个节点含有的子树的根节点称为该节点的子节点。上图中 d 节点、e 节点是 b 节点的子节点。\n * 兄弟节点 ：具有相同父节点的节点互称为兄弟节点。上图中 d 节点、e 节点的共同父节点是 b 节点，故 d 和 e 为兄弟节点。\n * 叶子节点 ：没有子节点的节点。上图中的 d、f、h、i 都是叶子节点。\n * 节点的高度 ：该节点到叶子节点的最长路径所包含的边数。\n * 节点的深度 ：根节点到该节点的路径所包含的边数\n * 节点的层数 ：节点的深度+1。\n * 树的高度 ：根节点的高度。\n\n\n# 二叉树的分类\n\n二叉树（binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。\n\n二叉树 的分支通常被称作“左子树”或“右子树”。并且，二叉树 的分支具有左右次序，不能随意颠倒。\n\n二叉树 的第 i 层至多拥有 2^(i-1) 个节点，深度为 k 的二叉树至多总共有 2^(k+1)-1个节点（满二叉树的情况），至少有 2^(k)个节点。\n\n\n# 满二叉树\n\n一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 满二叉树。也就是说，如果一个二叉树的层数为 k，且结点总数是(2^k) -1 ，则它就是 满二叉树。如下图所示：\n\n\n\n\n# 完全二叉树\n\n除最后一层外，若其余层都是满的，并且最后一层可以是满的也可以是右边缺少连续的若干节点，则这个二叉树就是 完全二叉树 。\n\n大家可以想象为一棵树从根结点开始扩展，扩展完左子节点才能开始扩展右子节点，每扩展完一层，才能继续扩展下一层。如下图所示：\n\n\n\n完全二叉树有一个很好的性质：父结点和子节点的序号有着对应关系。\n\n如果根节点的序号为1，那么若父结点的序号是 i，那么左子节点的序号就是 2i，右子节点的序号是 2i+1。这个性质使得完全二叉树利用数组存储时可以极大地节省空间，以及利用序号找到某个节点的父结点和子节点，后续二叉树的存储会详细介绍。\n\n\n# 平衡二叉树\n\n平衡二叉树 是一棵二叉排序树，且具有以下性质：\n\n 1. 可以是一棵空树\n 2. 如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。\n\n平衡二叉树的常用实现方法有 红黑树、avl 树、替罪羊树、加权平衡树、伸展树 等。\n\n",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"Linux 常用命令",frontmatter:{title:"Linux 常用命令",date:"2023-10-24T07:42:33.000Z",permalink:"/pages/74b53c/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/01.Linux/02.Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",relativePath:"01.Java 知识体系/01.计算机基础/02.操作系统/01.Linux/02.Linux 常用命令.md",key:"v-414ca65b",path:"/pages/74b53c/",headers:[{level:1,title:"系统管理",slug:"系统管理",normalizedTitle:"系统管理",charIndex:2},{level:2,title:"关机&&重启",slug:"关机-重启",normalizedTitle:"关机&amp;&amp;重启",charIndex:null},{level:2,title:"init 命令",slug:"init-命令",normalizedTitle:"init 命令",charIndex:162},{level:2,title:"echo",slug:"echo",normalizedTitle:"echo",charIndex:438},{level:2,title:"查看历史命令——history",slug:"查看历史命令-history",normalizedTitle:"查看历史命令——history",charIndex:631},{level:2,title:"查看进程——ps",slug:"查看进程-ps",normalizedTitle:"查看进程——ps",charIndex:878},{level:2,title:"service 命令——控制系统服务",slug:"service-命令-控制系统服务",normalizedTitle:"service 命令——控制系统服务",charIndex:983},{level:2,title:"systemctl 命令 – 管理系统服务",slug:"systemctl-命令-管理系统服务",normalizedTitle:"systemctl 命令 – 管理系统服务",charIndex:1124},{level:2,title:"端口处理",slug:"端口处理",normalizedTitle:"端口处理",charIndex:1505},{level:1,title:"磁盘管理",slug:"磁盘管理",normalizedTitle:"磁盘管理",charIndex:1709},{level:2,title:"sync",slug:"sync",normalizedTitle:"sync",charIndex:1718},{level:1,title:"用户管理",slug:"用户管理",normalizedTitle:"用户管理",charIndex:1748},{level:3,title:"添加用户",slug:"添加用户",normalizedTitle:"添加用户",charIndex:1889},{level:3,title:"指定/修改密码",slug:"指定-修改密码",normalizedTitle:"指定/修改密码",charIndex:1983},{level:3,title:"删除用户",slug:"删除用户",normalizedTitle:"删除用户",charIndex:2008},{level:3,title:"查询用户信息",slug:"查询用户信息",normalizedTitle:"查询用户信息",charIndex:2116},{level:3,title:"切换用户",slug:"切换用户",normalizedTitle:"切换用户",charIndex:1880},{level:3,title:"查看当前用户/登录用户",slug:"查看当前用户-登录用户",normalizedTitle:"查看当前用户/登录用户",charIndex:2219},{level:3,title:"用户组",slug:"用户组",normalizedTitle:"用户组",charIndex:1842},{level:3,title:"用户和组相关文件",slug:"用户和组相关文件",normalizedTitle:"用户和组相关文件",charIndex:2461},{level:1,title:"目录管理",slug:"目录管理",normalizedTitle:"目录管理",charIndex:2573},{level:2,title:"目录切换命令",slug:"目录切换命令",normalizedTitle:"目录切换命令",charIndex:2582},{level:2,title:"pwd",slug:"pwd",normalizedTitle:"pwd",charIndex:2738},{level:2,title:"查看目录——ls",slug:"查看目录-ls",normalizedTitle:"查看目录——ls",charIndex:2790},{level:2,title:"创建目录——mkdir",slug:"创建目录-mkdir",normalizedTitle:"创建目录——mkdir",charIndex:2876},{level:2,title:"删除空目录——rmdir",slug:"删除空目录-rmdir",normalizedTitle:"删除空目录——rmdir",charIndex:3045},{level:2,title:"查找目录——find",slug:"查找目录-find",normalizedTitle:"查找目录——find",charIndex:3190},{level:1,title:"文件管理",slug:"文件管理",normalizedTitle:"文件管理",charIndex:3893},{level:2,title:"创建空文件——touch",slug:"创建空文件-touch",normalizedTitle:"创建空文件——touch",charIndex:3902},{level:2,title:"文件拷贝——cp",slug:"文件拷贝-cp",normalizedTitle:"文件拷贝——cp",charIndex:4047},{level:2,title:"删除文件——rm",slug:"删除文件-rm",normalizedTitle:"删除文件——rm",charIndex:4419},{level:2,title:"文件重命名或文件移动——mv",slug:"文件重命名或文件移动-mv",normalizedTitle:"文件重命名或文件移动——mv",charIndex:4693},{level:2,title:"文件查看——cat/more/less/head/tail",slug:"文件查看-cat-more-less-head-tail",normalizedTitle:"文件查看——cat/more/less/head/tail",charIndex:5020},{level:3,title:"cat",slug:"cat",normalizedTitle:"cat",charIndex:5026},{level:3,title:"more",slug:"more",normalizedTitle:"more",charIndex:5030},{level:3,title:"less",slug:"less",normalizedTitle:"less",charIndex:5035},{level:3,title:"head",slug:"head",normalizedTitle:"head",charIndex:5040},{level:3,title:"tail",slug:"tail",normalizedTitle:"tail",charIndex:5045},{level:2,title:"搜索命令——grep",slug:"搜索命令-grep",normalizedTitle:"搜索命令——grep",charIndex:6579},{level:2,title:"符号链接——in",slug:"符号链接-in",normalizedTitle:"符号链接——in",charIndex:6810},{level:2,title:"压缩/解压缩文件",slug:"压缩-解压缩文件",normalizedTitle:"压缩/解压缩文件",charIndex:7056},{level:2,title:"wget命令——下载网络文件",slug:"wget命令-下载网络文件",normalizedTitle:"wget命令——下载网络文件",charIndex:7783},{level:2,title:"make 命令——编译内核或源码文件",slug:"make-命令-编译内核或源码文件",normalizedTitle:"make 命令——编译内核或源码文件",charIndex:8123},{level:1,title:"文本编辑器 vi 和 vim",slug:"文本编辑器-vi-和-vim",normalizedTitle:"文本编辑器 vi 和 vim",charIndex:8319},{level:2,title:"一般命令模式",slug:"一般命令模式",normalizedTitle:"一般命令模式",charIndex:8405},{level:2,title:"编辑模式",slug:"编辑模式",normalizedTitle:"编辑模式",charIndex:8416},{level:2,title:"命令行模式",slug:"命令行模式",normalizedTitle:"命令行模式",charIndex:8425},{level:1,title:"yum命令——基于RPM的软件包管理器",slug:"yum命令-基于rpm的软件包管理器",normalizedTitle:"yum命令——基于rpm的软件包管理器",charIndex:8923}],headersStr:"系统管理 关机&&重启 init 命令 echo 查看历史命令——history 查看进程——ps service 命令——控制系统服务 systemctl 命令 – 管理系统服务 端口处理 磁盘管理 sync 用户管理 添加用户 指定/修改密码 删除用户 查询用户信息 切换用户 查看当前用户/登录用户 用户组 用户和组相关文件 目录管理 目录切换命令 pwd 查看目录——ls 创建目录——mkdir 删除空目录——rmdir 查找目录——find 文件管理 创建空文件——touch 文件拷贝——cp 删除文件——rm 文件重命名或文件移动——mv 文件查看——cat/more/less/head/tail cat more less head tail 搜索命令——grep 符号链接——in 压缩/解压缩文件 wget命令——下载网络文件 make 命令——编译内核或源码文件 文本编辑器 vi 和 vim 一般命令模式 编辑模式 命令行模式 yum命令——基于RPM的软件包管理器",content:'# 系统管理\n\n\n# 关机&&重启\n\n * shutdown\n\n * \n * * shutdown -h now： 表示立即关机\n * \n * * shutdown -h 1： 表示1分钟后关机\n * \n * * shutdown -r now：立即重启\n\n * halt：立即关机\n\n * reboot：重启系统\n\n\n# init 命令\n\ninit 命令切换系统运行级别。\n\n运行级别说明：\n\n 1. 关机\n\n 2. 单用户【找回丢失密码】\n\n 3. 多用户状态没有网络服务\n\n 4. 多用户状态有网络服务\n\n 5. 系统未使用保留给用户\n\n 6. 图形界面\n\n 7. 系统重启\n\n\n\n常用运行级别是3和5，要修改默认的运行级别可修改文件/etc/inittab 的内容\n\nid:5:initdefault:\n\n\n也可以使用init [012356]指令切换到指定的运行级别。\n\n使用案例：\n\n * 使用init切换不同运行级别，然后关机\n\n * 找回root密码\n\n\n# echo\n\n * 基本语法\n\n * \n * * echo [选项] [输出内容]\n\n * 应用实例\n\n * \n * * 案例：使用echo指令输出环境变量,输出当前的环境路径。\n * \n * * \n * * * echo $PATH\n * \n * * 案例：使用echo指令输出hello,world!\n * \n * * \n * * * echo ”hello,world!“\n\n\n# 查看历史命令——history\n\n查看已轻执行过历史命令,也可以执行历史指令\n\n * 基本语法\n\n * \n * * history（功能描述，查看已经执行过历史命令）\n\n * 应用实例\n\n * \n * * 案例1：显示所有的历史命令\n * \n * * \n * * * history\n * \n * * 案例2：显示最近使用过的10个指令。\n * \n * * \n * * * history 10\n * \n * * 案例3：执行历史编号为5的指令\n * \n * * \n * * * !5\n\n\n# 查看进程——ps\n\nps -ef 去进行查看系统上的运行的所有进程。\n\n只执行ps命令，默认是显示当前控制台下属于当前用户的进程；\n\n * -e 显示运行在系统上的所有进程\n\n * -f 扩展显示输出\n\n\n# service 命令——控制系统服务\n\nservice命令可以启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。\n\n * 显示所有服务的状态：service --status-all\n\n * 重启网络服务：service network restart\n\n\n# systemctl 命令 – 管理系统服务\n\nsystemctl 是用于管理系统服务。从功能上涵盖了之前service、chkconfig、init、setup等多条命令的大部分功能。\n\n语法格式：systemctl 参数 服务\n\n常用参数：\n\nSTART                        启动服务\nstop                         停止服务\nrestart                      重启服务\nenable                       使某服务开机自启\ndisable                      关闭某服务开机自启\nstatus                       查看服务状态\nlist -units --type=service   列举所有已启动服务\n\n\n# 端口处理\n\nfirewall-cmd --list-ports #查看所有已开放的临时端口（默认为空） firewall-cmd --add-port=3306/tcp --permanent 添加永久开放的端口（例如：3306端口）\n\n配置结束后需要输入重载命令并重启防火墙以生效配置：\n\nfirewall-cmd --reload  \n\nsystemctl restart firewalld\n\n\n\n# 磁盘管理\n\n\n# sync\n\n * sync：将内存的数据同步到磁盘\n\n\n# 用户管理\n\nLinux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。\n\nLinux用户至少属于一个用户组。\n\nlogin：用户登入系统\n\nlogout：用户退出系统\n\nsu：切换用户\n\n\n# 添加用户\n\nuseradd [选项] 用户名\n\n\n当创建用户成功后，会自动创建和用户同名的家目录。也可以通过：useradd -d 指定目录 新的用户名给新创建的用户指定家目录。\n\n\n# 指定/修改密码\n\npasswd 用户名\n\n\n\n# 删除用户\n\nuserdel 用户名\n\n\n * 删除用户，保留家目录\n\n * \n * * \n\nuserdel 用户名\n\n\n * 删除用户，同时删除家目录\n\n * \n * * \n\nuserdel -r 用户名\n\n\n\n# 查询用户信息\n\nid 用户名\n\n\n\n# 切换用户\n\nsu - 用户名\n\n\n 1. 权限高的用户切换到权限低的用户，不需要输入密码，反之需要。\n\n 2. 当需要返回到原来的用户时，使用exit命令。\n\n\n# 查看当前用户/登录用户\n\nwhoami/who am l\n\n\n\n# 用户组\n\n每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同，如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。\n\n * 增加组：groupadd 组名\n\n * 增加用户时加上组：useradd -g 用户组 用户名\n\n * 删除组：groupdel 组名\n\n * 修改用户组：usermod -g 用户组 用户名\n\n\n# 用户和组相关文件\n\n * /ect/passwd文件：用户配置文件，记录用户各种信息\n\n * /ect/shadow文件：口命配置文件\n\n * /ect/group文件：组的配置文件，记录Linux包含的组的信息。\n\n\n# 目录管理\n\n\n# 目录切换命令\n\ncd（change directory）\n\n基本语法\n\n * cd[参数] （功能描述。切换到指定目录）\n\n常用参数：\n\n * 绝对路径和相对路径\n\n * cd ~或者cd ：回到自己的家目录\n\n * cd .. ：回到当前目录的上一级目录\n\n * cd -： 切换到上一个操作所在目录\n\n\n# pwd\n\npwd（print working directory）显示当前工作目录的绝对路径。\n\n\n# 查看目录——ls\n\nls [选项] [目录或是文件]\n\n\n常用选项：\n\n * -a：显示当前目录所有的文件和目录，包括隐藏的。\n\n * -l：以列表的方式显示信息\n\n\n# 创建目录——mkdir\n\n基本语法\n\nmkdir [选项] 要创建的目录\n\n\n常用选项\n\n-p：创建多级目录\n\n\n应用实例\n\n案例1：创建一个目录/home/dog\n    mkdir /home/dog\n案例2：创建多级目录/home/animal/tiger\n    mkdir -p /home/animal/tiger\n\n\n\n# 删除空目录——rmdir\n\nrmdir指令删除空目录\n\n * 基本语法\n\n * \n * * rmdir [选项] 要册除的空目录\n\n * 应用实例\n\n * \n * * 案例1：删除一个目录/home/dog使用细节\n\n * rmdir删除的是空目录，如果目录下有内容时无法删除的。\n\n\n# 查找目录——find\n\nfind指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。\n\n * 基本语法\n\n * \n * * find [搜索范围] [选项]\n\n * 选项说明\n\n * \n * * \n\n选项                                功能\n-name <查询方式>                      按照指定的文件名查找模式查找文件\n-user <用户名>                       查找属于指定用户名所有文件\n-size <文件大小>（+n大于-n小于n等于（n为数目））   按照指定的文件大小查找文件\n\n * 应用实例\n\n * \n * * 案例1：按文件名：根据名称查找/home目录下的hello.txt文件\n * \n * * \n * * * find /home -name hello.txt\n * \n * * 案例2：按拥有者：查找/opt目录下，用户名称为nobody的文件\n * \n * * \n * * * find /opt -user nobody\n * \n * * 案例3：查找整个linux系统下大于、等于、小于20m的文件\n * \n * * \n * * * find / -size +20M\n * \n * * \n * * * find / -size 20M\n * \n * * \n * * * find / -size -20M\n * \n * * 案例4：按文件名：根据名称查找/目录下的以txt结尾的文件\n * \n * * \n * * * find / -name *.txt\n\n\n# 文件管理\n\n\n# 创建空文件——touch\n\ntouch指令创建空文件\n\n * 基本语法\n\n * \n * * touch 文件名称s（可创建多个空文件）\n\n * 应用实例\n\n * \n * * 案例1：创建一个空文件hello.txt\n * \n * * \n * * * touch hello.txt\n\n\n# 文件拷贝——cp\n\ncp指令拷贝文件到指定目录。注意：cp 命令不仅可以拷贝文件还可以拷贝目录，压缩包等，拷贝文件和压缩包时不 用写-r 递归。\n\n * 基本语法\n\n * \n * * cp [选项] (source) (dest)\n\n * 常用选项\n\n * \n * * -r：递归复制整个文件夹\n\n * 应用实例\n\n * \n * * 案例1：将/home/aaa.txt拷贝到/home/bbb目录下（当前工作目录为/home）\n * \n * * \n * * * cp aaa.txt /home/bbb\n * \n * * 案例2：递归复制整个文件夹，举例\n * \n * * \n * * * cp -r src/ target/\n * \n * * \n * * * 注意一定要注意 你当前的工作目录位置，然后准确地定位源目录和目标目录。\n\n\n# 删除文件——rm\n\nrm指令移除文件或目录\n\n * 基本语法\n\n * \n * * rm [选项] (要删除的文件或目录)\n\n * 常用选项\n\n * \n * * -r：递归删除整个文件夹\n * \n * * -f：强制刚除不提示\n\n * 应用实例\n\n * \n * * 案例1：将/home/aaa.txt删除（当前工作目录为/home）\n * \n * * \n * * * rm aaa.txt\n * \n * * 案例2：递归删除整个文件夹/home/bbb（当前工作目录为/home）\n * \n * * \n * * * rm -rf bbb/\n\n\n# 文件重命名或文件移动——mv\n\n * 基本语法\n\n * \n * * mv (oldNameFile) (newNameFile)：(功能描述:重命名)\n * \n * * mv (/temp/movefile) (/targetFolder)：(功能描述:移动文件)\n\n * 应用实例\n\n * \n * * 案例1：将/home/aaa.txt文件重新命名为pig.txt（当前工作目录为/home）\n * \n * * \n * * * mv aaa.txt pig.txt\n * \n * * 案例2：将/home/pig.txt文件移动到root目录下（当前工作目录为/home）\n * \n * * \n * * * mv pig.txt /root\n\n\n# 文件查看——cat/more/less/head/tail\n\n\n# cat\n\ncat查看文件内容，是以只读的方式\n\n * 基本语法\n\n * \n * * cat [选项] 要查看的文件\n\n * 常用选项\n\n * \n * * -n：显示行号\n\n * 应用实例\n\n * \n * * 案例1: /ect/profile文件内容，并显示行号\n * \n * * \n * * * cat -n /ect/profile\n\n\n# more\n\nmore指令是一个基于vi编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。\n\nmore指令中内置了若干快捷键，详见操作说明：\n\n操作       功能说明\n空白键      向下翻一页\nEnter    向下翻一行\nq        离开more\nCtrl+F   向下滚动一屏\nCtrl+B   返回上一屏\n=        输出当前行号\n:f       输出文件名和当前的行号\n\n * 基本语法\n\n * \n * * more 要查看的文件操作说明\n\n * 应用实例\n\n * \n * * 案例：采用more查看文件/etc/profile\n * \n * * \n * * * more /etc/profile\n\n\n# less\n\nless指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。\n\n * 基本语法\n\n * \n * * less 要查看的文件\n\n * 操作说明\n\n * \n * * \n\n操作           功能说明\n空白键          向下翻动一页\n[PageDown]   向下翻动一页\n[PageUp]     向上翻动一页\n/字串          向下搜寻“字串”的功能：n：向下查我；N：向上查找；\n?字串          向上搜寻“字串”的功能：n：向上查我；N：向下查找；\nq            离开less这个程序\n\n\n# head\n\nhead用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容\n\n * 基本语法\n\n * \n * * head 文件路径（功能描述：查看文件头10行内容）\n * \n * * head -n 5 文件路径（功能描述：查看文件头5行内容，5可以是任意行数）\n\n * 应用实例\n\n * \n * * 案例：查看/etc/profile的前面5行代码\n * \n * * \n * * * head -n 5 /etc/profile\n\n\n# tail\n\ntail用于输出文件中尾部的内容，默认情况下tail指令显示文件的后10行内容。\n\n * 基本语法\n\n * \n * * tail 文件路径（功能描述:查看文件后10行内容）\n * \n * * tail -n 5 文件路径（功能描述:查看文件后5行内容，5可以是任意行数）\n * \n * * tail -f 文件路径（功能描述：实时追踪该文档的所有更新）\n\n * 应用实例\n\n * \n * * 案例1：查看/etc/profile最后5行的代码\n * \n * * \n * * * tail -n 5 /etc/profile\n * \n * * 案例2：实时监控mydate.txt，看看到文件有变化时，是否看到，实时的追加日期\n * \n * * \n * * * tail -f mydate.txt\n * \n * * 案例3：实时监控tomcat 的日志文件\n * \n * * \n * * * tail -f catalina-2016-11-11.log\n\n\n# 搜索命令——grep\n\ngrep过滤查找\n\n * 基本语法\n\n * \n * * grep [选项] 查找内容 源文件\n\n * 常用选项\n\n * \n * * \n\n选项   功能\n-n   显示匹配行及行号。\n-i   忽略字母大小写\n\n * 应用实例\n\n * \n * * 案例1：请在hello.txt文件中，查找"yes”所在行，并且显示行号。--color 代表高亮显示\n * \n * * grep -n yes hello.txt --colorr\n\n\n# 符号链接——in\n\n软链接也叫符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径。\n\n * 基本语法\n\n * \n * * ln -s [原文件或目录] [软链接名] （功能描述：给原文件创建一个软链接）（如果软链接名时目录路径，cd 软链接名 就能跳到目录）\n\n * 应用实例\n\n * \n * * 案例1：在/home目录下创建一个软连接linkToRoot，连接到/root目录\n * \n * * \n * * * ln -s /root linkToRoot\n\n\n# 压缩/解压缩文件\n\ntar指令是打包指令，最后打包后的文件是.tar.gz的文件。\n\n * 基本语法\n\n * \n * * tar [选项] XXX.tar.gz 打包的内容（功能描述，打包目录，压缩后的文件格式.tar.gz）。\n\n * 选项说明\n\n * \n * * \n\n选项   功能\n-c   产生.tar打包文件\n-v   显示详细信息\n-f   指定压缩后的文件名\n-z   通过gzip支持压缩或解压缩\n-x   解包.tar文件\n\n * 应用实例\n\n * \n * * 打包并压缩文件\n * \n * * \n * * * 命令：tar -zcvf 打包压缩后的文件名 要打包压缩的文件\n * \n * * \n * * * 假如 test 目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包 test 目录并指定压缩后的压缩包名称为 test.tar.gz 可以使用命令：**tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt** 或 **tar -zcvf test.tar.gz /test/**\n * \n * * 解压压缩包\n * \n * * \n * * * 命令：tar [-xvf] 压缩文件\n * \n * * \n * * * 将 /test 下的 test.tar.gz 解压到当前目录下可以使用命令：**tar -xvf test.tar.gz**\n * \n * * \n * * * 将 /test 下的 test.tar.gz 解压到根目录/usr 下:**tar -xvf test.tar.gz -C /usr**（- C 代表指定解压的位置）\n\n\n# wget命令——下载网络文件\n\nwget 是用于从指定网址下载网络文件。wget 命令非常稳定，一般即便网络波动也不会导致下载失败，而是不断的尝试重连，直至整个文件下载完毕。需使用 yum -y install wget 安装\n\n语法格式： wget [参数] 网址\n\n常用参数：\n\n-V                  显示版本信息\n-h                  显示帮助信息\n-b                  启动后转入后台执行\n-c                  支持断点续传\n-O                  定义本地文件名\n-e <命令>             执行指定的命令\n--limit-rate=<速率>   限制下载速度\n\n\n# make 命令——编译内核或源码文件\n\nmake 命令的功能是用于编译内核或源码文件。make是GNU工程化编译工具，用于编译众多相互关联的源代码文件，也可以编译内核或模块功能，以工程化的工作方式，提高开发效率。\n\n初次运行 make 命令时，它会通过扫描Makefile文件找到目标及其依赖关系，并在建立依赖关系后依次编译所对应的源码程序。\n\n语法格式: make [参数] 文件\n\n\n# 文本编辑器 vi 和 vim\n\n所有的Linux系统都会内建 vi 文本编辑器。vim 具有程序编辑的能力，是 vi 的增强版本。\n\n基本上有 vi 有3种模式：\n\n * 一般命令模式\n\n * 编辑模式\n\n * 命令行模式\n\n\n\n\n# 一般命令模式\n\n一般命令模式，可以使用快捷键，其他模式不能使用快捷键。\n\n以 vi 方式打开一个文件默认进入正常模式。在正常模式中，可以使用上下左右来移动光标，可以删除字符或者整行来处理文档内容，可以使用复制粘贴处理文件数据。\n\n正常模式的快捷键：\n\n * dd 删除光标所在的行\n\n * delete 删除单个字符\n\n * yy 复制光标所在的行\n\n * p 粘贴复制的内容在光标所在的行的下一行。\n\n\n# 编辑模式\n\n在正常模式，按下 I、i、A、a、O、o、R、r等等一些字母就可以进入到编辑模式，一般都按下i进入编辑模式。编辑完成之后按ESC键返回一般命令模式。\n\n\n# 命令行模式\n\n一般命令模式输入 : 进入命令行模式。命令行模式可以使用命令来完成读取、保存、替换、退出、显示行号等动作。常用的命令有：\n\n * w : 表示保存\n\n * wq：表示保存并退出\n\n * q：表示直 接退出\n\n * q! ： 表示强制退 出\n\n * 搜索/查找： /关键词。在搜索结果中切换上/下一个结果：N(上一个)、n（下一个），如果需要取消高亮，需要输入:nohl\n\n\n# yum命令——基于RPM的软件包管理器\n\nyum 基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。\n\n常用命令：\n\n * 仅安装指定的软件命令：yum install <package_name>\n\n * 列出所有可安裝的软件清单命令：yum list\n\n * 删除软件包命令：yum remove <package_name>\n\n * 查找软件包命令：yum search',normalizedContent:'# 系统管理\n\n\n# 关机&&重启\n\n * shutdown\n\n * \n * * shutdown -h now： 表示立即关机\n * \n * * shutdown -h 1： 表示1分钟后关机\n * \n * * shutdown -r now：立即重启\n\n * halt：立即关机\n\n * reboot：重启系统\n\n\n# init 命令\n\ninit 命令切换系统运行级别。\n\n运行级别说明：\n\n 1. 关机\n\n 2. 单用户【找回丢失密码】\n\n 3. 多用户状态没有网络服务\n\n 4. 多用户状态有网络服务\n\n 5. 系统未使用保留给用户\n\n 6. 图形界面\n\n 7. 系统重启\n\n\n\n常用运行级别是3和5，要修改默认的运行级别可修改文件/etc/inittab 的内容\n\nid:5:initdefault:\n\n\n也可以使用init [012356]指令切换到指定的运行级别。\n\n使用案例：\n\n * 使用init切换不同运行级别，然后关机\n\n * 找回root密码\n\n\n# echo\n\n * 基本语法\n\n * \n * * echo [选项] [输出内容]\n\n * 应用实例\n\n * \n * * 案例：使用echo指令输出环境变量,输出当前的环境路径。\n * \n * * \n * * * echo $path\n * \n * * 案例：使用echo指令输出hello,world!\n * \n * * \n * * * echo ”hello,world!“\n\n\n# 查看历史命令——history\n\n查看已轻执行过历史命令,也可以执行历史指令\n\n * 基本语法\n\n * \n * * history（功能描述，查看已经执行过历史命令）\n\n * 应用实例\n\n * \n * * 案例1：显示所有的历史命令\n * \n * * \n * * * history\n * \n * * 案例2：显示最近使用过的10个指令。\n * \n * * \n * * * history 10\n * \n * * 案例3：执行历史编号为5的指令\n * \n * * \n * * * !5\n\n\n# 查看进程——ps\n\nps -ef 去进行查看系统上的运行的所有进程。\n\n只执行ps命令，默认是显示当前控制台下属于当前用户的进程；\n\n * -e 显示运行在系统上的所有进程\n\n * -f 扩展显示输出\n\n\n# service 命令——控制系统服务\n\nservice命令可以启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。\n\n * 显示所有服务的状态：service --status-all\n\n * 重启网络服务：service network restart\n\n\n# systemctl 命令 – 管理系统服务\n\nsystemctl 是用于管理系统服务。从功能上涵盖了之前service、chkconfig、init、setup等多条命令的大部分功能。\n\n语法格式：systemctl 参数 服务\n\n常用参数：\n\nstart                        启动服务\nstop                         停止服务\nrestart                      重启服务\nenable                       使某服务开机自启\ndisable                      关闭某服务开机自启\nstatus                       查看服务状态\nlist -units --type=service   列举所有已启动服务\n\n\n# 端口处理\n\nfirewall-cmd --list-ports #查看所有已开放的临时端口（默认为空） firewall-cmd --add-port=3306/tcp --permanent 添加永久开放的端口（例如：3306端口）\n\n配置结束后需要输入重载命令并重启防火墙以生效配置：\n\nfirewall-cmd --reload  \n\nsystemctl restart firewalld\n\n\n\n# 磁盘管理\n\n\n# sync\n\n * sync：将内存的数据同步到磁盘\n\n\n# 用户管理\n\nlinux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。\n\nlinux用户至少属于一个用户组。\n\nlogin：用户登入系统\n\nlogout：用户退出系统\n\nsu：切换用户\n\n\n# 添加用户\n\nuseradd [选项] 用户名\n\n\n当创建用户成功后，会自动创建和用户同名的家目录。也可以通过：useradd -d 指定目录 新的用户名给新创建的用户指定家目录。\n\n\n# 指定/修改密码\n\npasswd 用户名\n\n\n\n# 删除用户\n\nuserdel 用户名\n\n\n * 删除用户，保留家目录\n\n * \n * * \n\nuserdel 用户名\n\n\n * 删除用户，同时删除家目录\n\n * \n * * \n\nuserdel -r 用户名\n\n\n\n# 查询用户信息\n\nid 用户名\n\n\n\n# 切换用户\n\nsu - 用户名\n\n\n 1. 权限高的用户切换到权限低的用户，不需要输入密码，反之需要。\n\n 2. 当需要返回到原来的用户时，使用exit命令。\n\n\n# 查看当前用户/登录用户\n\nwhoami/who am l\n\n\n\n# 用户组\n\n每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 linux 系统对用户组的规定有所不同，如 linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。\n\n * 增加组：groupadd 组名\n\n * 增加用户时加上组：useradd -g 用户组 用户名\n\n * 删除组：groupdel 组名\n\n * 修改用户组：usermod -g 用户组 用户名\n\n\n# 用户和组相关文件\n\n * /ect/passwd文件：用户配置文件，记录用户各种信息\n\n * /ect/shadow文件：口命配置文件\n\n * /ect/group文件：组的配置文件，记录linux包含的组的信息。\n\n\n# 目录管理\n\n\n# 目录切换命令\n\ncd（change directory）\n\n基本语法\n\n * cd[参数] （功能描述。切换到指定目录）\n\n常用参数：\n\n * 绝对路径和相对路径\n\n * cd ~或者cd ：回到自己的家目录\n\n * cd .. ：回到当前目录的上一级目录\n\n * cd -： 切换到上一个操作所在目录\n\n\n# pwd\n\npwd（print working directory）显示当前工作目录的绝对路径。\n\n\n# 查看目录——ls\n\nls [选项] [目录或是文件]\n\n\n常用选项：\n\n * -a：显示当前目录所有的文件和目录，包括隐藏的。\n\n * -l：以列表的方式显示信息\n\n\n# 创建目录——mkdir\n\n基本语法\n\nmkdir [选项] 要创建的目录\n\n\n常用选项\n\n-p：创建多级目录\n\n\n应用实例\n\n案例1：创建一个目录/home/dog\n    mkdir /home/dog\n案例2：创建多级目录/home/animal/tiger\n    mkdir -p /home/animal/tiger\n\n\n\n# 删除空目录——rmdir\n\nrmdir指令删除空目录\n\n * 基本语法\n\n * \n * * rmdir [选项] 要册除的空目录\n\n * 应用实例\n\n * \n * * 案例1：删除一个目录/home/dog使用细节\n\n * rmdir删除的是空目录，如果目录下有内容时无法删除的。\n\n\n# 查找目录——find\n\nfind指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。\n\n * 基本语法\n\n * \n * * find [搜索范围] [选项]\n\n * 选项说明\n\n * \n * * \n\n选项                                功能\n-name <查询方式>                      按照指定的文件名查找模式查找文件\n-user <用户名>                       查找属于指定用户名所有文件\n-size <文件大小>（+n大于-n小于n等于（n为数目））   按照指定的文件大小查找文件\n\n * 应用实例\n\n * \n * * 案例1：按文件名：根据名称查找/home目录下的hello.txt文件\n * \n * * \n * * * find /home -name hello.txt\n * \n * * 案例2：按拥有者：查找/opt目录下，用户名称为nobody的文件\n * \n * * \n * * * find /opt -user nobody\n * \n * * 案例3：查找整个linux系统下大于、等于、小于20m的文件\n * \n * * \n * * * find / -size +20m\n * \n * * \n * * * find / -size 20m\n * \n * * \n * * * find / -size -20m\n * \n * * 案例4：按文件名：根据名称查找/目录下的以txt结尾的文件\n * \n * * \n * * * find / -name *.txt\n\n\n# 文件管理\n\n\n# 创建空文件——touch\n\ntouch指令创建空文件\n\n * 基本语法\n\n * \n * * touch 文件名称s（可创建多个空文件）\n\n * 应用实例\n\n * \n * * 案例1：创建一个空文件hello.txt\n * \n * * \n * * * touch hello.txt\n\n\n# 文件拷贝——cp\n\ncp指令拷贝文件到指定目录。注意：cp 命令不仅可以拷贝文件还可以拷贝目录，压缩包等，拷贝文件和压缩包时不 用写-r 递归。\n\n * 基本语法\n\n * \n * * cp [选项] (source) (dest)\n\n * 常用选项\n\n * \n * * -r：递归复制整个文件夹\n\n * 应用实例\n\n * \n * * 案例1：将/home/aaa.txt拷贝到/home/bbb目录下（当前工作目录为/home）\n * \n * * \n * * * cp aaa.txt /home/bbb\n * \n * * 案例2：递归复制整个文件夹，举例\n * \n * * \n * * * cp -r src/ target/\n * \n * * \n * * * 注意一定要注意 你当前的工作目录位置，然后准确地定位源目录和目标目录。\n\n\n# 删除文件——rm\n\nrm指令移除文件或目录\n\n * 基本语法\n\n * \n * * rm [选项] (要删除的文件或目录)\n\n * 常用选项\n\n * \n * * -r：递归删除整个文件夹\n * \n * * -f：强制刚除不提示\n\n * 应用实例\n\n * \n * * 案例1：将/home/aaa.txt删除（当前工作目录为/home）\n * \n * * \n * * * rm aaa.txt\n * \n * * 案例2：递归删除整个文件夹/home/bbb（当前工作目录为/home）\n * \n * * \n * * * rm -rf bbb/\n\n\n# 文件重命名或文件移动——mv\n\n * 基本语法\n\n * \n * * mv (oldnamefile) (newnamefile)：(功能描述:重命名)\n * \n * * mv (/temp/movefile) (/targetfolder)：(功能描述:移动文件)\n\n * 应用实例\n\n * \n * * 案例1：将/home/aaa.txt文件重新命名为pig.txt（当前工作目录为/home）\n * \n * * \n * * * mv aaa.txt pig.txt\n * \n * * 案例2：将/home/pig.txt文件移动到root目录下（当前工作目录为/home）\n * \n * * \n * * * mv pig.txt /root\n\n\n# 文件查看——cat/more/less/head/tail\n\n\n# cat\n\ncat查看文件内容，是以只读的方式\n\n * 基本语法\n\n * \n * * cat [选项] 要查看的文件\n\n * 常用选项\n\n * \n * * -n：显示行号\n\n * 应用实例\n\n * \n * * 案例1: /ect/profile文件内容，并显示行号\n * \n * * \n * * * cat -n /ect/profile\n\n\n# more\n\nmore指令是一个基于vi编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。\n\nmore指令中内置了若干快捷键，详见操作说明：\n\n操作       功能说明\n空白键      向下翻一页\nenter    向下翻一行\nq        离开more\nctrl+f   向下滚动一屏\nctrl+b   返回上一屏\n=        输出当前行号\n:f       输出文件名和当前的行号\n\n * 基本语法\n\n * \n * * more 要查看的文件操作说明\n\n * 应用实例\n\n * \n * * 案例：采用more查看文件/etc/profile\n * \n * * \n * * * more /etc/profile\n\n\n# less\n\nless指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。\n\n * 基本语法\n\n * \n * * less 要查看的文件\n\n * 操作说明\n\n * \n * * \n\n操作           功能说明\n空白键          向下翻动一页\n[pagedown]   向下翻动一页\n[pageup]     向上翻动一页\n/字串          向下搜寻“字串”的功能：n：向下查我；n：向上查找；\n?字串          向上搜寻“字串”的功能：n：向上查我；n：向下查找；\nq            离开less这个程序\n\n\n# head\n\nhead用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容\n\n * 基本语法\n\n * \n * * head 文件路径（功能描述：查看文件头10行内容）\n * \n * * head -n 5 文件路径（功能描述：查看文件头5行内容，5可以是任意行数）\n\n * 应用实例\n\n * \n * * 案例：查看/etc/profile的前面5行代码\n * \n * * \n * * * head -n 5 /etc/profile\n\n\n# tail\n\ntail用于输出文件中尾部的内容，默认情况下tail指令显示文件的后10行内容。\n\n * 基本语法\n\n * \n * * tail 文件路径（功能描述:查看文件后10行内容）\n * \n * * tail -n 5 文件路径（功能描述:查看文件后5行内容，5可以是任意行数）\n * \n * * tail -f 文件路径（功能描述：实时追踪该文档的所有更新）\n\n * 应用实例\n\n * \n * * 案例1：查看/etc/profile最后5行的代码\n * \n * * \n * * * tail -n 5 /etc/profile\n * \n * * 案例2：实时监控mydate.txt，看看到文件有变化时，是否看到，实时的追加日期\n * \n * * \n * * * tail -f mydate.txt\n * \n * * 案例3：实时监控tomcat 的日志文件\n * \n * * \n * * * tail -f catalina-2016-11-11.log\n\n\n# 搜索命令——grep\n\ngrep过滤查找\n\n * 基本语法\n\n * \n * * grep [选项] 查找内容 源文件\n\n * 常用选项\n\n * \n * * \n\n选项   功能\n-n   显示匹配行及行号。\n-i   忽略字母大小写\n\n * 应用实例\n\n * \n * * 案例1：请在hello.txt文件中，查找"yes”所在行，并且显示行号。--color 代表高亮显示\n * \n * * grep -n yes hello.txt --colorr\n\n\n# 符号链接——in\n\n软链接也叫符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径。\n\n * 基本语法\n\n * \n * * ln -s [原文件或目录] [软链接名] （功能描述：给原文件创建一个软链接）（如果软链接名时目录路径，cd 软链接名 就能跳到目录）\n\n * 应用实例\n\n * \n * * 案例1：在/home目录下创建一个软连接linktoroot，连接到/root目录\n * \n * * \n * * * ln -s /root linktoroot\n\n\n# 压缩/解压缩文件\n\ntar指令是打包指令，最后打包后的文件是.tar.gz的文件。\n\n * 基本语法\n\n * \n * * tar [选项] xxx.tar.gz 打包的内容（功能描述，打包目录，压缩后的文件格式.tar.gz）。\n\n * 选项说明\n\n * \n * * \n\n选项   功能\n-c   产生.tar打包文件\n-v   显示详细信息\n-f   指定压缩后的文件名\n-z   通过gzip支持压缩或解压缩\n-x   解包.tar文件\n\n * 应用实例\n\n * \n * * 打包并压缩文件\n * \n * * \n * * * 命令：tar -zcvf 打包压缩后的文件名 要打包压缩的文件\n * \n * * \n * * * 假如 test 目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包 test 目录并指定压缩后的压缩包名称为 test.tar.gz 可以使用命令：**tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt** 或 **tar -zcvf test.tar.gz /test/**\n * \n * * 解压压缩包\n * \n * * \n * * * 命令：tar [-xvf] 压缩文件\n * \n * * \n * * * 将 /test 下的 test.tar.gz 解压到当前目录下可以使用命令：**tar -xvf test.tar.gz**\n * \n * * \n * * * 将 /test 下的 test.tar.gz 解压到根目录/usr 下:**tar -xvf test.tar.gz -c /usr**（- c 代表指定解压的位置）\n\n\n# wget命令——下载网络文件\n\nwget 是用于从指定网址下载网络文件。wget 命令非常稳定，一般即便网络波动也不会导致下载失败，而是不断的尝试重连，直至整个文件下载完毕。需使用 yum -y install wget 安装\n\n语法格式： wget [参数] 网址\n\n常用参数：\n\n-v                  显示版本信息\n-h                  显示帮助信息\n-b                  启动后转入后台执行\n-c                  支持断点续传\n-o                  定义本地文件名\n-e <命令>             执行指定的命令\n--limit-rate=<速率>   限制下载速度\n\n\n# make 命令——编译内核或源码文件\n\nmake 命令的功能是用于编译内核或源码文件。make是gnu工程化编译工具，用于编译众多相互关联的源代码文件，也可以编译内核或模块功能，以工程化的工作方式，提高开发效率。\n\n初次运行 make 命令时，它会通过扫描makefile文件找到目标及其依赖关系，并在建立依赖关系后依次编译所对应的源码程序。\n\n语法格式: make [参数] 文件\n\n\n# 文本编辑器 vi 和 vim\n\n所有的linux系统都会内建 vi 文本编辑器。vim 具有程序编辑的能力，是 vi 的增强版本。\n\n基本上有 vi 有3种模式：\n\n * 一般命令模式\n\n * 编辑模式\n\n * 命令行模式\n\n\n\n\n# 一般命令模式\n\n一般命令模式，可以使用快捷键，其他模式不能使用快捷键。\n\n以 vi 方式打开一个文件默认进入正常模式。在正常模式中，可以使用上下左右来移动光标，可以删除字符或者整行来处理文档内容，可以使用复制粘贴处理文件数据。\n\n正常模式的快捷键：\n\n * dd 删除光标所在的行\n\n * delete 删除单个字符\n\n * yy 复制光标所在的行\n\n * p 粘贴复制的内容在光标所在的行的下一行。\n\n\n# 编辑模式\n\n在正常模式，按下 i、i、a、a、o、o、r、r等等一些字母就可以进入到编辑模式，一般都按下i进入编辑模式。编辑完成之后按esc键返回一般命令模式。\n\n\n# 命令行模式\n\n一般命令模式输入 : 进入命令行模式。命令行模式可以使用命令来完成读取、保存、替换、退出、显示行号等动作。常用的命令有：\n\n * w : 表示保存\n\n * wq：表示保存并退出\n\n * q：表示直 接退出\n\n * q! ： 表示强制退 出\n\n * 搜索/查找： /关键词。在搜索结果中切换上/下一个结果：n(上一个)、n（下一个），如果需要取消高亮，需要输入:nohl\n\n\n# yum命令——基于rpm的软件包管理器\n\nyum 基于 rpm 包管理，能够从指定的服务器自动下载 rpm 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。\n\n常用命令：\n\n * 仅安装指定的软件命令：yum install <package_name>\n\n * 列出所有可安裝的软件清单命令：yum list\n\n * 删除软件包命令：yum remove <package_name>\n\n * 查找软件包命令：yum search',charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"图",frontmatter:{title:"图",date:"2023-10-24T03:03:59.000Z",permalink:"/pages/8751ef/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E5%9B%BE.html",relativePath:"01.Java 知识体系/01.计算机基础/01.数据结构/03.图.md",key:"v-243cc8aa",path:"/pages/8751ef/",headers:[{level:3,title:"基本概念",slug:"基本概念",normalizedTitle:"基本概念",charIndex:146},{level:4,title:"顶点",slug:"顶点",normalizedTitle:"顶点",charIndex:9},{level:4,title:"边",slug:"边",normalizedTitle:"边",charIndex:24},{level:4,title:"度",slug:"度",normalizedTitle:"度",charIndex:270},{level:4,title:"无向图和有向图",slug:"无向图和有向图",normalizedTitle:"无向图和有向图",charIndex:362},{level:4,title:"无权图和带权图",slug:"无权图和带权图",normalizedTitle:"无权图和带权图",charIndex:561},{level:3,title:"图的存储",slug:"图的存储",normalizedTitle:"图的存储",charIndex:728},{level:4,title:"邻接矩阵存储",slug:"邻接矩阵存储",normalizedTitle:"邻接矩阵存储",charIndex:736},{level:4,title:"邻接表存储",slug:"邻接表存储",normalizedTitle:"邻接表存储",charIndex:1056},{level:3,title:"图的搜索",slug:"图的搜索",normalizedTitle:"图的搜索",charIndex:1346},{level:4,title:"广度优先搜索",slug:"广度优先搜索",normalizedTitle:"广度优先搜索",charIndex:1354},{level:4,title:"深度优先搜索",slug:"深度优先搜索",normalizedTitle:"深度优先搜索",charIndex:1491}],headersStr:"基本概念 顶点 边 度 无向图和有向图 无权图和带权图 图的存储 邻接矩阵存储 邻接表存储 图的搜索 广度优先搜索 深度优先搜索",content:"简单来说，图就是由顶点的有穷非空集合和顶点之间的边组成的集合。通常表示为：G(V,E)，其中，G表示一个图，V表示顶点的集合，E表示边的集合。\n\n下图所展示的就是图这种数据结构，并且还是一张有向图。\n\n\n\n图在我们日常生活中的例子很多！比如我们在社交软件上好友关系就可以用图来表示。\n\n\n# 基本概念\n\n# 顶点\n\n图中的数据元素，我们称之为顶点，图至少有一个顶点（非空有穷集合）\n\n对应到好友关系图，每一个用户就代表一个顶点。\n\n# 边\n\n顶点之间的关系用边表示。\n\n对应到好友关系图，两个用户是好友的话，那两者之间就存在一条边。\n\n# 度\n\n度表示一个顶点包含多少条边，在有向图中，还分为出度和入度，出度表示从该顶点出去的边的条数，入度表示进入该顶点的边的条数。\n\n对应到好友关系图，度就代表了某个人的好友数量。\n\n# 无向图和有向图\n\n边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A是B的同学，那么B也肯定是A的同学，那么在表示A和B的关系时，就不用关注方向，用不带箭头的边表示，这样的图就是无向图。\n\n有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，A是B的爸爸，但B肯定不是A的爸爸，A关注B，B不一定关注A。在这种情况下，我们就用带箭头的边表示二者的关系，这样的图就是有向图。\n\n# 无权图和带权图\n\n对于一个关系，如果我们只关心关系的有无，而不关心关系有多强，那么就可以用无权图表示二者的关系。\n\n对于一个关系，如果我们既关心关系的有无，也关心关系的强度，比如描述地图上两个城市的关系，需要用到距离，那么就用带权图来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。\n\n下图就是一个带权有向图。\n\n\n\n\n# 图的存储\n\n# 邻接矩阵存储\n\n邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。\n\n如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 A[i][j]=n 。\n\n在无向图中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，A[i][j]=1，当顶点i和顶点j没有关系时，A[i][j]=0。如下图所示：\n\n\n\n值得注意的是：无向图的邻接矩阵是一个对称矩阵，因为在无向图中，顶点i和顶点j有关系，则顶点j和顶点i必有关系。\n\n\n\n邻接矩阵存储的方式优点是简单直接（直接使用一个二维数组即可），并且，在获取两个定点之间的关系的时候也非常高效（直接获取指定位置的数组元素的值即可）。但是，这种存储方式的缺点也比较明显，那就是比较浪费空间。\n\n# 邻接表存储\n\n针对上面邻接矩阵比较浪费内存空间的问题，诞生了图的另外一种存储方法—邻接表 。\n\n邻接链表使用一个链表来存储某个顶点的所有后继相邻顶点。对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的 邻接表。如下图所示：\n\n\n\n\n\n大家可以数一数邻接表中所存储的元素的个数以及图中边的条数，你会发现：\n\n * 在无向图中，邻接表元素个数等于边的条数的两倍，如左图所示的无向图中，边的条数为7，邻接表存储的元素个数为14。\n * 在有向图中，邻接表元素个数等于边的条数，如右图所示的有向图中，边的条数为8，邻接表存储的元素个数为8。\n\n\n# 图的搜索\n\n# 广度优先搜索\n\n广度优先搜索就像水面上的波纹一样一层一层向外扩展，如下图所示：\n\n\n\n广度优先搜索的具体实现方式用到了之前所学过的线性数据结构——队列 。具体过程如下图所示：\n\n第1步：\n\n第2步：\n\n\n\n第3步：\n\n\n\n第4步：\n\n\n\n第5步：\n\n\n\n第6步：\n\n\n\n# 深度优先搜索\n\n深度优先搜索就是“一条路走到黑”，从源顶点开始，一直走到没有后继节点，才回溯到上一顶点，然后继续“一条路走到黑”，如下图所示：\n\n和广度优先搜索类似，深度优先搜索的具体实现用到了另一种线性数据结构——栈 。具体过程如下图所示：\n\n第1步：\n\n\n\n第2步：\n\n\n\n第3步：\n\n\n\n第4步：\n\n\n\n第5步：\n\n\n\n第6步：\n\n",normalizedContent:"简单来说，图就是由顶点的有穷非空集合和顶点之间的边组成的集合。通常表示为：g(v,e)，其中，g表示一个图，v表示顶点的集合，e表示边的集合。\n\n下图所展示的就是图这种数据结构，并且还是一张有向图。\n\n\n\n图在我们日常生活中的例子很多！比如我们在社交软件上好友关系就可以用图来表示。\n\n\n# 基本概念\n\n# 顶点\n\n图中的数据元素，我们称之为顶点，图至少有一个顶点（非空有穷集合）\n\n对应到好友关系图，每一个用户就代表一个顶点。\n\n# 边\n\n顶点之间的关系用边表示。\n\n对应到好友关系图，两个用户是好友的话，那两者之间就存在一条边。\n\n# 度\n\n度表示一个顶点包含多少条边，在有向图中，还分为出度和入度，出度表示从该顶点出去的边的条数，入度表示进入该顶点的边的条数。\n\n对应到好友关系图，度就代表了某个人的好友数量。\n\n# 无向图和有向图\n\n边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，a是b的同学，那么b也肯定是a的同学，那么在表示a和b的关系时，就不用关注方向，用不带箭头的边表示，这样的图就是无向图。\n\n有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，a是b的爸爸，但b肯定不是a的爸爸，a关注b，b不一定关注a。在这种情况下，我们就用带箭头的边表示二者的关系，这样的图就是有向图。\n\n# 无权图和带权图\n\n对于一个关系，如果我们只关心关系的有无，而不关心关系有多强，那么就可以用无权图表示二者的关系。\n\n对于一个关系，如果我们既关心关系的有无，也关心关系的强度，比如描述地图上两个城市的关系，需要用到距离，那么就用带权图来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。\n\n下图就是一个带权有向图。\n\n\n\n\n# 图的存储\n\n# 邻接矩阵存储\n\n邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。\n\n如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 a[i][j]=n 。\n\n在无向图中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，a[i][j]=1，当顶点i和顶点j没有关系时，a[i][j]=0。如下图所示：\n\n\n\n值得注意的是：无向图的邻接矩阵是一个对称矩阵，因为在无向图中，顶点i和顶点j有关系，则顶点j和顶点i必有关系。\n\n\n\n邻接矩阵存储的方式优点是简单直接（直接使用一个二维数组即可），并且，在获取两个定点之间的关系的时候也非常高效（直接获取指定位置的数组元素的值即可）。但是，这种存储方式的缺点也比较明显，那就是比较浪费空间。\n\n# 邻接表存储\n\n针对上面邻接矩阵比较浪费内存空间的问题，诞生了图的另外一种存储方法—邻接表 。\n\n邻接链表使用一个链表来存储某个顶点的所有后继相邻顶点。对于图中每个顶点vi，把所有邻接于vi的顶点vj链成一个单链表，这个单链表称为顶点vi的 邻接表。如下图所示：\n\n\n\n\n\n大家可以数一数邻接表中所存储的元素的个数以及图中边的条数，你会发现：\n\n * 在无向图中，邻接表元素个数等于边的条数的两倍，如左图所示的无向图中，边的条数为7，邻接表存储的元素个数为14。\n * 在有向图中，邻接表元素个数等于边的条数，如右图所示的有向图中，边的条数为8，邻接表存储的元素个数为8。\n\n\n# 图的搜索\n\n# 广度优先搜索\n\n广度优先搜索就像水面上的波纹一样一层一层向外扩展，如下图所示：\n\n\n\n广度优先搜索的具体实现方式用到了之前所学过的线性数据结构——队列 。具体过程如下图所示：\n\n第1步：\n\n第2步：\n\n\n\n第3步：\n\n\n\n第4步：\n\n\n\n第5步：\n\n\n\n第6步：\n\n\n\n# 深度优先搜索\n\n深度优先搜索就是“一条路走到黑”，从源顶点开始，一直走到没有后继节点，才回溯到上一顶点，然后继续“一条路走到黑”，如下图所示：\n\n和广度优先搜索类似，深度优先搜索的具体实现用到了另一种线性数据结构——栈 。具体过程如下图所示：\n\n第1步：\n\n\n\n第2步：\n\n\n\n第3步：\n\n\n\n第4步：\n\n\n\n第5步：\n\n\n\n第6步：\n\n",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"Linux",frontmatter:{title:"Linux",date:"2023-10-24T07:42:33.000Z",permalink:"/pages/ee514b/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/01.Linux/01.Linux.html",relativePath:"01.Java 知识体系/01.计算机基础/02.操作系统/01.Linux/01.Linux.md",key:"v-59615ba1",path:"/pages/ee514b/",headers:[{level:1,title:"Linux简介",slug:"linux简介",normalizedTitle:"linux简介",charIndex:2},{level:2,title:"常见的Linux发行版本",slug:"常见的linux发行版本",normalizedTitle:"常见的linux发行版本",charIndex:83},{level:2,title:"常见的操作系统",slug:"常见的操作系统",normalizedTitle:"常见的操作系统",charIndex:222},{level:3,title:"Windows",slug:"windows",normalizedTitle:"windows",charIndex:234},{level:3,title:"Unix",slug:"unix",normalizedTitle:"unix",charIndex:30},{level:3,title:"Linux",slug:"linux",normalizedTitle:"linux",charIndex:2},{level:3,title:"Mac OS",slug:"mac-os",normalizedTitle:"mac os",charIndex:439},{level:1,title:"Linux 文件系统",slug:"linux-文件系统",normalizedTitle:"linux 文件系统",charIndex:512},{level:2,title:"Linux文件系统简介",slug:"linux文件系统简介",normalizedTitle:"linux文件系统简介",charIndex:527},{level:2,title:"Linux目录树",slug:"linux目录树",normalizedTitle:"linux目录树",charIndex:718}],headersStr:"Linux简介 常见的Linux发行版本 常见的操作系统 Windows Unix Linux Mac OS Linux 文件系统 Linux文件系统简介 Linux目录树",content:"# Linux简介\n\nLinux 是一套免费使用、开源的类 Unix 操作系统。 Linux 存在着许多不同的发行版本，但它们都使用了 Linux 内核 。\n\n\n# 常见的Linux发行版本\n\nLinux 的发行版本可以大体分为两类：\n\n * 商业公司维护的发行版本，以著名的 Red Hat 为代表，比较典型的有 CentOS 。\n\n * 社区组织维护的发行版本，以 Debian 为代表，比较典型的有 Ubuntu、Debian。\n\n\n# 常见的操作系统\n\n\n# Windows\n\n目前最流行的个人桌面操作系统 。界面简单易操作，软件生态非常好。\n\n\n# Unix\n\n最早的多用户、多任务操作系统 。后面崛起的 Linux 在很多方面都参考了 Unix。\n\n目前这款操作系统已经逐渐逐渐退出操作系统的舞台。\n\n\n# Linux\n\nLinux 是一套免费使用、开源的类 Unix 操作系统。 Linux 存在着许多不同的发行版本，但它们都使用了 Linux 内核 。\n\n\n# Mac OS\n\n苹果自家的操作系统，编程体验和 Linux 相当，但是界面、软件生态以及用户体验各方面都要比 Linux 操作系统更好。\n\n\n# Linux 文件系统\n\n\n# Linux文件系统简介\n\n在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。 也就是说在 Linux 系统中有一个重要的概念：一切都是文件。\n\n其实这是 UNIX 哲学的一个体现，在 UNIX 系统中，把一切资源都看作是文件，Linux 的文件系统也是借鉴 UNIX 文件系统而来。\n\n\n# Linux目录树\n\n所有可操作的计算机资源都存在于目录树这个结构中，对计算资源的访问，可以看做是对这棵目录树的访问。\n\nLinux 的目录结构如下：\n\nLinux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：\n\n\n\n常见目录说明：\n\n * /bin： 存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里；\n\n * /etc： 存放系统管理和配置文件；\n\n * /home： 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是/home/user，可以用~user 表示；\n\n * /usr ： 用于存放系统应用程序；\n\n * /opt： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；\n\n * /proc： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；\n\n * /root： 超级用户（系统管理员）的主目录；\n\n * /sbin: 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；\n\n * /dev： 用于存放设备文件，类似于windwos的设备管理器；\n\n * /mnt： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；\n\n * /boot： 存放用于系统引导时使用的各种文件；\n\n * /lib ： 存放着和系统运行相关的库文件 ；\n\n * /tmp： 用于存放各种临时文件，是公用的临时文件存储点；\n\n * /var： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；\n\n * /lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。",normalizedContent:"# linux简介\n\nlinux 是一套免费使用、开源的类 unix 操作系统。 linux 存在着许多不同的发行版本，但它们都使用了 linux 内核 。\n\n\n# 常见的linux发行版本\n\nlinux 的发行版本可以大体分为两类：\n\n * 商业公司维护的发行版本，以著名的 red hat 为代表，比较典型的有 centos 。\n\n * 社区组织维护的发行版本，以 debian 为代表，比较典型的有 ubuntu、debian。\n\n\n# 常见的操作系统\n\n\n# windows\n\n目前最流行的个人桌面操作系统 。界面简单易操作，软件生态非常好。\n\n\n# unix\n\n最早的多用户、多任务操作系统 。后面崛起的 linux 在很多方面都参考了 unix。\n\n目前这款操作系统已经逐渐逐渐退出操作系统的舞台。\n\n\n# linux\n\nlinux 是一套免费使用、开源的类 unix 操作系统。 linux 存在着许多不同的发行版本，但它们都使用了 linux 内核 。\n\n\n# mac os\n\n苹果自家的操作系统，编程体验和 linux 相当，但是界面、软件生态以及用户体验各方面都要比 linux 操作系统更好。\n\n\n# linux 文件系统\n\n\n# linux文件系统简介\n\n在 linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。 也就是说在 linux 系统中有一个重要的概念：一切都是文件。\n\n其实这是 unix 哲学的一个体现，在 unix 系统中，把一切资源都看作是文件，linux 的文件系统也是借鉴 unix 文件系统而来。\n\n\n# linux目录树\n\n所有可操作的计算机资源都存在于目录树这个结构中，对计算资源的访问，可以看做是对这棵目录树的访问。\n\nlinux 的目录结构如下：\n\nlinux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：\n\n\n\n常见目录说明：\n\n * /bin： 存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里；\n\n * /etc： 存放系统管理和配置文件；\n\n * /home： 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是/home/user，可以用~user 表示；\n\n * /usr ： 用于存放系统应用程序；\n\n * /opt： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；\n\n * /proc： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；\n\n * /root： 超级用户（系统管理员）的主目录；\n\n * /sbin: 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；\n\n * /dev： 用于存放设备文件，类似于windwos的设备管理器；\n\n * /mnt： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；\n\n * /boot： 存放用于系统引导时使用的各种文件；\n\n * /lib ： 存放着和系统运行相关的库文件 ；\n\n * /tmp： 用于存放各种临时文件，是公用的临时文件存储点；\n\n * /var： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；\n\n * /lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"数据库基础与SQL",frontmatter:{title:"数据库基础与SQL",date:"2023-10-24T03:12:19.000Z",permalink:"/pages/67462f/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/02.%E6%95%B0%E6%8D%AE%E5%BA%93/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E4%B8%8ESQL.html",relativePath:"01.Java 知识体系/02.数据库/01.数据库基础与SQL.md",key:"v-90b1f352",path:"/pages/67462f/",headers:[{level:1,title:"数据库基础",slug:"数据库基础",normalizedTitle:"数据库基础",charIndex:2},{level:1,title:"SQL",slug:"sql",normalizedTitle:"sql",charIndex:453},{level:2,title:"什么是SQL",slug:"什么是sql",normalizedTitle:"什么是sql",charIndex:461},{level:2,title:"事务",slug:"事务",normalizedTitle:"事务",charIndex:670},{level:3,title:"ACID特性",slug:"acid特性",normalizedTitle:"acid特性",charIndex:712},{level:3,title:"隔离级别",slug:"隔离级别",normalizedTitle:"隔离级别",charIndex:992},{level:4,title:"可重复读和幻读",slug:"可重复读和幻读",normalizedTitle:"可重复读和幻读",charIndex:1363}],headersStr:"数据库基础 SQL 什么是SQL 事务 ACID特性 隔离级别 可重复读和幻读",content:"# 数据库基础\n\n数据库（database）：保存有组织的数据的容器（通常是一个文件或者一组文件）\n\n数据库管理系统：我们并不能直接访问数据库，而是通过DBMS（数据库管理系统）访问数据库。\n\n表（table）：某种特定类型数据的结构化清单。\n\n数据库中的每个表都有一个表名，用来标识自己。这个表名在相同数据库中是唯一的，在不同数据库可以使用相同的表名。\n\n模式（schema）：关于数据库和表的布局及特性的信息。\n\n列（column）：表中的一个字段。所有表都是由一个或多个列组成的。数据库中每个列都有相应的数据类型。\n\n数据类型（datatype）：所容许的数据的类型。每个表列都有相应的数据类型，限制（或容许）该列存储的数据。\n\n行（row）：表中的一个记录。表中的数据按行存储，每个记录都存储在自己的行内。\n\n主键（primary key）：一列（或一组列），其值能够区分表中每个行。\n\n外键（foreign key）：外键为某个表中的一列，包含另一个表的主键值，定义了两个表之间的关系。\n\n\n# SQL\n\n\n# 什么是SQL\n\nSQL是结构化查询语言（Structured Query Language）的缩写，是一种专门用来与数据库通信的语言。\n\nSQL提供了一种从数据库中读写数据的简单有效方法。\n\nSQL优点：\n\n * SQL不是特定数据库供应商专有的语言。几乎所有重要的DBMS都支持SQL。但是任意两个DBMS实现的SQL都不完全相同。\n * SQL简单易学。\n * SQL可以进行非常复杂和高级的数据库操作。\n\n\n# 事务\n\n事务是逻辑上的一组操作，事务中的操作要么全都成功，要么全都不成功。\n\n\n# ACID特性\n\n事务ACID特性指的是：\n\n * 原子性（atomicity）:事务是一个不可分割的最小工作单元，事务中的所有操作要么全部提交成功，要么全部失败回滚。\n * 一致性（consistency）:数据库总是从一个一致性状态转换到另一个一致性状态。也就说事务前后数据要保持一致。\n * 隔离性（isolation）:一个事务所做的修改在最终提交之前，对其他事务是不可见。\n * 持久性（durability）:事务一旦提交，所做的修改将会永久保存到数据库中。即使系统奔溃，修改的数据也不会丢失。\n\nACID 中，C 是目的，AID 是手段。\n\n\n# 隔离级别\n\nSQL标准定义了四种隔离级别：\n\n * READ UNCOMMITTED(未提交读)：事务中的修改，即使没有提交。对其他事务也是可见的。事务可以读取未提交的数据，这也被称为脏读。\n * READ COMMITTED（提交读）：一个事务从开始直到提交之前，所做的修改对其他事务都是不可见的。这个级别会导致不可重复读，即两次执行同样的查询，可能会得到不一样的结果。\n * REPEATABLE READ（可重复读）：这个级别解决了脏读和不可重复读问题。保证了在同一事务多次读取同样的记录结果是一致的。但还是无法解决幻读问题，幻读指某个事务在读取某个范围内记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围记录时，会产生幻行。\n * SERIALIZABLE（可串行化）：最高的隔离级别。强制事务串行执行。\n\n# 可重复读和幻读\n\n> 在可重复读中，该sql第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。\n> \n> 但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来实现。\n> \n> 转自：https://www.cnblogs.com/catmelo/p/8878961.html",normalizedContent:"# 数据库基础\n\n数据库（database）：保存有组织的数据的容器（通常是一个文件或者一组文件）\n\n数据库管理系统：我们并不能直接访问数据库，而是通过dbms（数据库管理系统）访问数据库。\n\n表（table）：某种特定类型数据的结构化清单。\n\n数据库中的每个表都有一个表名，用来标识自己。这个表名在相同数据库中是唯一的，在不同数据库可以使用相同的表名。\n\n模式（schema）：关于数据库和表的布局及特性的信息。\n\n列（column）：表中的一个字段。所有表都是由一个或多个列组成的。数据库中每个列都有相应的数据类型。\n\n数据类型（datatype）：所容许的数据的类型。每个表列都有相应的数据类型，限制（或容许）该列存储的数据。\n\n行（row）：表中的一个记录。表中的数据按行存储，每个记录都存储在自己的行内。\n\n主键（primary key）：一列（或一组列），其值能够区分表中每个行。\n\n外键（foreign key）：外键为某个表中的一列，包含另一个表的主键值，定义了两个表之间的关系。\n\n\n# sql\n\n\n# 什么是sql\n\nsql是结构化查询语言（structured query language）的缩写，是一种专门用来与数据库通信的语言。\n\nsql提供了一种从数据库中读写数据的简单有效方法。\n\nsql优点：\n\n * sql不是特定数据库供应商专有的语言。几乎所有重要的dbms都支持sql。但是任意两个dbms实现的sql都不完全相同。\n * sql简单易学。\n * sql可以进行非常复杂和高级的数据库操作。\n\n\n# 事务\n\n事务是逻辑上的一组操作，事务中的操作要么全都成功，要么全都不成功。\n\n\n# acid特性\n\n事务acid特性指的是：\n\n * 原子性（atomicity）:事务是一个不可分割的最小工作单元，事务中的所有操作要么全部提交成功，要么全部失败回滚。\n * 一致性（consistency）:数据库总是从一个一致性状态转换到另一个一致性状态。也就说事务前后数据要保持一致。\n * 隔离性（isolation）:一个事务所做的修改在最终提交之前，对其他事务是不可见。\n * 持久性（durability）:事务一旦提交，所做的修改将会永久保存到数据库中。即使系统奔溃，修改的数据也不会丢失。\n\nacid 中，c 是目的，aid 是手段。\n\n\n# 隔离级别\n\nsql标准定义了四种隔离级别：\n\n * read uncommitted(未提交读)：事务中的修改，即使没有提交。对其他事务也是可见的。事务可以读取未提交的数据，这也被称为脏读。\n * read committed（提交读）：一个事务从开始直到提交之前，所做的修改对其他事务都是不可见的。这个级别会导致不可重复读，即两次执行同样的查询，可能会得到不一样的结果。\n * repeatable read（可重复读）：这个级别解决了脏读和不可重复读问题。保证了在同一事务多次读取同样的记录结果是一致的。但还是无法解决幻读问题，幻读指某个事务在读取某个范围内记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围记录时，会产生幻行。\n * serializable（可串行化）：最高的隔离级别。强制事务串行执行。\n\n# 可重复读和幻读\n\n> 在可重复读中，该sql第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务a先前读取了数据，或者修改了全部数据，事务b还是可以insert数据提交，这时事务a就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。\n> \n> 但是mysql、oracle、postgresql等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的mvcc（多版本并发控制）来实现。\n> \n> 转自：https://www.cnblogs.com/catmelo/p/8878961.html",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"MySQL简介",frontmatter:{title:"MySQL简介",date:"2023-10-24T03:12:56.000Z",permalink:"/pages/c9b13a/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/02.%E6%95%B0%E6%8D%AE%E5%BA%93/02.MySQL/01.MySQL%E7%AE%80%E4%BB%8B.html",relativePath:"01.Java 知识体系/02.数据库/02.MySQL/01.MySQL简介.md",key:"v-73deb80f",path:"/pages/c9b13a/",headers:[{level:1,title:"并发控制",slug:"并发控制",normalizedTitle:"并发控制",charIndex:175},{level:1,title:"事务",slug:"事务",normalizedTitle:"事务",charIndex:415},{level:1,title:"多版本并发控制",slug:"多版本并发控制",normalizedTitle:"多版本并发控制",charIndex:830}],headersStr:"并发控制 事务 多版本并发控制",content:"MySQL是基于客户机——服务器的DBMS。服务器部分负责所有数据访问和处理的一个软件。客户机是与用户打交道的软件。\n\n使用MySQL的原因：\n\n * 成本：MySQL开源，可以免费使用。\n * 性能：MySQL执行非常快。\n * 可信赖：某些非常重要和声望高的公司、站点使用MySQL处理重要数据。\n * 简单：MySQL容易安装和使用。\n\n\n# 并发控制\n\nMySQL有两个层面的并发控制：服务器层与存储引擎层。\n\n通用使用锁解决并发问题。有两种类型的锁：共享锁和排他锁，也叫读锁和写锁。读锁是共享的，相互不阻塞，写锁是排他的，一个写锁会阻塞其他的读和写操作。\n\n有两种最重要的锁策略：表锁和行级锁。\n\n表锁是最基本的锁策略，并且是开销最小的策略（加锁也是需要消耗资源的）。表锁会锁定整张表。\n\n行级锁可以最大程度支持并发处理，同时也带来最大的锁开销。行级锁只在存储引擎实现。比如InnoDB存储引擎就实现了行急锁。\n\n\n# 事务\n\nMySQL的InnoDB存储引擎支持事务。\n\nMySQL默认自动提交事务。可以通过设置AUTOCOMMIT变量来启用或者禁用自动提交事务。\n\nshow VARIABLES like 'AUTOCOMMIT'; //查看是否是自动提交模式，ON启用，OFF禁用\nSET AUTOCOMMIT=1; //1启用自动提交模式，0禁用\n\n\n可以通过SET TRANSACTION ISOLATION LEVEL 命令设置隔离级别,新的隔离级别在下一个事务开始的时候生效。MySQL的InnoDB存储引擎支持所有隔离级别。\n\nSET TRANSACTION ISOLATION LEVEL READ COMMITED\n\n\nMySQL事务是由下层的存储引擎实现的，所以避免在同一个事务中，使用多种存储引擎。假如在一个事务中混合使用了事务型和非事务型表（比如InnoDB和MyISAM表），回滚时非事务型表的数据是无法回滚的。\n\n\n# 多版本并发控制\n\nMySQL的大多数事务型存储引擎实现的都不是简单的行级锁。为了提高并发性能，一般都同时实现了多版本并发控制（MVCC）。\n\nMVCC是行级锁的一个变种，在大多数情况下避免了加锁操作，因此开销更低。MVCC的实现，是通过保存数据在某个时间点的快照来实现的。不同存储引擎的MVCC实现不同，典型的有乐观并发控制和悲观并发控制。\n\nInnoDB存储引擎的MVCC是通过在每行记录后面保存两个隐藏的列实现的。这两个列，一个保存行的创建时间，一个保存行的过期时间（或删除时间）。存储的不是实际时间值而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。\n\nMVCC具体实现：\n\n * SELECT：InnoDB会根据以下两个条件检查每行记录\n   * InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号）\n   * 行的删除版本要么未定义，要么大于当前事务版本号。\n * INSERT：InnoDB为新插入的每一行保存当前系统版本号作为行版本号\n * DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除标识。\n * UPDATE：InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。\n\nMVCC只在REPEATABLE READ 和READ COMMITTED 两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容。",normalizedContent:"mysql是基于客户机——服务器的dbms。服务器部分负责所有数据访问和处理的一个软件。客户机是与用户打交道的软件。\n\n使用mysql的原因：\n\n * 成本：mysql开源，可以免费使用。\n * 性能：mysql执行非常快。\n * 可信赖：某些非常重要和声望高的公司、站点使用mysql处理重要数据。\n * 简单：mysql容易安装和使用。\n\n\n# 并发控制\n\nmysql有两个层面的并发控制：服务器层与存储引擎层。\n\n通用使用锁解决并发问题。有两种类型的锁：共享锁和排他锁，也叫读锁和写锁。读锁是共享的，相互不阻塞，写锁是排他的，一个写锁会阻塞其他的读和写操作。\n\n有两种最重要的锁策略：表锁和行级锁。\n\n表锁是最基本的锁策略，并且是开销最小的策略（加锁也是需要消耗资源的）。表锁会锁定整张表。\n\n行级锁可以最大程度支持并发处理，同时也带来最大的锁开销。行级锁只在存储引擎实现。比如innodb存储引擎就实现了行急锁。\n\n\n# 事务\n\nmysql的innodb存储引擎支持事务。\n\nmysql默认自动提交事务。可以通过设置autocommit变量来启用或者禁用自动提交事务。\n\nshow variables like 'autocommit'; //查看是否是自动提交模式，on启用，off禁用\nset autocommit=1; //1启用自动提交模式，0禁用\n\n\n可以通过set transaction isolation level 命令设置隔离级别,新的隔离级别在下一个事务开始的时候生效。mysql的innodb存储引擎支持所有隔离级别。\n\nset transaction isolation level read commited\n\n\nmysql事务是由下层的存储引擎实现的，所以避免在同一个事务中，使用多种存储引擎。假如在一个事务中混合使用了事务型和非事务型表（比如innodb和myisam表），回滚时非事务型表的数据是无法回滚的。\n\n\n# 多版本并发控制\n\nmysql的大多数事务型存储引擎实现的都不是简单的行级锁。为了提高并发性能，一般都同时实现了多版本并发控制（mvcc）。\n\nmvcc是行级锁的一个变种，在大多数情况下避免了加锁操作，因此开销更低。mvcc的实现，是通过保存数据在某个时间点的快照来实现的。不同存储引擎的mvcc实现不同，典型的有乐观并发控制和悲观并发控制。\n\ninnodb存储引擎的mvcc是通过在每行记录后面保存两个隐藏的列实现的。这两个列，一个保存行的创建时间，一个保存行的过期时间（或删除时间）。存储的不是实际时间值而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。\n\nmvcc具体实现：\n\n * select：innodb会根据以下两个条件检查每行记录\n   * innodb只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号）\n   * 行的删除版本要么未定义，要么大于当前事务版本号。\n * insert：innodb为新插入的每一行保存当前系统版本号作为行版本号\n * delete：innodb为删除的每一行保存当前系统版本号作为行删除标识。\n * update：innodb为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。\n\nmvcc只在repeatable read 和read committed 两个隔离级别下工作。其他两个隔离级别都和mvcc不兼容。",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"红黑树",frontmatter:{title:"红黑树",date:"2023-10-24T03:03:59.000Z",permalink:"/pages/b5322d/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05.%E7%BA%A2%E9%BB%91%E6%A0%91.html",relativePath:"01.Java 知识体系/01.计算机基础/01.数据结构/05.红黑树.md",key:"v-618bf0bb",path:"/pages/b5322d/",headers:[{level:1,title:"二叉查找树",slug:"二叉查找树",normalizedTitle:"二叉查找树",charIndex:2},{level:1,title:"红黑树",slug:"红黑树",normalizedTitle:"红黑树",charIndex:159}],headersStr:"二叉查找树 红黑树",content:"# 二叉查找树\n\n二叉查找树（BST）具备什么特性呢？\n\n 1. 左子树上所有结点的值均小于或等于它的根结点的值。\n 2. 右子树上所有结点的值均大于或等于它的根结点的值。\n 3. 左、右子树也分别为二叉排序树。\n\n下图中这棵树，就是一颗典型的二叉查找树：\n\n\n\n二叉查找树符合二分法查找思想，利于查找数据。\n\n\n# 红黑树\n\n红黑树是一种自平衡的二叉查找树。除了符合二叉查找树的特点，还具有下列的特性：\n\n 1. 节点是红色或黑色。\n 2. 根节点是黑色。\n 3. 每个叶子节点都是黑色的空节点（NIL节点）。\n 4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)\n 5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n\n下图中这棵树，就是一颗典型的红黑树：\n\n\n\n红黑树是通过变色和旋转保证自平衡的（保证红黑树始终是红黑树）。旋转又分为左旋转和右旋转。",normalizedContent:"# 二叉查找树\n\n二叉查找树（bst）具备什么特性呢？\n\n 1. 左子树上所有结点的值均小于或等于它的根结点的值。\n 2. 右子树上所有结点的值均大于或等于它的根结点的值。\n 3. 左、右子树也分别为二叉排序树。\n\n下图中这棵树，就是一颗典型的二叉查找树：\n\n\n\n二叉查找树符合二分法查找思想，利于查找数据。\n\n\n# 红黑树\n\n红黑树是一种自平衡的二叉查找树。除了符合二叉查找树的特点，还具有下列的特性：\n\n 1. 节点是红色或黑色。\n 2. 根节点是黑色。\n 3. 每个叶子节点都是黑色的空节点（nil节点）。\n 4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)\n 5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n\n下图中这棵树，就是一颗典型的红黑树：\n\n\n\n红黑树是通过变色和旋转保证自平衡的（保证红黑树始终是红黑树）。旋转又分为左旋转和右旋转。",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"MySQL索引",frontmatter:{title:"MySQL索引",date:"2023-10-24T03:12:56.000Z",permalink:"/pages/17d468/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/02.%E6%95%B0%E6%8D%AE%E5%BA%93/02.MySQL/03.MySQL%E7%B4%A2%E5%BC%95.html",relativePath:"01.Java 知识体系/02.数据库/02.MySQL/03.MySQL索引.md",key:"v-30655360",path:"/pages/17d468/",headers:[{level:1,title:"索引实现方案",slug:"索引实现方案",normalizedTitle:"索引实现方案",charIndex:290},{level:2,title:"B+树",slug:"b-树",normalizedTitle:"b+树",charIndex:301},{level:1,title:"InnoDB逻辑存储结构",slug:"innodb逻辑存储结构",normalizedTitle:"innodb逻辑存储结构",charIndex:392},{level:2,title:"表空间",slug:"表空间",normalizedTitle:"表空间",charIndex:418},{level:2,title:"段",slug:"段",normalizedTitle:"段",charIndex:439},{level:2,title:"区",slug:"区",normalizedTitle:"区",charIndex:450},{level:2,title:"页",slug:"页",normalizedTitle:"页",charIndex:313},{level:2,title:"行",slug:"行",normalizedTitle:"行",charIndex:112},{level:2,title:"行记录格式",slug:"行记录格式",normalizedTitle:"行记录格式",charIndex:1383},{level:3,title:"Compact行记录格式",slug:"compact行记录格式",normalizedTitle:"compact行记录格式",charIndex:1583},{level:3,title:"Redundant行记录格式",slug:"redundant行记录格式",normalizedTitle:"redundant行记录格式",charIndex:2057},{level:3,title:"行溢出数据",slug:"行溢出数据",normalizedTitle:"行溢出数据",charIndex:2418},{level:3,title:"Compressed和Dynamic行记录格式",slug:"compressed和dynamic行记录格式",normalizedTitle:"compressed和dynamic行记录格式",charIndex:2750},{level:2,title:"InnoDB数据页结构",slug:"innodb数据页结构",normalizedTitle:"innodb数据页结构",charIndex:3068},{level:3,title:"File Header",slug:"file-header",normalizedTitle:"file header",charIndex:3107},{level:3,title:"Page Header",slug:"page-header",normalizedTitle:"page header",charIndex:3127},{level:3,title:"Infimum和Supremum Record",slug:"infimum和supremum-record",normalizedTitle:"infimum和supremum record",charIndex:3555},{level:3,title:"User Record和Free Space",slug:"user-record和free-space",normalizedTitle:"user record和free space",charIndex:3765},{level:3,title:"Page Directory",slug:"page-directory",normalizedTitle:"page directory",charIndex:3221},{level:3,title:"File Trailer",slug:"file-trailer",normalizedTitle:"file trailer",charIndex:3244},{level:1,title:"索引分类",slug:"索引分类",normalizedTitle:"索引分类",charIndex:4228},{level:2,title:"功能逻辑分类",slug:"功能逻辑分类",normalizedTitle:"功能逻辑分类",charIndex:4237},{level:2,title:"作用字段个数分类",slug:"作用字段个数分类",normalizedTitle:"作用字段个数分类",charIndex:4270},{level:2,title:"物理实现方式分类",slug:"物理实现方式分类",normalizedTitle:"物理实现方式分类",charIndex:4295},{level:3,title:"聚簇索引",slug:"聚簇索引",normalizedTitle:"聚簇索引",charIndex:4308},{level:3,title:"非聚簇索引",slug:"非聚簇索引",normalizedTitle:"非聚簇索引",charIndex:4632},{level:4,title:"覆盖索引",slug:"覆盖索引",normalizedTitle:"覆盖索引",charIndex:4703},{level:1,title:"索引语法",slug:"索引语法",normalizedTitle:"索引语法",charIndex:4762},{level:2,title:"创建索引",slug:"创建索引",normalizedTitle:"创建索引",charIndex:77},{level:3,title:"创建表时创建索引",slug:"创建表时创建索引",normalizedTitle:"创建表时创建索引",charIndex:4884},{level:3,title:"在已存在的表上创建索引",slug:"在已存在的表上创建索引",normalizedTitle:"在已存在的表上创建索引",charIndex:5338},{level:2,title:"查看索引",slug:"查看索引",normalizedTitle:"查看索引",charIndex:5768},{level:2,title:"删除索引",slug:"删除索引",normalizedTitle:"删除索引",charIndex:5803},{level:1,title:"索引设计原则",slug:"索引设计原则",normalizedTitle:"索引设计原则",charIndex:6021},{level:2,title:"哪些情况适合创建索引",slug:"哪些情况适合创建索引",normalizedTitle:"哪些情况适合创建索引",charIndex:6032},{level:3,title:"1.字段的数值有唯一性的限制",slug:"_1-字段的数值有唯一性的限制",normalizedTitle:"1.字段的数值有唯一性的限制",charIndex:6047},{level:3,title:"2.频繁作为WHERE查询条件的字段",slug:"_2-频繁作为where查询条件的字段",normalizedTitle:"2.频繁作为where查询条件的字段",charIndex:6162},{level:3,title:"3.经常GROUP BY 和ORDER BY 的列",slug:"_3-经常group-by-和order-by-的列",normalizedTitle:"3.经常group by 和order by 的列",charIndex:6268},{level:3,title:"4.UPDATE、DELETE的WHERE条件列",slug:"_4-update、delete的where条件列",normalizedTitle:"4.update、delete的where条件列",charIndex:6422},{level:3,title:"5.DISTINCT字段需要创建索引",slug:"_5-distinct字段需要创建索引",normalizedTitle:"5.distinct字段需要创建索引",charIndex:6616},{level:3,title:"6.多表JOIN连接时，对连接的字段和WHERE条件创建索引",slug:"_6-多表join连接时-对连接的字段和where条件创建索引",normalizedTitle:"6.多表join连接时，对连接的字段和where条件创建索引",charIndex:6672},{level:3,title:"7.使用列的类型小的创建索引",slug:"_7-使用列的类型小的创建索引",normalizedTitle:"7.使用列的类型小的创建索引",charIndex:6707},{level:3,title:"8.使用字符串前缀创建索引",slug:"_8-使用字符串前缀创建索引",normalizedTitle:"8.使用字符串前缀创建索引",charIndex:6726},{level:3,title:"9.区分度高(散列性高)的列适合作为索引",slug:"_9-区分度高-散列性高-的列适合作为索引",normalizedTitle:"9.区分度高(散列性高)的列适合作为索引",charIndex:6915},{level:3,title:"10.使用最频繁的列放到联合索引的左侧",slug:"_10-使用最频繁的列放到联合索引的左侧",normalizedTitle:"10.使用最频繁的列放到联合索引的左侧",charIndex:6940},{level:3,title:"11.在多个字段都要创建索引的情况下，联合索引优于单值索引",slug:"_11-在多个字段都要创建索引的情况下-联合索引优于单值索引",normalizedTitle:"11.在多个字段都要创建索引的情况下，联合索引优于单值索引",charIndex:7008},{level:2,title:"哪些情况不适合创建索引",slug:"哪些情况不适合创建索引",normalizedTitle:"哪些情况不适合创建索引",charIndex:7042},{level:3,title:"1.WHERE中使用不到的字段，不要设置索引",slug:"_1-where中使用不到的字段-不要设置索引",normalizedTitle:"1.where中使用不到的字段，不要设置索引",charIndex:7058},{level:3,title:"2.数据量小的表最好不要使用索引",slug:"_2-数据量小的表最好不要使用索引",normalizedTitle:"2.数据量小的表最好不要使用索引",charIndex:7085},{level:3,title:"3.有大量重复数据的列上不要建立索引",slug:"_3-有大量重复数据的列上不要建立索引",normalizedTitle:"3.有大量重复数据的列上不要建立索引",charIndex:7106},{level:3,title:"4.避免对经常更新的表创建过多的索引",slug:"_4-避免对经常更新的表创建过多的索引",normalizedTitle:"4.避免对经常更新的表创建过多的索引",charIndex:7129},{level:3,title:"5.不建议用无序的值作为索引",slug:"_5-不建议用无序的值作为索引",normalizedTitle:"5.不建议用无序的值作为索引",charIndex:7152},{level:3,title:"6.删除不再使用或者很少使用的索引",slug:"_6-删除不再使用或者很少使用的索引",normalizedTitle:"6.删除不再使用或者很少使用的索引",charIndex:7232},{level:3,title:"7.不要定义冗余或重复的索引",slug:"_7-不要定义冗余或重复的索引",normalizedTitle:"7.不要定义冗余或重复的索引",charIndex:7254}],headersStr:"索引实现方案 B+树 InnoDB逻辑存储结构 表空间 段 区 页 行 行记录格式 Compact行记录格式 Redundant行记录格式 行溢出数据 Compressed和Dynamic行记录格式 InnoDB数据页结构 File Header Page Header Infimum和Supremum Record User Record和Free Space Page Directory File Trailer 索引分类 功能逻辑分类 作用字段个数分类 物理实现方式分类 聚簇索引 非聚簇索引 覆盖索引 索引语法 创建索引 创建表时创建索引 在已存在的表上创建索引 查看索引 删除索引 索引设计原则 哪些情况适合创建索引 1.字段的数值有唯一性的限制 2.频繁作为WHERE查询条件的字段 3.经常GROUP BY 和ORDER BY 的列 4.UPDATE、DELETE的WHERE条件列 5.DISTINCT字段需要创建索引 6.多表JOIN连接时，对连接的字段和WHERE条件创建索引 7.使用列的类型小的创建索引 8.使用字符串前缀创建索引 9.区分度高(散列性高)的列适合作为索引 10.使用最频繁的列放到联合索引的左侧 11.在多个字段都要创建索引的情况下，联合索引优于单值索引 哪些情况不适合创建索引 1.WHERE中使用不到的字段，不要设置索引 2.数据量小的表最好不要使用索引 3.有大量重复数据的列上不要建立索引 4.避免对经常更新的表创建过多的索引 5.不建议用无序的值作为索引 6.删除不再使用或者很少使用的索引 7.不要定义冗余或重复的索引",content:"索引（Index）是帮助MySQL高效获取数据的数据结构。由具体的存储引擎实现。\n\n索引的优点：\n\n 1. 提高数据检索的效率，降低数据库的IO成本。这是创建索引最主要的原因。\n\n 2. 通过创建唯一索引，保证数据库表中每一行数据的唯一性。\n\n 3. 可以加速表和表之间的连接。对于有依赖关系的子表和父表联合查询时，可以提高查询速度。\n\n 4. 可以显著减少查询中分组和排序的时间。\n\n索引的缺点：\n\n 1. 创建索引和维护索引要耗费时间，并且随着数据量的增加，耗费的时间也会增加。\n 2. 索引需要占磁盘空间。\n 3. 索引在提高查询速度的同时，也会降低更新表的速度。\n\n\n# 索引实现方案\n\n\n# B+树\n\n\n\nB+树的根页面位置万年不动。InnoDB和MyISAM默认实现B+树实现索引。但是InnoDB叶子节点存储的是完整数据，而MyISAM存储的是数据记录的地址。\n\n\n# InnoDB逻辑存储结构\n\n所有数据都被逻辑地存放到表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。如下图所示\n\n\n\n\n# 表空间\n\n表空间是InnoDB存储引擎逻辑结构的最高层，所有数据都存放在表空间中。\n\n默认情况下InnoDB存储引擎有一个共享表空间ibdata1，所有数据都会存放在这个表空间内。如果启用了参数innodb_file_per_table，则每张表内的数据都可以存放在单独的表空间内，但是索引、插入缓冲Bitmap页，其他类的数据（如回滚信息，插入缓冲索引页、系统事务信息，二次写缓冲等）还是存放在原来的共享表空间。即使启用了参数innodb_file_per_table，共享表空间还是会不断地增加其大小。\n\n执行rollback时并不会取收缩表空间，但是会根据需求判断这些空间是否为可用空间，是的话这些可用空间将会被再次使用。\n\n\n# 段\n\n表空间由各个段组成的，常见的段有数据段、索引段、回滚段等。\n\n\n# 区\n\n区是由连续页组成的空间，在任何情况下每个区的大小都为1MB。\n\n为了保证区中页的连续性，InnoDB存储引擎一次从磁盘申请4～5个区。在默认情况下，InnoDB存储引擎页的大小为16KB，即一个区中一共有64个连续的页。\n\n\n# 页\n\n页是InnoDB磁盘管理的最小单位。在InnoDB存储引擎中，默认每个页的大小为16KB。\n\nInnoDB 1.2版本后可以通过参数innodb_page_size将页的大小设置为4K、8K、16K。\n\nInnoDB存储引擎常见的页类型：\n\n * 数据页（B-tree Node）\n * undo页（undo Log Page）\n * 系统页（System Page）\n * 事务数据页（Transaction system Page）\n * 插入缓冲位图页（Insert Buffer Bitmap）\n * 插入缓冲空闲列表页（Insert Buffer Free List）\n * 未压缩的二进制大对象页（Uncompressed BLOB Page）\n * 压缩的二进制大对象页（compressed BLOB Page）\n\n\n# 行\n\nInnoDB存储引擎数据按行存放，最多允许存放16KB/2-200行的记录，即7992行记录。\n\n\n# 行记录格式\n\n页中保存着表中一行行的数据。在InnoDB 1.0.x版本之前，InnoDB存储引擎提供了Compact和Redundant两种格式来存放行记录数据。在MySQL 5.1版本中，默认设置为Compact行格式。可以通过命令SHOW TABLE STATUS LIKE'table_name'来查看当前表使用的行格式，其中row_format属性表示当前所使用的行记录结构类型。\n\n\n# Compact行记录格式\n\nCompact行记录在MySQL5.0引入，设计目标是高效存储数据。存储方式如下图：\n\n\n\nCompact行记录格式首部是一个非NULL变长字段长度列表，按照列的顺序逆序放置。长度为：\n\n * 若列的长度小于255字节，用1字节表示；\n * 若大于255个字节，用2字节表示。\n\n变长字段的长度最大不可以超过2字节，这是因在MySQL数据库中VARCHAR类型的最大长度限制为65535。\n\n变长字段之后的第二个部分是NULL标志位，该位指示了该行数据中是否有NULL值，有则用1表示。该部分所占的字节应该为1字节。\n\n接下来的部分是记录头信息（record header），固定占用5字节（40位），每位的含义如下图：\n\n\n\n最后部分是实际存储每个列的数据。NULL不占该部分任何空间，即NULL除了占有NULL标志位，实际存储不占有任何空间。每行数据除了用户定义的列外，还有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节的大小。若InnoDB表没有定义主键，每行还会增加一个6字节的rowid列。\n\n\n# Redundant行记录格式\n\nRedundant是MySQL 5.0版本之前InnoDB的行记录存储方式，MySQL 5.0支持Redundant是为了兼容之前版本的页格式。Redundant行记录如图：\n\n\n\nRedundant行记录格式的首部是一个字段长度偏移列表，同样是按照列的顺序逆序放置的。若列的长度小于255字节，用1字节表示；若大于255字节，用2字节表示。\n\n第二个部分为记录头信息（record header），不同于Compact行记录格式，Redundant行记录格式的记录头占用6字节（48位），每位含义如图：\n\n\n\n最后的部分为实际存储的每个列的数据。\n\n对于VARCHAR类型的NULL值，Redundant行记录格式同样不占用任何存储空间，而CHAR类型的NULL值需要占用空间。\n\n\n# 行溢出数据\n\n行溢出指的是当页中只能存放下一条记录，InnoDB存储引擎会自动将行数据存放到溢出页。\n\nMySQL官方手册定义的VARCHAR类型支持最大65532字节，但实际能存放VARCHAR类型的最大长度为65532，因为还有别的开销。创建表时VARCHAR（N）中的N指的是字符的长度。这个长度是指所有VARCHAR列的长度总和，如果列的长度总和超出这个长度，依然无法创建。\n\n在一般情况下，InnoDB存储引擎的数据都是存放在页类型为B-tree node中。但是当发生行溢出时，数据存放在页类型为Uncompress BLOB页中。行溢出数据存放方式如下\n\n\n\n当发生行溢出时，数据页只保存前一部分字节数据，后面保存的是偏移量，指向行溢出页。\n\n\n# Compressed和Dynamic行记录格式\n\nInnoDB 1.0.x版本引入新的文件格式Barracuda文件格式。Barracuda文件格式下拥有两种新的行记录格式：Compressed和Dynamic。\n\n新的两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式，如图\n\n\n\n在数据页中只存放20个字节的指针，实际的数据都存放在Off Page中，而之前的Compact和Redundant两种格式会存放768个前缀字节。\n\nCompressed行记录格式的另一个功能就是，存储在其中的行数据会以zlib的算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度类型的数据能够进行非常有效的存储。\n\n\n# InnoDB数据页结构\n\nInnoDB数据页由7个部分组成，如图所示\n\n * File Header（文件头）\n * Page Header（页头）\n * Infimun和Supremum Records\n * User Records（用户记录，即行记录）\n * Free Space（空闲空间）\n * Page Directory（页目录）\n * File Trailer（文件结尾信息）\n\n\n\n其中File Header、Page Header、File Trailer的大小是固定的，分别为38、56、8字节。User Records、Free Space、Page Directory这些部分为实际的行记录存储空间，因此大小是动态的。\n\n\n# File Header\n\nFile Header用来记录一些头信息，共占用38字节。组成部分如图：\n\n\n\nFIL_PAGE_TYPE是InnoDB存储引擎的类型，常见的类型如图\n\n\n\n\n# Page Header\n\nPage Header用来记录数据页的状态信息，由14部分组成，占用56字节，如图所示\n\n\n\n\n\n\n# Infimum和Supremum Record\n\nInnoDB存储引擎中，每个数据页中有两个虚拟的行记录，用来限定记录的边界。Infimum记录是比该页中任何主键值都要小的值，Supremum指比任何可能大的值还要大的值。这两个值在页创建时被建立，并且在任何情况下不会被删除。在Compact行格式和Redundant行格式下，两者占用的字节数各不相同。图4-7显示了Infimum和Supremum记录。\n\n\n\n\n# User Record和Free Space\n\nUser Record是实际存储行记录的内容。Free Space是空闲空间，也是个链表数据结构。一条记录被删除后，该空间会加入到空闲链表中。\n\n\n# Page Directory\n\nPage Directory（页目录）存放了记录的相对位置（页的相对位置，而不是偏移量），有时这些记录指针被称为Slots（槽）或者目录槽（Directory Slots）\n\n\n# File Trailer\n\nFile Trailer只有一个FIL_PAGE_END_LSN部分，占用8字节。前4字节代表该页的checksum值，最后4字节和File Header中的FIL_PAGE_LSN相同。将这两个值与File Header中的FIL_PAGE_SPACE_OR_CHKSUM和FIL_PAGE_LSN值进行比较，看是否一致（checksum的比较需要通过InnoDB的checksum函数来进行比较，不是简单的等值比较），以此来保证页的完整性（not corrupted）。\n\n\n# 索引分类\n\n\n# 功能逻辑分类\n\n普通索引、唯一索引、主键索引、全文索引。\n\n\n# 作用字段个数分类\n\n单列索引和联合索引。\n\n\n# 物理实现方式分类\n\n\n# 聚簇索引\n\n特点：\n\n 1. 使用记录主键值的大小进行记录和页的排序。\n    * 页内的记录按照主键顺序排序成一个单向链表。\n    * 各个存放用户记录的页根据页中用户记录的主键大小排成一个双向链表。\n    * 存放目录项记录的页分为不同的层次，在同一层次中的页根据目录项的主键大小顺序排成一个双向链表。\n 2. B+树的叶子节点存储的是完整的用户记录。即存储了所有列的值（包括隐藏列）\n\n优点：\n\n * 数据访问快。因为索引和数据保存在同一个B+树中。\n * 对主键的排序查找和范围查找速度非常快。\n\n缺点：\n\n * 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式。\n * 更新主键的代价高，因为会导致被更新的行移动。\n\n\n# 非聚簇索引\n\n非聚簇索引在自己的B+树中只能查找到记录的主键值。要查找完整的用户记录的话，需要到聚簇索引中再查一遍，这个过程称为回表。\n\n# 覆盖索引\n\n使用非聚簇索引时，查询里用到的列包含在索引列+主键当中。此时无须进行回表，就可以将查询数据返回。\n\n\n# 索引语法\n\n\n# 创建索引\n\nMySQL支持多种方法在单个或多个列创建索引：在创建表的定义语句CREATE TABLE指定索引列，使用ALTER TABLE语句已存在表上创建索引，使用CREATE INDEX语句在已存在表上添加索引。\n\n\n# 创建表时创建索引\n\n主键默认添加主键索引。\n\n显示创建表时创建索引，语法格式如下：\n\nCREATE TABLE table_name [col_name data_type]\n[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC |\nDESC]\n\n\n * UNIQUE 、 FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引；\n * INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引；\n * index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；\n * col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；\n * length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；\n * ASC 或 DESC 指定升序或者降序的索引值存储。\n\n\n# 在已存在的表上创建索引\n\n 1. 使用ALTER TABLE语句创建索引 ALTER TABLE语句创建索引的基本语法如下：\n    \n    ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY]\n    [index_name] (col_name[length],...) [ASC | DESC]\n    \n\n 2. 使用CREATE INDEX创建索引 CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中，CREATE INDEX被映射到一个ALTER TABLE语句上，基本语法结构为：\n    \n    CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name\n    ON table_name (col_name[length],...) [ASC | DESC]\n    \n\n\n# 查看索引\n\nSHOW INDEX FROM [TABLE]\n\n\n\n# 删除索引\n\n 1. 使用ALTER TABLE删除索引 ALTER TABLE删除索引的基本语法格式如下：\n    \n    ALTER TABLE table_name DROP INDEX index_name;\n    \n\n 2. 使用DROP INDEX语句删除索引 DROP INDEX删除索引的基本语法格式如下：\n    \n    DROP INDEX index_name ON table_name;\n    \n\n\n# 索引设计原则\n\n\n# 哪些情况适合创建索引\n\n\n# 1.字段的数值有唯一性的限制\n\n> 业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba） 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。\n\n\n# 2.频繁作为WHERE查询条件的字段\n\n某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。\n\n\n# 3.经常GROUP BY 和ORDER BY 的列\n\n索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要 对分组或者排序的字段进行索引 。如果待排序的列有多个，那么可以在这些列上建立 组合索引 。\n\n\n# 4.UPDATE、DELETE的WHERE条件列\n\n对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。\n\n\n# 5.DISTINCT字段需要创建索引\n\n索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。\n\n\n# 6.多表JOIN连接时，对连接的字段和WHERE条件创建索引\n\n\n# 7.使用列的类型小的创建索引\n\n\n# 8.使用字符串前缀创建索引\n\n> 在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本 区分度决定索引长度。 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 高达 90% 以上 ，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。\n\n\n# 9.区分度高(散列性高)的列适合作为索引\n\n\n# 10.使用最频繁的列放到联合索引的左侧\n\n这样也可以较少的建立一些索引。同时，由于\"最左前缀原则\"，可以增加联合索引的使用率。\n\n\n# 11.在多个字段都要创建索引的情况下，联合索引优于单值索引\n\n\n# 哪些情况不适合创建索引\n\n\n# 1.WHERE中使用不到的字段，不要设置索引\n\n\n# 2.数据量小的表最好不要使用索引\n\n\n# 3.有大量重复数据的列上不要建立索引\n\n\n# 4.避免对经常更新的表创建过多的索引\n\n\n# 5.不建议用无序的值作为索引\n\n例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字 符串等。\n\n\n# 6.删除不再使用或者很少使用的索引\n\n\n# 7.不要定义冗余或重复的索引",normalizedContent:"索引（index）是帮助mysql高效获取数据的数据结构。由具体的存储引擎实现。\n\n索引的优点：\n\n 1. 提高数据检索的效率，降低数据库的io成本。这是创建索引最主要的原因。\n\n 2. 通过创建唯一索引，保证数据库表中每一行数据的唯一性。\n\n 3. 可以加速表和表之间的连接。对于有依赖关系的子表和父表联合查询时，可以提高查询速度。\n\n 4. 可以显著减少查询中分组和排序的时间。\n\n索引的缺点：\n\n 1. 创建索引和维护索引要耗费时间，并且随着数据量的增加，耗费的时间也会增加。\n 2. 索引需要占磁盘空间。\n 3. 索引在提高查询速度的同时，也会降低更新表的速度。\n\n\n# 索引实现方案\n\n\n# b+树\n\n\n\nb+树的根页面位置万年不动。innodb和myisam默认实现b+树实现索引。但是innodb叶子节点存储的是完整数据，而myisam存储的是数据记录的地址。\n\n\n# innodb逻辑存储结构\n\n所有数据都被逻辑地存放到表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。如下图所示\n\n\n\n\n# 表空间\n\n表空间是innodb存储引擎逻辑结构的最高层，所有数据都存放在表空间中。\n\n默认情况下innodb存储引擎有一个共享表空间ibdata1，所有数据都会存放在这个表空间内。如果启用了参数innodb_file_per_table，则每张表内的数据都可以存放在单独的表空间内，但是索引、插入缓冲bitmap页，其他类的数据（如回滚信息，插入缓冲索引页、系统事务信息，二次写缓冲等）还是存放在原来的共享表空间。即使启用了参数innodb_file_per_table，共享表空间还是会不断地增加其大小。\n\n执行rollback时并不会取收缩表空间，但是会根据需求判断这些空间是否为可用空间，是的话这些可用空间将会被再次使用。\n\n\n# 段\n\n表空间由各个段组成的，常见的段有数据段、索引段、回滚段等。\n\n\n# 区\n\n区是由连续页组成的空间，在任何情况下每个区的大小都为1mb。\n\n为了保证区中页的连续性，innodb存储引擎一次从磁盘申请4～5个区。在默认情况下，innodb存储引擎页的大小为16kb，即一个区中一共有64个连续的页。\n\n\n# 页\n\n页是innodb磁盘管理的最小单位。在innodb存储引擎中，默认每个页的大小为16kb。\n\ninnodb 1.2版本后可以通过参数innodb_page_size将页的大小设置为4k、8k、16k。\n\ninnodb存储引擎常见的页类型：\n\n * 数据页（b-tree node）\n * undo页（undo log page）\n * 系统页（system page）\n * 事务数据页（transaction system page）\n * 插入缓冲位图页（insert buffer bitmap）\n * 插入缓冲空闲列表页（insert buffer free list）\n * 未压缩的二进制大对象页（uncompressed blob page）\n * 压缩的二进制大对象页（compressed blob page）\n\n\n# 行\n\ninnodb存储引擎数据按行存放，最多允许存放16kb/2-200行的记录，即7992行记录。\n\n\n# 行记录格式\n\n页中保存着表中一行行的数据。在innodb 1.0.x版本之前，innodb存储引擎提供了compact和redundant两种格式来存放行记录数据。在mysql 5.1版本中，默认设置为compact行格式。可以通过命令show table status like'table_name'来查看当前表使用的行格式，其中row_format属性表示当前所使用的行记录结构类型。\n\n\n# compact行记录格式\n\ncompact行记录在mysql5.0引入，设计目标是高效存储数据。存储方式如下图：\n\n\n\ncompact行记录格式首部是一个非null变长字段长度列表，按照列的顺序逆序放置。长度为：\n\n * 若列的长度小于255字节，用1字节表示；\n * 若大于255个字节，用2字节表示。\n\n变长字段的长度最大不可以超过2字节，这是因在mysql数据库中varchar类型的最大长度限制为65535。\n\n变长字段之后的第二个部分是null标志位，该位指示了该行数据中是否有null值，有则用1表示。该部分所占的字节应该为1字节。\n\n接下来的部分是记录头信息（record header），固定占用5字节（40位），每位的含义如下图：\n\n\n\n最后部分是实际存储每个列的数据。null不占该部分任何空间，即null除了占有null标志位，实际存储不占有任何空间。每行数据除了用户定义的列外，还有两个隐藏列，事务id列和回滚指针列，分别为6字节和7字节的大小。若innodb表没有定义主键，每行还会增加一个6字节的rowid列。\n\n\n# redundant行记录格式\n\nredundant是mysql 5.0版本之前innodb的行记录存储方式，mysql 5.0支持redundant是为了兼容之前版本的页格式。redundant行记录如图：\n\n\n\nredundant行记录格式的首部是一个字段长度偏移列表，同样是按照列的顺序逆序放置的。若列的长度小于255字节，用1字节表示；若大于255字节，用2字节表示。\n\n第二个部分为记录头信息（record header），不同于compact行记录格式，redundant行记录格式的记录头占用6字节（48位），每位含义如图：\n\n\n\n最后的部分为实际存储的每个列的数据。\n\n对于varchar类型的null值，redundant行记录格式同样不占用任何存储空间，而char类型的null值需要占用空间。\n\n\n# 行溢出数据\n\n行溢出指的是当页中只能存放下一条记录，innodb存储引擎会自动将行数据存放到溢出页。\n\nmysql官方手册定义的varchar类型支持最大65532字节，但实际能存放varchar类型的最大长度为65532，因为还有别的开销。创建表时varchar（n）中的n指的是字符的长度。这个长度是指所有varchar列的长度总和，如果列的长度总和超出这个长度，依然无法创建。\n\n在一般情况下，innodb存储引擎的数据都是存放在页类型为b-tree node中。但是当发生行溢出时，数据存放在页类型为uncompress blob页中。行溢出数据存放方式如下\n\n\n\n当发生行溢出时，数据页只保存前一部分字节数据，后面保存的是偏移量，指向行溢出页。\n\n\n# compressed和dynamic行记录格式\n\ninnodb 1.0.x版本引入新的文件格式barracuda文件格式。barracuda文件格式下拥有两种新的行记录格式：compressed和dynamic。\n\n新的两种记录格式对于存放在blob中的数据采用了完全的行溢出的方式，如图\n\n\n\n在数据页中只存放20个字节的指针，实际的数据都存放在off page中，而之前的compact和redundant两种格式会存放768个前缀字节。\n\ncompressed行记录格式的另一个功能就是，存储在其中的行数据会以zlib的算法进行压缩，因此对于blob、text、varchar这类大长度类型的数据能够进行非常有效的存储。\n\n\n# innodb数据页结构\n\ninnodb数据页由7个部分组成，如图所示\n\n * file header（文件头）\n * page header（页头）\n * infimun和supremum records\n * user records（用户记录，即行记录）\n * free space（空闲空间）\n * page directory（页目录）\n * file trailer（文件结尾信息）\n\n\n\n其中file header、page header、file trailer的大小是固定的，分别为38、56、8字节。user records、free space、page directory这些部分为实际的行记录存储空间，因此大小是动态的。\n\n\n# file header\n\nfile header用来记录一些头信息，共占用38字节。组成部分如图：\n\n\n\nfil_page_type是innodb存储引擎的类型，常见的类型如图\n\n\n\n\n# page header\n\npage header用来记录数据页的状态信息，由14部分组成，占用56字节，如图所示\n\n\n\n\n\n\n# infimum和supremum record\n\ninnodb存储引擎中，每个数据页中有两个虚拟的行记录，用来限定记录的边界。infimum记录是比该页中任何主键值都要小的值，supremum指比任何可能大的值还要大的值。这两个值在页创建时被建立，并且在任何情况下不会被删除。在compact行格式和redundant行格式下，两者占用的字节数各不相同。图4-7显示了infimum和supremum记录。\n\n\n\n\n# user record和free space\n\nuser record是实际存储行记录的内容。free space是空闲空间，也是个链表数据结构。一条记录被删除后，该空间会加入到空闲链表中。\n\n\n# page directory\n\npage directory（页目录）存放了记录的相对位置（页的相对位置，而不是偏移量），有时这些记录指针被称为slots（槽）或者目录槽（directory slots）\n\n\n# file trailer\n\nfile trailer只有一个fil_page_end_lsn部分，占用8字节。前4字节代表该页的checksum值，最后4字节和file header中的fil_page_lsn相同。将这两个值与file header中的fil_page_space_or_chksum和fil_page_lsn值进行比较，看是否一致（checksum的比较需要通过innodb的checksum函数来进行比较，不是简单的等值比较），以此来保证页的完整性（not corrupted）。\n\n\n# 索引分类\n\n\n# 功能逻辑分类\n\n普通索引、唯一索引、主键索引、全文索引。\n\n\n# 作用字段个数分类\n\n单列索引和联合索引。\n\n\n# 物理实现方式分类\n\n\n# 聚簇索引\n\n特点：\n\n 1. 使用记录主键值的大小进行记录和页的排序。\n    * 页内的记录按照主键顺序排序成一个单向链表。\n    * 各个存放用户记录的页根据页中用户记录的主键大小排成一个双向链表。\n    * 存放目录项记录的页分为不同的层次，在同一层次中的页根据目录项的主键大小顺序排成一个双向链表。\n 2. b+树的叶子节点存储的是完整的用户记录。即存储了所有列的值（包括隐藏列）\n\n优点：\n\n * 数据访问快。因为索引和数据保存在同一个b+树中。\n * 对主键的排序查找和范围查找速度非常快。\n\n缺点：\n\n * 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式。\n * 更新主键的代价高，因为会导致被更新的行移动。\n\n\n# 非聚簇索引\n\n非聚簇索引在自己的b+树中只能查找到记录的主键值。要查找完整的用户记录的话，需要到聚簇索引中再查一遍，这个过程称为回表。\n\n# 覆盖索引\n\n使用非聚簇索引时，查询里用到的列包含在索引列+主键当中。此时无须进行回表，就可以将查询数据返回。\n\n\n# 索引语法\n\n\n# 创建索引\n\nmysql支持多种方法在单个或多个列创建索引：在创建表的定义语句create table指定索引列，使用alter table语句已存在表上创建索引，使用create index语句在已存在表上添加索引。\n\n\n# 创建表时创建索引\n\n主键默认添加主键索引。\n\n显示创建表时创建索引，语法格式如下：\n\ncreate table table_name [col_name data_type]\n[unique | fulltext | spatial] [index | key] [index_name] (col_name [length]) [asc |\ndesc]\n\n\n * unique 、 fulltext 和 spatial 为可选参数，分别表示唯一索引、全文索引和空间索引；\n * index 与 key 为同义词，两者的作用相同，用来指定创建索引；\n * index_name 指定索引的名称，为可选参数，如果不指定，那么mysql默认col_name为索引名；\n * col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；\n * length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；\n * asc 或 desc 指定升序或者降序的索引值存储。\n\n\n# 在已存在的表上创建索引\n\n 1. 使用alter table语句创建索引 alter table语句创建索引的基本语法如下：\n    \n    alter table table_name add [unique | fulltext | spatial] [index | key]\n    [index_name] (col_name[length],...) [asc | desc]\n    \n\n 2. 使用create index创建索引 create index语句可以在已经存在的表上添加索引，在mysql中，create index被映射到一个alter table语句上，基本语法结构为：\n    \n    create [unique | fulltext | spatial] index index_name\n    on table_name (col_name[length],...) [asc | desc]\n    \n\n\n# 查看索引\n\nshow index from [table]\n\n\n\n# 删除索引\n\n 1. 使用alter table删除索引 alter table删除索引的基本语法格式如下：\n    \n    alter table table_name drop index index_name;\n    \n\n 2. 使用drop index语句删除索引 drop index删除索引的基本语法格式如下：\n    \n    drop index index_name on table_name;\n    \n\n\n# 索引设计原则\n\n\n# 哪些情况适合创建索引\n\n\n# 1.字段的数值有唯一性的限制\n\n> 业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：alibaba） 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。\n\n\n# 2.频繁作为where查询条件的字段\n\n某个字段在select语句的 where 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。\n\n\n# 3.经常group by 和order by 的列\n\n索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 group by 对数据进行分组查询，或者使用 order by 对数据进行排序的时候，就需要 对分组或者排序的字段进行索引 。如果待排序的列有多个，那么可以在这些列上建立 组合索引 。\n\n\n# 4.update、delete的where条件列\n\n对数据按照某个条件进行查询后再进行 update 或 delete 的操作，如果对 where 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 where 条件列检索出来这条记录，然后再对它进行更新或删除。如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。\n\n\n# 5.distinct字段需要创建索引\n\n索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。\n\n\n# 6.多表join连接时，对连接的字段和where条件创建索引\n\n\n# 7.使用列的类型小的创建索引\n\n\n# 8.使用字符串前缀创建索引\n\n> 在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本 区分度决定索引长度。 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 高达 90% 以上 ，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。\n\n\n# 9.区分度高(散列性高)的列适合作为索引\n\n\n# 10.使用最频繁的列放到联合索引的左侧\n\n这样也可以较少的建立一些索引。同时，由于\"最左前缀原则\"，可以增加联合索引的使用率。\n\n\n# 11.在多个字段都要创建索引的情况下，联合索引优于单值索引\n\n\n# 哪些情况不适合创建索引\n\n\n# 1.where中使用不到的字段，不要设置索引\n\n\n# 2.数据量小的表最好不要使用索引\n\n\n# 3.有大量重复数据的列上不要建立索引\n\n\n# 4.避免对经常更新的表创建过多的索引\n\n\n# 5.不建议用无序的值作为索引\n\n例如身份证、uuid(在索引比较时需要转为ascii，并且插入时可能造成页分裂)、md5、hash、无序长字 符串等。\n\n\n# 6.删除不再使用或者很少使用的索引\n\n\n# 7.不要定义冗余或重复的索引",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"MySQL体系结构",frontmatter:{title:"MySQL体系结构",date:"2023-10-24T03:12:56.000Z",permalink:"/pages/198df0/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/02.%E6%95%B0%E6%8D%AE%E5%BA%93/02.MySQL/02.MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.html",relativePath:"01.Java 知识体系/02.数据库/02.MySQL/02.MySQL体系结构.md",key:"v-f91ab4be",path:"/pages/198df0/",headers:[{level:1,title:"MySQL逻辑架构",slug:"mysql逻辑架构",normalizedTitle:"mysql逻辑架构",charIndex:2},{level:1,title:"SQL执行流程",slug:"sql执行流程",normalizedTitle:"sql执行流程",charIndex:1058},{level:1,title:"MySQL存储引擎",slug:"mysql存储引擎",normalizedTitle:"mysql存储引擎",charIndex:1627},{level:2,title:"InnoDB存储引擎",slug:"innodb存储引擎",normalizedTitle:"innodb存储引擎",charIndex:1641},{level:2,title:"MyISAM存储引擎",slug:"myisam存储引擎",normalizedTitle:"myisam存储引擎",charIndex:1792}],headersStr:"MySQL逻辑架构 SQL执行流程 MySQL存储引擎 InnoDB存储引擎 MyISAM存储引擎",content:"# MySQL逻辑架构\n\n图为MySQL5.7版本典型的逻辑架构图\n\n\n\nMySQL逻辑架构分为三层，分别是连接层、服务层、存储引擎层。\n\n第一层连接层是进行连接管理的，包括连接处理、身份认证、权限获取、安全等功能。客户端通过TCP连接MySQL服务器，MySQL服务器对传输过来的账号密码进行身份认证和权限获取。\n\n * 用户名和密码不对，会收到一个Access denied for user错误，客户端程序结束执行\n * 用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限\n\nMySQL会从线程池分配一个线程专门与这个客户端进行交互，每个连接都从线程池获取，省去创建和销毁线程的开销。\n\n第二层是服务层，包括SQL接口、解析器、优化器、查询缓存。\n\nSQL接口（SQL Interface）：接收用户的SQL命令，并且返回用户查询的结果。支持DML、DDL、存储过程、视图、触发器、自定义函数等多种SQL语言接口。\n\n解析器（Parser）：对SQL命令进行验证和解析，并为其创建语法树，根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。后续SQL语句的传递和处理都是基于这个结构的。\n\n优化器（Optimizer）：SQL语句解析后，查询之前用查询优化器确定SQL语句的执行路径，生成一个执行计划。这个执行计划表明应该使用哪些索引进行查询，表之间的连接顺序如何，最后会安装执行计划的步骤调用存储引擎提供的方法来真正执行查询，并将查询结果返回给用户。使用选取-投影-连接策略进行查询。\n\nSELECT id,name FROM student WHERE gender = '女';\n\n\n这个SELECT查询先根据WHERE语句进行选取，而不是将表全部查询出来以后再进行gender过滤。这个SELECT查询先根据id和name进行属性投影，而不是将属性全部取出以后再进行过 滤，将这两个查询条件连接起来生成最终查询结果。\n\n查询缓存（Caches&Buffers）：查询缓存可以用来缓存一条SELECT语句的执行结果，如果能找到对应的执行结果，就直接将结果返回，不必进行查询解析、优化、执行等过程。查询缓存在不同客户端之间共享。查询缓存在MySQL8.0删除。\n\n第三层是存储引擎层，负责数据的存储和提取。服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同。\n\nMySQL 8.25默认的支持的存储引擎如下：\n\n\n\n\n# SQL执行流程\n\n\n\nMySQl中的查询流程：\n\n 1. 查询缓存：服务器如果在查询缓存中发现这条SQL语句，就会直接将结果返回给客户端；如果没有发现，就进入解析器阶段。\n\n 2. 解析器：对SQL语句进行语法分析、语义检查。分析器先做“词法分析”，输入的多个字符串和空格组成的一条SQL语句，MySQL需要识别里面字符串分别是什么，代表什么。比如“select”关键字识别成查询语句，字符串“T”识别成表名。再做语法分析。根本词法分析的结果，语法分析器会根据语法规则，判断SQL语句是否满足MySQL语法。如果SQL语句正确的话就会生成一个语法树。比如：\n    \n    select username ismale from userinfo where age>20 and level>5 and 1=1\n    \n    \n    会生成一个这样的语法树\n\n 3. 优化器：确定SQL语句的执行计划。比如是根据全表检索还是根据索引检索等。在查询优化器中，可以分为逻辑查询优化阶段和物理查询优化阶段。确定执行计划后进入执行器阶段\n\n 4. 执行器：在执行之前判断该用户是否具备权限。如果没有，就会返回权限错误。如果具备权限，就执行SQL查询并返回结果。在MySQL8.0以下的版本，如果设置查询缓存，会将结果进行缓存。\n\n\n# MySQL存储引擎\n\n\n# InnoDB存储引擎\n\nMYSQL5.5版本默认的存储引擎。InnoDB采用MVCC来支持高并发，并且实现四个标准的隔离级别。默认隔离级别是REPEATABLE READ（可重复读），并且通过间隙锁策略防止幻读。\n\nInnoDB表是基于聚簇索引建立的。\n\nInnoDB支持事务、行级锁、外键。\n\n\n# MyISAM存储引擎\n\nMyISAM不支持事务、行级锁、外键。",normalizedContent:"# mysql逻辑架构\n\n图为mysql5.7版本典型的逻辑架构图\n\n\n\nmysql逻辑架构分为三层，分别是连接层、服务层、存储引擎层。\n\n第一层连接层是进行连接管理的，包括连接处理、身份认证、权限获取、安全等功能。客户端通过tcp连接mysql服务器，mysql服务器对传输过来的账号密码进行身份认证和权限获取。\n\n * 用户名和密码不对，会收到一个access denied for user错误，客户端程序结束执行\n * 用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限\n\nmysql会从线程池分配一个线程专门与这个客户端进行交互，每个连接都从线程池获取，省去创建和销毁线程的开销。\n\n第二层是服务层，包括sql接口、解析器、优化器、查询缓存。\n\nsql接口（sql interface）：接收用户的sql命令，并且返回用户查询的结果。支持dml、ddl、存储过程、视图、触发器、自定义函数等多种sql语言接口。\n\n解析器（parser）：对sql命令进行验证和解析，并为其创建语法树，根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。后续sql语句的传递和处理都是基于这个结构的。\n\n优化器（optimizer）：sql语句解析后，查询之前用查询优化器确定sql语句的执行路径，生成一个执行计划。这个执行计划表明应该使用哪些索引进行查询，表之间的连接顺序如何，最后会安装执行计划的步骤调用存储引擎提供的方法来真正执行查询，并将查询结果返回给用户。使用选取-投影-连接策略进行查询。\n\nselect id,name from student where gender = '女';\n\n\n这个select查询先根据where语句进行选取，而不是将表全部查询出来以后再进行gender过滤。这个select查询先根据id和name进行属性投影，而不是将属性全部取出以后再进行过 滤，将这两个查询条件连接起来生成最终查询结果。\n\n查询缓存（caches&buffers）：查询缓存可以用来缓存一条select语句的执行结果，如果能找到对应的执行结果，就直接将结果返回，不必进行查询解析、优化、执行等过程。查询缓存在不同客户端之间共享。查询缓存在mysql8.0删除。\n\n第三层是存储引擎层，负责数据的存储和提取。服务器通过api与存储引擎进行通信。不同的存储引擎具有的功能不同。\n\nmysql 8.25默认的支持的存储引擎如下：\n\n\n\n\n# sql执行流程\n\n\n\nmysql中的查询流程：\n\n 1. 查询缓存：服务器如果在查询缓存中发现这条sql语句，就会直接将结果返回给客户端；如果没有发现，就进入解析器阶段。\n\n 2. 解析器：对sql语句进行语法分析、语义检查。分析器先做“词法分析”，输入的多个字符串和空格组成的一条sql语句，mysql需要识别里面字符串分别是什么，代表什么。比如“select”关键字识别成查询语句，字符串“t”识别成表名。再做语法分析。根本词法分析的结果，语法分析器会根据语法规则，判断sql语句是否满足mysql语法。如果sql语句正确的话就会生成一个语法树。比如：\n    \n    select username ismale from userinfo where age>20 and level>5 and 1=1\n    \n    \n    会生成一个这样的语法树\n\n 3. 优化器：确定sql语句的执行计划。比如是根据全表检索还是根据索引检索等。在查询优化器中，可以分为逻辑查询优化阶段和物理查询优化阶段。确定执行计划后进入执行器阶段\n\n 4. 执行器：在执行之前判断该用户是否具备权限。如果没有，就会返回权限错误。如果具备权限，就执行sql查询并返回结果。在mysql8.0以下的版本，如果设置查询缓存，会将结果进行缓存。\n\n\n# mysql存储引擎\n\n\n# innodb存储引擎\n\nmysql5.5版本默认的存储引擎。innodb采用mvcc来支持高并发，并且实现四个标准的隔离级别。默认隔离级别是repeatable read（可重复读），并且通过间隙锁策略防止幻读。\n\ninnodb表是基于聚簇索引建立的。\n\ninnodb支持事务、行级锁、外键。\n\n\n# myisam存储引擎\n\nmyisam不支持事务、行级锁、外键。",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"MySQL调优",frontmatter:{title:"MySQL调优",date:"2023-10-24T03:12:56.000Z",permalink:"/pages/ec5067/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/02.%E6%95%B0%E6%8D%AE%E5%BA%93/02.MySQL/04.MySQL%E8%B0%83%E4%BC%98.html",relativePath:"01.Java 知识体系/02.数据库/02.MySQL/04.MySQL调优.md",key:"v-f52dc942",path:"/pages/ec5067/",headers:[{level:1,title:"性能分析工具",slug:"性能分析工具",normalizedTitle:"性能分析工具",charIndex:2},{level:2,title:"查看系统性能参数",slug:"查看系统性能参数",normalizedTitle:"查看系统性能参数",charIndex:13},{level:2,title:"统计SQL的查询成本",slug:"统计sql的查询成本",normalizedTitle:"统计sql的查询成本",charIndex:490},{level:2,title:"慢查询日志",slug:"慢查询日志",normalizedTitle:"慢查询日志",charIndex:617},{level:3,title:"开启慢查询日志",slug:"开启慢查询日志",normalizedTitle:"开启慢查询日志",charIndex:627},{level:3,title:"查看慢查询数目",slug:"查看慢查询数目",normalizedTitle:"查看慢查询数目",charIndex:884},{level:3,title:"慢查询日志分析工具——mysqldumpslow",slug:"慢查询日志分析工具-mysqldumpslow",normalizedTitle:"慢查询日志分析工具——mysqldumpslow",charIndex:958},{level:3,title:"关闭慢查询日志",slug:"关闭慢查询日志",normalizedTitle:"关闭慢查询日志",charIndex:1643},{level:2,title:"查看SQL执行成本",slug:"查看sql执行成本",normalizedTitle:"查看sql执行成本",charIndex:1803},{level:2,title:"EXPLAIN 查看执行计划",slug:"explain-查看执行计划",normalizedTitle:"explain 查看执行计划",charIndex:1894},{level:3,title:"基本语法",slug:"基本语法",normalizedTitle:"基本语法",charIndex:2404},{level:3,title:"EXPLAIN各个列的作用",slug:"explain各个列的作用",normalizedTitle:"explain各个列的作用",charIndex:2984},{level:4,title:"id",slug:"id",normalizedTitle:"id",charIndex:2599},{level:4,title:"select_type",slug:"select-type",normalizedTitle:"select_type",charIndex:2646},{level:4,title:"table",slug:"table",normalizedTitle:"table",charIndex:2682},{level:4,title:"partitions",slug:"partitions",normalizedTitle:"partitions",charIndex:2173},{level:4,title:"type",slug:"type",normalizedTitle:"type",charIndex:2653},{level:4,title:"possible_keys和key",slug:"possible-keys和key",normalizedTitle:"possible_keys和key",charIndex:4447},{level:4,title:"key_len",slug:"key-len",normalizedTitle:"key_len",charIndex:2800},{level:4,title:"ref",slug:"ref",normalizedTitle:"ref",charIndex:1957},{level:4,title:"rows",slug:"rows",normalizedTitle:"rows",charIndex:228},{level:4,title:"filtered",slug:"filtered",normalizedTitle:"filtered",charIndex:2215},{level:4,title:"Extra",slug:"extra",normalizedTitle:"extra",charIndex:2956},{level:2,title:"MySQL监控分析视图-sys schemea",slug:"mysql监控分析视图-sys-schemea",normalizedTitle:"mysql监控分析视图-sys schemea",charIndex:6220},{level:3,title:"Sys schemea视图摘要",slug:"sys-schemea视图摘要",normalizedTitle:"sys schemea视图摘要",charIndex:6248},{level:3,title:"Sys schemea视图使用场景",slug:"sys-schemea视图使用场景",normalizedTitle:"sys schemea视图使用场景",charIndex:6701},{level:1,title:"SQL 优化",slug:"sql-优化",normalizedTitle:"sql 优化",charIndex:8010},{level:2,title:"索引优化",slug:"索引优化",normalizedTitle:"索引优化",charIndex:8084},{level:3,title:"索引失效的情况",slug:"索引失效的情况",normalizedTitle:"索引失效的情况",charIndex:8093},{level:2,title:"关联查询优化",slug:"关联查询优化",normalizedTitle:"关联查询优化",charIndex:8491},{level:3,title:"JOIN底层原理",slug:"join底层原理",normalizedTitle:"join底层原理",charIndex:8616},{level:4,title:"简单嵌套循环连接",slug:"简单嵌套循环连接",normalizedTitle:"简单嵌套循环连接",charIndex:8628},{level:4,title:"索引嵌套循环连接",slug:"索引嵌套循环连接",normalizedTitle:"索引嵌套循环连接",charIndex:8675},{level:4,title:"块嵌套循环连接",slug:"块嵌套循环连接",normalizedTitle:"块嵌套循环连接",charIndex:8715},{level:2,title:"子查询优化",slug:"子查询优化",normalizedTitle:"子查询优化",charIndex:8755},{level:2,title:"排序优化",slug:"排序优化",normalizedTitle:"排序优化",charIndex:8808},{level:2,title:"GROUP BY优化",slug:"group-by优化",normalizedTitle:"group by优化",charIndex:8956},{level:2,title:"函数优化",slug:"函数优化",normalizedTitle:"函数优化",charIndex:9002}],headersStr:"性能分析工具 查看系统性能参数 统计SQL的查询成本 慢查询日志 开启慢查询日志 查看慢查询数目 慢查询日志分析工具——mysqldumpslow 关闭慢查询日志 查看SQL执行成本 EXPLAIN 查看执行计划 基本语法 EXPLAIN各个列的作用 id select_type table partitions type possible_keys和key key_len ref rows filtered Extra MySQL监控分析视图-sys schemea Sys schemea视图摘要 Sys schemea视图使用场景 SQL 优化 索引优化 索引失效的情况 关联查询优化 JOIN底层原理 简单嵌套循环连接 索引嵌套循环连接 块嵌套循环连接 子查询优化 排序优化 GROUP BY优化 函数优化",content:"# 性能分析工具\n\n\n# 查看系统性能参数\n\n在MySQL中，可以使用 SHOW STATUS 语句查询一些MySQL数据库服务器的性能参数、执行频率。\n\n语法如下：\n\nSHOW [GLOBAL|SESSION] STATUS LIKE '参数';\n\n\n常用的性能参数如下：\n\n * Connections：连接MySQL服务器的次数。\n * Uptime：MySQL服务器的上线时间。\n * Slow_queries：慢查询的次数。\n * Innodb_rows_read：Select查询返回的行数\n * Innodb_rows_inserted：执行INSERT操作插入的行数\n * Innodb_rows_updated：执行UPDATE操作更新的行数\n * Innodb_rows_deleted：执行DELETE操作删除的行数\n * Com_select：查询操作的次数。\n * Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。\n * Com_update：更新操作的次数。\n * Com_delete：删除操作的次数。\n\n\n# 统计SQL的查询成本\n\n执行一个查询SQL后，使用以下语句查看查询优化器的成本，Value列的值就是需要检索数据页的数量。\n\nSHOW STATUS LIKE 'last_query_cost';\n\n\n当有多个查询SQL可选时，可用来比较开销。\n\n\n# 慢查询日志\n\n\n# 开启慢查询日志\n\n 1. 开启slow_query_log\n\n使用set global slow_query_log='ON';开启慢查询日志。\n\n然后查看慢查询日志是否开启以及慢查询日志文件的位置\n\n\n\n 2. 修改long_query_time阈值\n\nlong_query_time默认值为10s。\n\n修改long_query_time的值为1s\n\n#session和global都得设置\nset global long_query_time = 1;\nset long_query_time=1;\n\n\n\n# 查看慢查询数目\n\n查询当前系统中有多少条慢查询记录\n\nSHOW GLOBAL STATUS LIKE '%Slow_queries%';\n\n\n\n# 慢查询日志分析工具——mysqldumpslow\n\nmysqldumpslow 命令的具体参数如下：\n\n * -a: 不将数字抽象成N，字符串抽象成S\n\n * -s: 是表示按照何种方式排序：\n   \n   * c: 访问次数\n   \n   * l: 锁定时间\n   \n   * r: 返回记录\n   \n   * t: 查询时间\n   \n   * al:平均锁定时间\n   \n   * ar:平均返回记录数\n   \n   * at:平均查询时间 （默认方式）\n   \n   * ac:平均查询次数\n\n * -t: 即为返回前面多少条的数据；\n\n * -g: 后边搭配一个正则匹配模式，大小写不敏感的；\n\n常用：\n\n#得到返回记录集最多的10个SQL\nmysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more\n#得到访问次数最多的10个SQL\nmysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log | more\n#得到按照时间排序的前10条里面含有左连接的查询语句\nmysqldumpslow -s t -t 10 -g \"left join\" /var/lib/mysql/atguigu-slow.log | more\n#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况\nmysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more\n\n\n\n# 关闭慢查询日志\n\n方式1：永久性方式\n\n修改mysql配置文件slow_query_log=OFF或者将slow_query_log注释或删除掉，然后重启MySQL服务。\n\n方式2：临时性方式\n\n使用\n\nSET GLOBAL slow_query_log=off;\n\n\n关闭慢查询日志，然后重启MySQL服务。\n\n\n# 查看SQL执行成本\n\n通过 set profiling = 'ON'来开启show profile。\n\n使用show profiles会列出当前会话都有哪些查询和对应开销。\n\n\n# EXPLAIN 查看执行计划\n\n官网介绍：\n\n * MySQL 5.7 ：https://dev.mysql.com/doc/refman/5.7/en/explain-output.html\n * MySQL 8.0：https://dev.mysql.com/doc/refman/8.0/en/explain-output.html\n\n版本变化：\n\n * MySQL 5.6.3以前只能 EXPLAIN SELECT ；MYSQL 5.6.3以后就可以 EXPLAIN SELECT，UPDATE，DELETE。\n * 在5.7以前的版本中，想要显示 partitions 需要使用 explain partitions 命令；想要显示filtered 需要使用 explain extended 命令。在5.7版本后，默认explain直接显示partitions和filtered中的信息。\n\n注意：\n\n * EXPLAIN不考虑各种Cache\n * EXPLAIN不能显示MySQL在执行查询时所作的优化工作\n * EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况\n\n\n# 基本语法\n\n可以使用EXPLAIN或DESCRIBE语法查看执行计划\n\nEXPLAIN SELECT select_options\n或者\nDESCRIBE SELECT select_options\n\n\n如果想查看某个查询SQL的执行计划，在具体的查询SQL前边加上EXPLAIN就可以，比如EXPLAIN SELECT 1。输出各个列的作用如下：\n\n列名              描述\nid              在一个大的查询语句中个SELECT关键字都对应一个唯一的id\nselect_type     SELECT关键字对应的那个查询的类型\ntable           表名\npartitions      匹配的分区信息\ntype            针对单表的访问方法\npossible_keys   可能用到的索引\nkey             实际上使用的索引\nkey_len         实际使用到的索引长度（联合索引时可以看用了几个索引列）\nref             当使用索引列等值查询时，与索引列进行等值匹配的对象信息\nrows            预估的需要读取的记录条数\nfiltered        某个表经过搜索条件过滤后剩余记录条数的百分比\nExtra           一些额外的信息\n\n\n# EXPLAIN各个列的作用\n\n# id\n\nSQL执行的顺序标识，每个select关键字对应一个id。\n\n * id如果相同，可以认为是一组，从上往下顺序执行\n * 在所有组中，id值越大，优先级越高，越先执行\n * 关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好\n\n# select_type\n\n每个select查询的类型\n\n名称                     描述\nSIMPLE                 简单查询（不使用 UNION 或子查询）\nPRIMARY                查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY\nUNION                  UNION中的第二个或后面的SELECT语句\nUNION RESULT           UNION的结果\nSUBQUERY               子查询中的第一个SELECT\nDEPENDENT SUBQUERY     子查询中的第一个SELECT，取决于外面的查询\nDEPENDENT UNION        UNION中的第二个或后面的SELECT语句，取决于外面的查询\nDERIVED                派生表的SELECT, FROM子句的子查询\nMATERIALIZED           Materialized subquery\nUNCACHEABLE SUBQUERY   A subquery for which the result cannot be cached and must be\n                       re-evaluated for\n                       each row of the outer query\nUNCACHEABLE UNION      The second or later select in a UNION that belongs to an\n                       uncacheable subquery\n                       (see UNCACHEABLE SUBQUERY)\n\n# table\n\n查询语句无论多复杂，最终还是对每个表进行单表访问。所 以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）\n\n# partitions\n\n匹配的分区信息\n\n# type\n\n针对单表的访问方法，即MySQL决定如何查找表中的行。\n\n完整的访问方法如下：system、const、eq_ref、ref、fulltext、ref_or_null、index_merge、unique_subquery、index_subquery、range、index、ALL。\n\n结果值从最好到最坏依次是： system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL\n\n> SQL性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是consts级别。（阿里巴巴开发手册要求）\n\n# possible_keys和key\n\npossible_keys：可能使用哪些索引来查找\n\nkey：实际使用哪些索引查找\n\n# key_len\n\n这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列（主要用于联合索引）。\n\n举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。\n\nmysql> explain select * from film_actor where film_id = 2;\n+----+-------------+------------+------+-------------------+-------------------+---------+-------+------+-------------+\n| id | select_type | table      | type | possible_keys     | key               | key_len | ref   | rows | Extra       |\n+----+-------------+------------+------+-------------------+-------------------+---------+-------+------+-------------+\n|  1 | SIMPLE      | film_actor | ref  | idx_film_actor_id | idx_film_actor_id | 4       | const |    1 | Using index |\n+----+-------------+------------+------+-------------------+-------------------+---------+-------+------+-------------+\n\n\nkey_len计算规则如下：\n\n * 字符串\n   * char(n)：n字节长度\n   * varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2\n * 数值类型\n   * tinyint：1字节\n   * smallint：2字节\n   * int：4字节\n   * bigint：8字节\n * 时间类型\n   * date：3字节\n   * timestamp：4字节\n   * datetime：8字节\n * 如果字段允许为 NULL，需要1字节记录是否为 NULL\n\n# ref\n\n这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），func，NULL，字段名（例：film.id）\n\n# rows\n\n这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。\n\n# filtered\n\n某个表经过搜索条件过滤后剩余记录条数的百分比。这个值越大越好。\n\n# Extra\n\n这一列展示的是额外信息。常见的重要值如下：\n\n * distinct： 一旦mysql找到了与行相联合匹配的行，就不再搜索了\n * Using index：这发生在对表的请求列都是同一索引的部分的时候，返回的列数据只使用了索引中的信息，而没有再去访问表中的行记录。是性能高的表现。\n * Using where：mysql服务器将在存储引擎检索行后再进行过滤。就是先读取整行数据，再按 where 条件进行检查，符合就留下，不符合就丢弃。\n * Using temporary：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。\n * Using filesort：mysql 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。这种情况下一般也是要考虑使用索引来优化的。\n\n\n# MySQL监控分析视图-sys schemea\n\n\n# Sys schemea视图摘要\n\n 1.  主机相关：以host_summary开头，主要汇总了IO延迟的信息。\n 2.  Innodb相关：以innodb开头，汇总了innodb buffer信息和事务等待innodb锁的信息。\n 3.  I/o相关：以io开头，汇总了等待I/O、I/O使用量情况。\n 4.  内存使用情况：以memory开头，从主机、线程、事件等角度展示内存的使用情况\n 5.  连接与会话信息：processlist和session相关视图，总结了会话相关信息。\n 6.  表相关：以schema_table开头的视图，展示了表的统计信息。\n 7.  索引信息：统计了索引的使用情况，包含冗余索引和未使用的索引情况。\n 8.  语句相关：以statement开头，包含执行全表扫描、使用临时表、排序等的语句信息。\n 9.  用户相关：以user开头的视图，统计了用户使用的文件I/O、执行语句统计信息。\n 10. 等待事件相关信息：以wait开头，展示等待事件的延迟情况。\n\n\n# Sys schemea视图使用场景\n\n索引情况：\n\n#1. 查询冗余索引\nselect * from sys.schema_redundant_indexes;\n#2. 查询未使用过的索引\nselect * from sys.schema_unused_indexes;\n#3. 查询索引的使用情况\nselect index_name,rows_selected,rows_inserted,rows_updated,rows_deleted\nfrom sys.schema_index_statistics where table_schema='dbname' ;\n\n\n表相关：\n\n# 1. 查询表的访问量\nselect table_schema,table_name,sum(io_read_requests+io_write_requests) as io from\nsys.schema_table_statistics group by table_schema,table_name order by io desc;\n# 2. 查询占用bufferpool较多的表\nselect object_schema,object_name,allocated,data\nfrom sys.innodb_buffer_stats_by_table order by allocated limit 10;\n# 3. 查看表的全表扫描情况\nselect * from sys.statements_with_full_table_scans where db='dbname';\n\n\n语句相关：\n\n#1. 监控SQL执行的频率\nselect db,exec_count,query from sys.statement_analysis\norder by exec_count desc;\n#2. 监控使用了排序的SQL\nselect db,exec_count,first_seen,last_seen,query\nfrom sys.statements_with_sorting limit 1;\n#3. 监控使用了临时表或者磁盘临时表的SQL\nselect db,exec_count,tmp_tables,tmp_disk_tables,query\nfrom sys.statement_analysis where tmp_tables>0 or tmp_disk_tables >0\norder by (tmp_tables+tmp_disk_tables) desc;\n\n\nIO相关：\n\n#1. 查看消耗磁盘IO的文件\nselect file,avg_read,avg_write,avg_read+avg_write as avg_io\nfrom sys.io_global_by_file_by_bytes order by avg_read limit 10;\n\n\nInnoDB相关：\n\n#1. 行锁阻塞情况\nselect * from sys.innodb_lock_waits;\n\n\n\n# SQL 优化\n\nSQL查询优化可以分成物理查询优化和逻辑查询优化。\n\n * 物理查询优化：索引、表连接\n * 逻辑查询优化：SQL等价变换\n\n\n# 索引优化\n\n\n# 索引失效的情况\n\n 1.  优化全值匹配：优先使用联合索引而不是单列索引。\n\n 2.  最佳左前缀法则：对于多列索引，过滤条件要使用索引必须按照索引建立的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。如果查询条件没有使用第一个字段，联合索引不会被使用。\n\n 3.  主键插入顺序：最好让主键依次递增，避免页分裂和记录移位造成的性能损耗。\n\n 4.  计算、函数导致索引失效\n\n 5.  类型转换（自动或手动）导致索引失效\n\n 6.  范围条件右边的列索引失效\n\n 7.  不等于（!=或者<>）索引失效\n\n 8.  is null可以使用索引,is not null无法使用索引\n\n 9.  like以通配符%开头索引失效\n\n 10. OR前后存在非索引的列，索引失效\n\n 11. 数据库和表的字符集统一使用utf8mb4：不同字符集进行比较前需要进行转换造成索引失效。\n\n\n# 关联查询优化\n\n内连接时，查询优化器可以决定哪张表为驱动表，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表。\n\n对于内连接来说，在两个表的连接条件都存在索引的情况下，小表驱动大表（小的结果集驱动大的结果集）。\n\n\n# JOIN底层原理\n\n# 简单嵌套循环连接\n\n都无索引。性能主要受被驱动表的全表扫描次数，也就是驱动表匹配数据。\n\n# 索引嵌套循环连接\n\n表中添加索引，被驱动表为加了索引的表，无须全表扫描。\n\n# 块嵌套循环连接\n\n驱动表一块一块获取多条数据，减少非驱动表的全表扫描。\n\n\n# 子查询优化\n\n子查询会建立临时表，影响查询性能。在MySQL中可以使用JOIN查询来替代子查询。\n\n\n# 排序优化\n\nMySQL支持两种排序方式，分别FileSort和Index排序\n\n * Index排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高\n * FileSort排序一般在内存中进行排序，效率较低。\n\n在Order by 子句中使用索引，避免使用FileSort排序。\n\n\n# GROUP BY优化\n\ngroup by 先排序再分组，遵照索引建的最佳左前缀法则\n\n\n# 函数优化\n\nmax/min函数：使用order by 列名 limit 1进行优化",normalizedContent:"# 性能分析工具\n\n\n# 查看系统性能参数\n\n在mysql中，可以使用 show status 语句查询一些mysql数据库服务器的性能参数、执行频率。\n\n语法如下：\n\nshow [global|session] status like '参数';\n\n\n常用的性能参数如下：\n\n * connections：连接mysql服务器的次数。\n * uptime：mysql服务器的上线时间。\n * slow_queries：慢查询的次数。\n * innodb_rows_read：select查询返回的行数\n * innodb_rows_inserted：执行insert操作插入的行数\n * innodb_rows_updated：执行update操作更新的行数\n * innodb_rows_deleted：执行delete操作删除的行数\n * com_select：查询操作的次数。\n * com_insert：插入操作的次数。对于批量插入的 insert 操作，只累加一次。\n * com_update：更新操作的次数。\n * com_delete：删除操作的次数。\n\n\n# 统计sql的查询成本\n\n执行一个查询sql后，使用以下语句查看查询优化器的成本，value列的值就是需要检索数据页的数量。\n\nshow status like 'last_query_cost';\n\n\n当有多个查询sql可选时，可用来比较开销。\n\n\n# 慢查询日志\n\n\n# 开启慢查询日志\n\n 1. 开启slow_query_log\n\n使用set global slow_query_log='on';开启慢查询日志。\n\n然后查看慢查询日志是否开启以及慢查询日志文件的位置\n\n\n\n 2. 修改long_query_time阈值\n\nlong_query_time默认值为10s。\n\n修改long_query_time的值为1s\n\n#session和global都得设置\nset global long_query_time = 1;\nset long_query_time=1;\n\n\n\n# 查看慢查询数目\n\n查询当前系统中有多少条慢查询记录\n\nshow global status like '%slow_queries%';\n\n\n\n# 慢查询日志分析工具——mysqldumpslow\n\nmysqldumpslow 命令的具体参数如下：\n\n * -a: 不将数字抽象成n，字符串抽象成s\n\n * -s: 是表示按照何种方式排序：\n   \n   * c: 访问次数\n   \n   * l: 锁定时间\n   \n   * r: 返回记录\n   \n   * t: 查询时间\n   \n   * al:平均锁定时间\n   \n   * ar:平均返回记录数\n   \n   * at:平均查询时间 （默认方式）\n   \n   * ac:平均查询次数\n\n * -t: 即为返回前面多少条的数据；\n\n * -g: 后边搭配一个正则匹配模式，大小写不敏感的；\n\n常用：\n\n#得到返回记录集最多的10个sql\nmysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more\n#得到访问次数最多的10个sql\nmysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log | more\n#得到按照时间排序的前10条里面含有左连接的查询语句\nmysqldumpslow -s t -t 10 -g \"left join\" /var/lib/mysql/atguigu-slow.log | more\n#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况\nmysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more\n\n\n\n# 关闭慢查询日志\n\n方式1：永久性方式\n\n修改mysql配置文件slow_query_log=off或者将slow_query_log注释或删除掉，然后重启mysql服务。\n\n方式2：临时性方式\n\n使用\n\nset global slow_query_log=off;\n\n\n关闭慢查询日志，然后重启mysql服务。\n\n\n# 查看sql执行成本\n\n通过 set profiling = 'on'来开启show profile。\n\n使用show profiles会列出当前会话都有哪些查询和对应开销。\n\n\n# explain 查看执行计划\n\n官网介绍：\n\n * mysql 5.7 ：https://dev.mysql.com/doc/refman/5.7/en/explain-output.html\n * mysql 8.0：https://dev.mysql.com/doc/refman/8.0/en/explain-output.html\n\n版本变化：\n\n * mysql 5.6.3以前只能 explain select ；mysql 5.6.3以后就可以 explain select，update，delete。\n * 在5.7以前的版本中，想要显示 partitions 需要使用 explain partitions 命令；想要显示filtered 需要使用 explain extended 命令。在5.7版本后，默认explain直接显示partitions和filtered中的信息。\n\n注意：\n\n * explain不考虑各种cache\n * explain不能显示mysql在执行查询时所作的优化工作\n * explain不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况\n\n\n# 基本语法\n\n可以使用explain或describe语法查看执行计划\n\nexplain select select_options\n或者\ndescribe select select_options\n\n\n如果想查看某个查询sql的执行计划，在具体的查询sql前边加上explain就可以，比如explain select 1。输出各个列的作用如下：\n\n列名              描述\nid              在一个大的查询语句中个select关键字都对应一个唯一的id\nselect_type     select关键字对应的那个查询的类型\ntable           表名\npartitions      匹配的分区信息\ntype            针对单表的访问方法\npossible_keys   可能用到的索引\nkey             实际上使用的索引\nkey_len         实际使用到的索引长度（联合索引时可以看用了几个索引列）\nref             当使用索引列等值查询时，与索引列进行等值匹配的对象信息\nrows            预估的需要读取的记录条数\nfiltered        某个表经过搜索条件过滤后剩余记录条数的百分比\nextra           一些额外的信息\n\n\n# explain各个列的作用\n\n# id\n\nsql执行的顺序标识，每个select关键字对应一个id。\n\n * id如果相同，可以认为是一组，从上往下顺序执行\n * 在所有组中，id值越大，优先级越高，越先执行\n * 关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好\n\n# select_type\n\n每个select查询的类型\n\n名称                     描述\nsimple                 简单查询（不使用 union 或子查询）\nprimary                查询中若包含任何复杂的子部分,最外层的select被标记为primary\nunion                  union中的第二个或后面的select语句\nunion result           union的结果\nsubquery               子查询中的第一个select\ndependent subquery     子查询中的第一个select，取决于外面的查询\ndependent union        union中的第二个或后面的select语句，取决于外面的查询\nderived                派生表的select, from子句的子查询\nmaterialized           materialized subquery\nuncacheable subquery   a subquery for which the result cannot be cached and must be\n                       re-evaluated for\n                       each row of the outer query\nuncacheable union      the second or later select in a union that belongs to an\n                       uncacheable subquery\n                       (see uncacheable subquery)\n\n# table\n\n查询语句无论多复杂，最终还是对每个表进行单表访问。所 以mysql规定explain语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）\n\n# partitions\n\n匹配的分区信息\n\n# type\n\n针对单表的访问方法，即mysql决定如何查找表中的行。\n\n完整的访问方法如下：system、const、eq_ref、ref、fulltext、ref_or_null、index_merge、unique_subquery、index_subquery、range、index、all。\n\n结果值从最好到最坏依次是： system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > all\n\n> sql性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是consts级别。（阿里巴巴开发手册要求）\n\n# possible_keys和key\n\npossible_keys：可能使用哪些索引来查找\n\nkey：实际使用哪些索引查找\n\n# key_len\n\n这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列（主要用于联合索引）。\n\n举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。\n\nmysql> explain select * from film_actor where film_id = 2;\n+----+-------------+------------+------+-------------------+-------------------+---------+-------+------+-------------+\n| id | select_type | table      | type | possible_keys     | key               | key_len | ref   | rows | extra       |\n+----+-------------+------------+------+-------------------+-------------------+---------+-------+------+-------------+\n|  1 | simple      | film_actor | ref  | idx_film_actor_id | idx_film_actor_id | 4       | const |    1 | using index |\n+----+-------------+------------+------+-------------------+-------------------+---------+-------+------+-------------+\n\n\nkey_len计算规则如下：\n\n * 字符串\n   * char(n)：n字节长度\n   * varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2\n * 数值类型\n   * tinyint：1字节\n   * smallint：2字节\n   * int：4字节\n   * bigint：8字节\n * 时间类型\n   * date：3字节\n   * timestamp：4字节\n   * datetime：8字节\n * 如果字段允许为 null，需要1字节记录是否为 null\n\n# ref\n\n这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），func，null，字段名（例：film.id）\n\n# rows\n\n这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。\n\n# filtered\n\n某个表经过搜索条件过滤后剩余记录条数的百分比。这个值越大越好。\n\n# extra\n\n这一列展示的是额外信息。常见的重要值如下：\n\n * distinct： 一旦mysql找到了与行相联合匹配的行，就不再搜索了\n * using index：这发生在对表的请求列都是同一索引的部分的时候，返回的列数据只使用了索引中的信息，而没有再去访问表中的行记录。是性能高的表现。\n * using where：mysql服务器将在存储引擎检索行后再进行过滤。就是先读取整行数据，再按 where 条件进行检查，符合就留下，不符合就丢弃。\n * using temporary：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。\n * using filesort：mysql 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。这种情况下一般也是要考虑使用索引来优化的。\n\n\n# mysql监控分析视图-sys schemea\n\n\n# sys schemea视图摘要\n\n 1.  主机相关：以host_summary开头，主要汇总了io延迟的信息。\n 2.  innodb相关：以innodb开头，汇总了innodb buffer信息和事务等待innodb锁的信息。\n 3.  i/o相关：以io开头，汇总了等待i/o、i/o使用量情况。\n 4.  内存使用情况：以memory开头，从主机、线程、事件等角度展示内存的使用情况\n 5.  连接与会话信息：processlist和session相关视图，总结了会话相关信息。\n 6.  表相关：以schema_table开头的视图，展示了表的统计信息。\n 7.  索引信息：统计了索引的使用情况，包含冗余索引和未使用的索引情况。\n 8.  语句相关：以statement开头，包含执行全表扫描、使用临时表、排序等的语句信息。\n 9.  用户相关：以user开头的视图，统计了用户使用的文件i/o、执行语句统计信息。\n 10. 等待事件相关信息：以wait开头，展示等待事件的延迟情况。\n\n\n# sys schemea视图使用场景\n\n索引情况：\n\n#1. 查询冗余索引\nselect * from sys.schema_redundant_indexes;\n#2. 查询未使用过的索引\nselect * from sys.schema_unused_indexes;\n#3. 查询索引的使用情况\nselect index_name,rows_selected,rows_inserted,rows_updated,rows_deleted\nfrom sys.schema_index_statistics where table_schema='dbname' ;\n\n\n表相关：\n\n# 1. 查询表的访问量\nselect table_schema,table_name,sum(io_read_requests+io_write_requests) as io from\nsys.schema_table_statistics group by table_schema,table_name order by io desc;\n# 2. 查询占用bufferpool较多的表\nselect object_schema,object_name,allocated,data\nfrom sys.innodb_buffer_stats_by_table order by allocated limit 10;\n# 3. 查看表的全表扫描情况\nselect * from sys.statements_with_full_table_scans where db='dbname';\n\n\n语句相关：\n\n#1. 监控sql执行的频率\nselect db,exec_count,query from sys.statement_analysis\norder by exec_count desc;\n#2. 监控使用了排序的sql\nselect db,exec_count,first_seen,last_seen,query\nfrom sys.statements_with_sorting limit 1;\n#3. 监控使用了临时表或者磁盘临时表的sql\nselect db,exec_count,tmp_tables,tmp_disk_tables,query\nfrom sys.statement_analysis where tmp_tables>0 or tmp_disk_tables >0\norder by (tmp_tables+tmp_disk_tables) desc;\n\n\nio相关：\n\n#1. 查看消耗磁盘io的文件\nselect file,avg_read,avg_write,avg_read+avg_write as avg_io\nfrom sys.io_global_by_file_by_bytes order by avg_read limit 10;\n\n\ninnodb相关：\n\n#1. 行锁阻塞情况\nselect * from sys.innodb_lock_waits;\n\n\n\n# sql 优化\n\nsql查询优化可以分成物理查询优化和逻辑查询优化。\n\n * 物理查询优化：索引、表连接\n * 逻辑查询优化：sql等价变换\n\n\n# 索引优化\n\n\n# 索引失效的情况\n\n 1.  优化全值匹配：优先使用联合索引而不是单列索引。\n\n 2.  最佳左前缀法则：对于多列索引，过滤条件要使用索引必须按照索引建立的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。如果查询条件没有使用第一个字段，联合索引不会被使用。\n\n 3.  主键插入顺序：最好让主键依次递增，避免页分裂和记录移位造成的性能损耗。\n\n 4.  计算、函数导致索引失效\n\n 5.  类型转换（自动或手动）导致索引失效\n\n 6.  范围条件右边的列索引失效\n\n 7.  不等于（!=或者<>）索引失效\n\n 8.  is null可以使用索引,is not null无法使用索引\n\n 9.  like以通配符%开头索引失效\n\n 10. or前后存在非索引的列，索引失效\n\n 11. 数据库和表的字符集统一使用utf8mb4：不同字符集进行比较前需要进行转换造成索引失效。\n\n\n# 关联查询优化\n\n内连接时，查询优化器可以决定哪张表为驱动表，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表。\n\n对于内连接来说，在两个表的连接条件都存在索引的情况下，小表驱动大表（小的结果集驱动大的结果集）。\n\n\n# join底层原理\n\n# 简单嵌套循环连接\n\n都无索引。性能主要受被驱动表的全表扫描次数，也就是驱动表匹配数据。\n\n# 索引嵌套循环连接\n\n表中添加索引，被驱动表为加了索引的表，无须全表扫描。\n\n# 块嵌套循环连接\n\n驱动表一块一块获取多条数据，减少非驱动表的全表扫描。\n\n\n# 子查询优化\n\n子查询会建立临时表，影响查询性能。在mysql中可以使用join查询来替代子查询。\n\n\n# 排序优化\n\nmysql支持两种排序方式，分别filesort和index排序\n\n * index排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高\n * filesort排序一般在内存中进行排序，效率较低。\n\n在order by 子句中使用索引，避免使用filesort排序。\n\n\n# group by优化\n\ngroup by 先排序再分组，遵照索引建的最佳左前缀法则\n\n\n# 函数优化\n\nmax/min函数：使用order by 列名 limit 1进行优化",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"MySQL命令大全",frontmatter:{title:"MySQL命令大全",date:"2023-10-24T03:12:56.000Z",permalink:"/pages/f7fcac/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/02.%E6%95%B0%E6%8D%AE%E5%BA%93/02.MySQL/05.MySQL%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.html",relativePath:"01.Java 知识体系/02.数据库/02.MySQL/05.MySQL命令大全.md",key:"v-558474a0",path:"/pages/f7fcac/",headers:[{level:2,title:"数据库操作",slug:"数据库操作",normalizedTitle:"数据库操作",charIndex:2},{level:2,title:"表操作",slug:"表操作",normalizedTitle:"表操作",charIndex:58},{level:3,title:"创建表",slug:"创建表",normalizedTitle:"创建表",charIndex:66},{level:3,title:"查询表",slug:"查询表",normalizedTitle:"查询表",charIndex:518},{level:3,title:"修改表",slug:"修改表",normalizedTitle:"修改表",charIndex:553},{level:3,title:"删除表",slug:"删除表",normalizedTitle:"删除表",charIndex:795},{level:3,title:"重命名表",slug:"重命名表",normalizedTitle:"重命名表",charIndex:826},{level:3,title:"获取表信息",slug:"获取表信息",normalizedTitle:"获取表信息",charIndex:893},{level:2,title:"检索数据",slug:"检索数据",normalizedTitle:"检索数据",charIndex:1001},{level:3,title:"去重",slug:"去重",normalizedTitle:"去重",charIndex:1125},{level:3,title:"限制结果",slug:"限制结果",normalizedTitle:"限制结果",charIndex:1267},{level:3,title:"排序检索数据",slug:"排序检索数据",normalizedTitle:"排序检索数据",charIndex:1500},{level:3,title:"过滤数据",slug:"过滤数据",normalizedTitle:"过滤数据",charIndex:1716},{level:4,title:"逻辑操作符",slug:"逻辑操作符",normalizedTitle:"逻辑操作符",charIndex:1972},{level:4,title:"IN操作符",slug:"in操作符",normalizedTitle:"in操作符",charIndex:2366},{level:4,title:"NOT操作符",slug:"not操作符",normalizedTitle:"not操作符",charIndex:2498},{level:4,title:"通配符查询",slug:"通配符查询",normalizedTitle:"通配符查询",charIndex:2636},{level:4,title:"正则表达式",slug:"正则表达式",normalizedTitle:"正则表达式",charIndex:2830},{level:3,title:"计算字段",slug:"计算字段",normalizedTitle:"计算字段",charIndex:697},{level:3,title:"数据处理函数",slug:"数据处理函数",normalizedTitle:"数据处理函数",charIndex:4359},{level:4,title:"文本处理函数",slug:"文本处理函数",normalizedTitle:"文本处理函数",charIndex:4369},{level:4,title:"日期和时间处理函数",slug:"日期和时间处理函数",normalizedTitle:"日期和时间处理函数",charIndex:4381},{level:4,title:"数值处理函数",slug:"数值处理函数",normalizedTitle:"数值处理函数",charIndex:4452},{level:3,title:"聚集函数",slug:"聚集函数",normalizedTitle:"聚集函数",charIndex:4465},{level:3,title:"分组数据",slug:"分组数据",normalizedTitle:"分组数据",charIndex:5087},{level:3,title:"使用子查询",slug:"使用子查询",normalizedTitle:"使用子查询",charIndex:5427},{level:3,title:"联结查询",slug:"联结查询",normalizedTitle:"联结查询",charIndex:5780},{level:4,title:"内部联结",slug:"内部联结",normalizedTitle:"内部联结",charIndex:5788},{level:4,title:"左外联结",slug:"左外联结",normalizedTitle:"左外联结",charIndex:6268},{level:4,title:"右外联结",slug:"右外联结",normalizedTitle:"右外联结",charIndex:6388},{level:4,title:"",slug:"",normalizedTitle:"",charIndex:0},{level:3,title:"组合查询",slug:"组合查询",normalizedTitle:"组合查询",charIndex:6513},{level:2,title:"插入数据",slug:"插入数据",normalizedTitle:"插入数据",charIndex:7090},{level:2,title:"更新数据",slug:"更新数据",normalizedTitle:"更新数据",charIndex:7835},{level:2,title:"删除数据",slug:"删除数据",normalizedTitle:"删除数据",charIndex:8098}],headersStr:"数据库操作 表操作 创建表 查询表 修改表 删除表 重命名表 获取表信息 检索数据 去重 限制结果 排序检索数据 过滤数据 逻辑操作符 IN操作符 NOT操作符 通配符查询 正则表达式 计算字段 数据处理函数 文本处理函数 日期和时间处理函数 数值处理函数 聚集函数 分组数据 使用子查询 联结查询 内部联结 左外联结 右外联结  组合查询 插入数据 更新数据 删除数据",content:"# 数据库操作\n\nuse dbName： 选择数据库\n\nshow databases：返回可用的数据库列表\n\n\n# 表操作\n\n\n# 创建表\n\nCREATE TABLE `customers` (\n  cust_id int(11) NOT NULL AUTO_INCREMENT,\n  cust_name char(50) NOT NULL,\n  cust_address char(50) DEFAULT NULL,\n  cust_city char(50) DEFAULT NULL,\n  cust_state char(5) DEFAULT NULL,\n  cust_zip char(10) DEFAULT NULL,\n  cust_country char(50) DEFAULT NULL,\n  cust_contact char(50) DEFAULT NULL,\n  cust_email char(255) DEFAULT NULL,\n  PRIMARY KEY (cust_id)\n) ENGINE=InnoDB AUTO_INCREMENT=10009 DEFAULT CHARSET=utf8mb4;\n\n\n\n# 查询表\n\nshow tables：返回当前数据库可用的表列表\n\n\n# 修改表\n\nALTER TABLE vendors ADD vend_phone CHAR(20)\n\n\n复杂的表结构更改一般需要手动删除过程，它涉及以下步骤：\n\n 1. 用新的列布局创建一个新表；\n 2. 使用INSERT SELECT语句从旧表复制数据到新表。如果有必要，可使用转换函数和计算字段；\n 3. 检验包含所需数据的新表；\n 4. 重命名旧表（如果确定，可以删除它）；\n 5. 用旧表原来的名字重命名新表；\n 6. 根据需要，重新创建触发器、存储过程、索引和外键。\n\n\n# 删除表\n\nDROP TABLE customers\n\n\n\n# 重命名表\n\nRENAME TABLE customers TO customers2,\norders TO orders2\n\n\n\n# 获取表信息\n\nshow columns form tableName：返回表中每个字段的详细信息。\n\ndescribe tableName：show columns form tableName的快捷方式。\n\n\n# 检索数据\n\nselect子句顺序：\n\n\n\nselect column from table：检索单个列\n\nselect column1,column2 from table：检索多个列\n\nselect * from table：检索所有列\n\n\n# 去重\n\nselect distinct column from table：检索单个列并去重\n\nselect distinct column1,column2 from table：distinct 应用于所有列（column1,column2 ），而不仅是column1。\n\n\n# 限制结果\n\nselect column from table limit 5：检索单个列，并返回5行数据\n\nselect column from table limit 5,5：检索单个列，并返回从行5开始的5条数据（第一个数为开始位置，第二个数为行数，检索出来的数据第一行为行0而不是行1）\n\nselect column from table limit 5 offset 5：等同上于select column from table limit 5,5\n\n\n# 排序检索数据\n\nselect column from table order by column：以字母顺序排序检索出来的数据（默认升序）\n\nselect column from table order by column1,column2：多个列排序（先按column1排序，再通过column2排序）\n\nselect column from table order by column asc/desc：升序/降序排序\n\n\n# 过滤数据\n\nselect column from table where column=columnVal：返回column列值为columnVal的数据。\n\nselect column from table where column between startVal and endVal：返回值范围在startVal到endVal的数据。\n\nselect column from table where column is null：返回column值为null的数据\n\nwhere子句操作符有：\n\n\n\n# 逻辑操作符\n\nselect column from table where column1=columnVal1 and column2=columnVal2：返回column1等于columnVal1 并且column2=columnVal2的数据\n\nselect column from table where column1=columnVal1 or column2=columnVal2：返回column1等于columnVal1 或者column2=columnVal2的数据\n\n计算次序：SQL优先处理AND操作符，然后再处理OR操作符\n\n最好使用园括号明确操作符处理次序：select column from table where (column1=columnVal1 or column2=columnVal2) and column2=columnVal3\n\n# IN操作符\n\nselect column from table where column in (columnVal1,columnVal2,columnVal3)：返回column值为columnVal1或columnVal2或columnVal3的数据\n\n# NOT操作符\n\nselect column from table where column not in (columnVal1,columnVal2,columnVal3)：返回column值不为columnVal1或columnVal2或columnVal3的数据\n\n# 通配符查询\n\nselect column from table column like 'jet%'：返回column中以jet开头的数据\n\nselect column from table column like '%jet%'：返回column中包含jet的数据\n\nselect column from table column like '_jet'：下划线_只匹配一个字符\n\n# 正则表达式\n\n正则表达式是用来匹配文本的特殊的串（字符集合）。\n\nMySQL仅支持多数正则表达式实现的一个很小的子集\n\nselect prod_name from products wehre prod_name REGEXP '1000' order by prod_name:检索列prod_name包含文本1000的所有行\n\nselect prod_name from products wehre prod_name REGEXP '1000|2000' order by prod_name:检索列prod_name包含文本1000或2000的所有行\n\nselect prod_name from products wehre prod_name REGEXP '[123]' order by prod_name：检索列prod_name包含文本1或2或3的所有行，等价于[1|2|3]\n\nselect prod_name from products wehre prod_name REGEXP '[0-9]' order by prod_name：检索列prod_name包含文本0到9的所有行，等价于[0123456789]\n\nselect prod_name from products wehre prod_name REGEXP '\\.' order by prod_name：检索列prod_name包含文本.的所有行，特殊字符需要使用\\为前导\n\n\n# 计算字段\n\n计算字段就是转换、计算或格式化检索出来的数据。\n\nselect Concat(vend_name,'(','vend_country',')') from vendors order by vend_name：Concat函数拼接字段\n\nselect RTrim(vend_name) from vendors order by vend_name：去除vend_name右边所有空格\n\nselect LTrim(vend_name) from vendors order by vend_name：去除vend_name左边所有空格\n\nselect Trim(vend_name) from vendors order by vend_name：去除vend_name所有空格\n\nselect Concat(vend_name,'(','vend_country',')') as vend_title from vendors order by vend_name：使用别名\n\n算术操作符\n\nselect quantity*item_price as expanded_price from orderitems where order_num=20005：计算quantity和item_price 乘\n\nselect quantity+item_price as expanded_price from orderitems where order_num=20005：计算quantity和item_price 加\n\nselect quantity-item_price as expanded_price from orderitems where order_num=20005：计算quantity和item_price 减\n\nselect quantity/item_price as expanded_price from orderitems where order_num=20005：计算quantity和item_price 除\n\n\n# 数据处理函数\n\n# 文本处理函数\n\n\n\n# 日期和时间处理函数\n\n\n\nDate(order_date)指示MySQL仅提取列的日期部分，如果想要的仅是日期，那就使用Date()。\n\n# 数值处理函数\n\n\n\n\n# 聚集函数\n\n\n\nselect AVG(prod_price) as avg_price from products：返回products中prod_price的平均值。 AVG()函数忽略列值为NULL的行。\n\nselect AVG(distinct prod_price) as avg_price from products：返回products中列prod_price去重后的平均值。\n\nselect COUNT(*) as num_cust from customers：返回customers表中客户的总数，不管表列中是否包含空值（NULL）\n\nselect COUNT(cust_email) as num_cust from customers：返回customers表中列cust_email有值的总数，忽略空值。\n\nselect MAX(prod_price) as max_price from products：返回products表列prod_price的最大值，忽略NULL\n\nselect MIN(prod_price) as max_price from products：返回products表列prod_price的最小值，忽略NULL\n\nselect SUM(quantity) as items_ordered from orderitems ：返回表orderitems中quantity值之和\n\n\n# 分组数据\n\nselect vend_id,COUNT(*) as num_prods from products group bu vend_id：通过vend_id分组，并获取每组的数据\n\nwhere过滤行，having 过滤分组。where在数据分组前进行过滤，having在数据分组后进行过滤。\n\nselect cust_id,COUNT() as orders from orders group by cust_id having count() >= 2：分组过滤条件\n\nselect vend_id,COUNT(*) as num_prods from products group bu vend_id order by num_prods ：分组后排序\n\n\n# 使用子查询\n\nwhere ...in使用子查询\n\nselect cust_name,cust_contact from customers where cust_id in (\n\tselect cust_id from orders where order_num in (\n\t\tselect order_num from orderitems where prod_id='TNT2'\n\t)\n)\n\n\n填充计算列\n\nSELECT cust_name, cust_state,( SELECT count(*) FROM orders WHERE orders.cust_id = customers.cust_id ) \nFROM\n\tcustomers \nORDER BY\n\tcust_name\n\n\n\n# 联结查询\n\n# 内部联结\n\nselect vend_name,prod_name,prod_price from vendors,products\nwhere vendors.vend_id=products.vend_id\nORDER BY vend_name,prod_name\n\n\nwhere vendors.vend_id=products.vend_id是联结条件，没有联结条件会出现笛卡儿积现象。\n\n内联结也可以使用INNER JOIN替代\n\nselect vend_name,prod_name,prod_price from vendors INNER JOIN products\nON vendors.vend_id=products.vend_id\nORDER BY vend_name,prod_name\n\n\nselect p1.prod_id,p1.prod_name from products as p1,products as p2 \nwhere p1.vend_id=p2.vend_id and p2.prod_id='DTNTR'\n\n\n# 左外联结\n\nselect customers.cust_id,orders.order_num from customers LEFT JOIN orders ON orders.cust_id=customers.cust_id\n\n\n# 右外联结\n\n#\n\nselect customers.cust_id,orders.order_num from customers RIGHT JOIN orders ON orders.cust_id=customers.cust_id\n\n\n\n# 组合查询\n\nUNION取重，UNION ALL不去重\n\nSELECT vend_id,prod_id,prod_price FROM products WHERE prod_price <=5\nUNION\nSELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN (1001,1002);\n\n\nSELECT vend_id,prod_id,prod_price FROM products WHERE prod_price <=5\nUNION ALL\nSELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN (1001,1002);\n\n\n在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。\n\nSELECT vend_id,prod_id,prod_price FROM products WHERE prod_price <=5\nUNION\nSELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN (1001,1002)\norder by vend_id,prod_id\n\n\n\n# 插入数据\n\n插入完整行：\n\nINSERT INTO customers \nVALUES (NULL, 'Pep E.LaPew','100 Main Street','Los Angeles','CA','90046','USA',NULL,NULL)\n\n\n推荐使用\n\nINSERT INTO customers ( cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)\nVALUES\n\t( 10001, 'Coyote Inc.', '200 Maple Lane', 'Detroit', 'MI', '44444', 'USA', 'Y Lee', 'ylee@coyote.com' );\n\n\n插入多条数据：\n\nINSERT INTO customers ( cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)\nVALUES\n\t( 10007, 'Coyote Inc.', '200 Maple Lane', 'Detroit', 'MI', '44444', 'USA', 'Y Lee', 'ylee@coyote.com' ),\n\t( 10008, 'Coyote Inc.', '200 Maple Lane', 'Detroit', 'MI', '44444', 'USA', 'Y Lee', 'ylee@coyote.com' );\n\n\n\n# 更新数据\n\nUPDATE customers SET cust_name = 'Yosemite Place', cust_address = '829 Riverside Drive', cust_city = 'Phoenix', cust_state = 'AZ', cust_zip = '88888', cust_country = 'USA', cust_contact = 'Y Sam', cust_email = 'sam@yosemite.com' WHERE cust_id = 10004;\n\n\n\n# 删除数据\n\nDELETE FROM customers where cust_id=10006\n",normalizedContent:"# 数据库操作\n\nuse dbname： 选择数据库\n\nshow databases：返回可用的数据库列表\n\n\n# 表操作\n\n\n# 创建表\n\ncreate table `customers` (\n  cust_id int(11) not null auto_increment,\n  cust_name char(50) not null,\n  cust_address char(50) default null,\n  cust_city char(50) default null,\n  cust_state char(5) default null,\n  cust_zip char(10) default null,\n  cust_country char(50) default null,\n  cust_contact char(50) default null,\n  cust_email char(255) default null,\n  primary key (cust_id)\n) engine=innodb auto_increment=10009 default charset=utf8mb4;\n\n\n\n# 查询表\n\nshow tables：返回当前数据库可用的表列表\n\n\n# 修改表\n\nalter table vendors add vend_phone char(20)\n\n\n复杂的表结构更改一般需要手动删除过程，它涉及以下步骤：\n\n 1. 用新的列布局创建一个新表；\n 2. 使用insert select语句从旧表复制数据到新表。如果有必要，可使用转换函数和计算字段；\n 3. 检验包含所需数据的新表；\n 4. 重命名旧表（如果确定，可以删除它）；\n 5. 用旧表原来的名字重命名新表；\n 6. 根据需要，重新创建触发器、存储过程、索引和外键。\n\n\n# 删除表\n\ndrop table customers\n\n\n\n# 重命名表\n\nrename table customers to customers2,\norders to orders2\n\n\n\n# 获取表信息\n\nshow columns form tablename：返回表中每个字段的详细信息。\n\ndescribe tablename：show columns form tablename的快捷方式。\n\n\n# 检索数据\n\nselect子句顺序：\n\n\n\nselect column from table：检索单个列\n\nselect column1,column2 from table：检索多个列\n\nselect * from table：检索所有列\n\n\n# 去重\n\nselect distinct column from table：检索单个列并去重\n\nselect distinct column1,column2 from table：distinct 应用于所有列（column1,column2 ），而不仅是column1。\n\n\n# 限制结果\n\nselect column from table limit 5：检索单个列，并返回5行数据\n\nselect column from table limit 5,5：检索单个列，并返回从行5开始的5条数据（第一个数为开始位置，第二个数为行数，检索出来的数据第一行为行0而不是行1）\n\nselect column from table limit 5 offset 5：等同上于select column from table limit 5,5\n\n\n# 排序检索数据\n\nselect column from table order by column：以字母顺序排序检索出来的数据（默认升序）\n\nselect column from table order by column1,column2：多个列排序（先按column1排序，再通过column2排序）\n\nselect column from table order by column asc/desc：升序/降序排序\n\n\n# 过滤数据\n\nselect column from table where column=columnval：返回column列值为columnval的数据。\n\nselect column from table where column between startval and endval：返回值范围在startval到endval的数据。\n\nselect column from table where column is null：返回column值为null的数据\n\nwhere子句操作符有：\n\n\n\n# 逻辑操作符\n\nselect column from table where column1=columnval1 and column2=columnval2：返回column1等于columnval1 并且column2=columnval2的数据\n\nselect column from table where column1=columnval1 or column2=columnval2：返回column1等于columnval1 或者column2=columnval2的数据\n\n计算次序：sql优先处理and操作符，然后再处理or操作符\n\n最好使用园括号明确操作符处理次序：select column from table where (column1=columnval1 or column2=columnval2) and column2=columnval3\n\n# in操作符\n\nselect column from table where column in (columnval1,columnval2,columnval3)：返回column值为columnval1或columnval2或columnval3的数据\n\n# not操作符\n\nselect column from table where column not in (columnval1,columnval2,columnval3)：返回column值不为columnval1或columnval2或columnval3的数据\n\n# 通配符查询\n\nselect column from table column like 'jet%'：返回column中以jet开头的数据\n\nselect column from table column like '%jet%'：返回column中包含jet的数据\n\nselect column from table column like '_jet'：下划线_只匹配一个字符\n\n# 正则表达式\n\n正则表达式是用来匹配文本的特殊的串（字符集合）。\n\nmysql仅支持多数正则表达式实现的一个很小的子集\n\nselect prod_name from products wehre prod_name regexp '1000' order by prod_name:检索列prod_name包含文本1000的所有行\n\nselect prod_name from products wehre prod_name regexp '1000|2000' order by prod_name:检索列prod_name包含文本1000或2000的所有行\n\nselect prod_name from products wehre prod_name regexp '[123]' order by prod_name：检索列prod_name包含文本1或2或3的所有行，等价于[1|2|3]\n\nselect prod_name from products wehre prod_name regexp '[0-9]' order by prod_name：检索列prod_name包含文本0到9的所有行，等价于[0123456789]\n\nselect prod_name from products wehre prod_name regexp '\\.' order by prod_name：检索列prod_name包含文本.的所有行，特殊字符需要使用\\为前导\n\n\n# 计算字段\n\n计算字段就是转换、计算或格式化检索出来的数据。\n\nselect concat(vend_name,'(','vend_country',')') from vendors order by vend_name：concat函数拼接字段\n\nselect rtrim(vend_name) from vendors order by vend_name：去除vend_name右边所有空格\n\nselect ltrim(vend_name) from vendors order by vend_name：去除vend_name左边所有空格\n\nselect trim(vend_name) from vendors order by vend_name：去除vend_name所有空格\n\nselect concat(vend_name,'(','vend_country',')') as vend_title from vendors order by vend_name：使用别名\n\n算术操作符\n\nselect quantity*item_price as expanded_price from orderitems where order_num=20005：计算quantity和item_price 乘\n\nselect quantity+item_price as expanded_price from orderitems where order_num=20005：计算quantity和item_price 加\n\nselect quantity-item_price as expanded_price from orderitems where order_num=20005：计算quantity和item_price 减\n\nselect quantity/item_price as expanded_price from orderitems where order_num=20005：计算quantity和item_price 除\n\n\n# 数据处理函数\n\n# 文本处理函数\n\n\n\n# 日期和时间处理函数\n\n\n\ndate(order_date)指示mysql仅提取列的日期部分，如果想要的仅是日期，那就使用date()。\n\n# 数值处理函数\n\n\n\n\n# 聚集函数\n\n\n\nselect avg(prod_price) as avg_price from products：返回products中prod_price的平均值。 avg()函数忽略列值为null的行。\n\nselect avg(distinct prod_price) as avg_price from products：返回products中列prod_price去重后的平均值。\n\nselect count(*) as num_cust from customers：返回customers表中客户的总数，不管表列中是否包含空值（null）\n\nselect count(cust_email) as num_cust from customers：返回customers表中列cust_email有值的总数，忽略空值。\n\nselect max(prod_price) as max_price from products：返回products表列prod_price的最大值，忽略null\n\nselect min(prod_price) as max_price from products：返回products表列prod_price的最小值，忽略null\n\nselect sum(quantity) as items_ordered from orderitems ：返回表orderitems中quantity值之和\n\n\n# 分组数据\n\nselect vend_id,count(*) as num_prods from products group bu vend_id：通过vend_id分组，并获取每组的数据\n\nwhere过滤行，having 过滤分组。where在数据分组前进行过滤，having在数据分组后进行过滤。\n\nselect cust_id,count() as orders from orders group by cust_id having count() >= 2：分组过滤条件\n\nselect vend_id,count(*) as num_prods from products group bu vend_id order by num_prods ：分组后排序\n\n\n# 使用子查询\n\nwhere ...in使用子查询\n\nselect cust_name,cust_contact from customers where cust_id in (\n\tselect cust_id from orders where order_num in (\n\t\tselect order_num from orderitems where prod_id='tnt2'\n\t)\n)\n\n\n填充计算列\n\nselect cust_name, cust_state,( select count(*) from orders where orders.cust_id = customers.cust_id ) \nfrom\n\tcustomers \norder by\n\tcust_name\n\n\n\n# 联结查询\n\n# 内部联结\n\nselect vend_name,prod_name,prod_price from vendors,products\nwhere vendors.vend_id=products.vend_id\norder by vend_name,prod_name\n\n\nwhere vendors.vend_id=products.vend_id是联结条件，没有联结条件会出现笛卡儿积现象。\n\n内联结也可以使用inner join替代\n\nselect vend_name,prod_name,prod_price from vendors inner join products\non vendors.vend_id=products.vend_id\norder by vend_name,prod_name\n\n\nselect p1.prod_id,p1.prod_name from products as p1,products as p2 \nwhere p1.vend_id=p2.vend_id and p2.prod_id='dtntr'\n\n\n# 左外联结\n\nselect customers.cust_id,orders.order_num from customers left join orders on orders.cust_id=customers.cust_id\n\n\n# 右外联结\n\n#\n\nselect customers.cust_id,orders.order_num from customers right join orders on orders.cust_id=customers.cust_id\n\n\n\n# 组合查询\n\nunion取重，union all不去重\n\nselect vend_id,prod_id,prod_price from products where prod_price <=5\nunion\nselect vend_id,prod_id,prod_price from products where vend_id in (1001,1002);\n\n\nselect vend_id,prod_id,prod_price from products where prod_price <=5\nunion all\nselect vend_id,prod_id,prod_price from products where vend_id in (1001,1002);\n\n\n在用union组合查询时，只能使用一条order by子句，它必须出现在最后一条select语句之后。\n\nselect vend_id,prod_id,prod_price from products where prod_price <=5\nunion\nselect vend_id,prod_id,prod_price from products where vend_id in (1001,1002)\norder by vend_id,prod_id\n\n\n\n# 插入数据\n\n插入完整行：\n\ninsert into customers \nvalues (null, 'pep e.lapew','100 main street','los angeles','ca','90046','usa',null,null)\n\n\n推荐使用\n\ninsert into customers ( cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)\nvalues\n\t( 10001, 'coyote inc.', '200 maple lane', 'detroit', 'mi', '44444', 'usa', 'y lee', 'ylee@coyote.com' );\n\n\n插入多条数据：\n\ninsert into customers ( cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)\nvalues\n\t( 10007, 'coyote inc.', '200 maple lane', 'detroit', 'mi', '44444', 'usa', 'y lee', 'ylee@coyote.com' ),\n\t( 10008, 'coyote inc.', '200 maple lane', 'detroit', 'mi', '44444', 'usa', 'y lee', 'ylee@coyote.com' );\n\n\n\n# 更新数据\n\nupdate customers set cust_name = 'yosemite place', cust_address = '829 riverside drive', cust_city = 'phoenix', cust_state = 'az', cust_zip = '88888', cust_country = 'usa', cust_contact = 'y sam', cust_email = 'sam@yosemite.com' where cust_id = 10004;\n\n\n\n# 删除数据\n\ndelete from customers where cust_id=10006\n",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"BigDecimal 详解",frontmatter:{title:"BigDecimal 详解",date:"2023-10-23T23:54:17.000Z",permalink:"/pages/f7214d/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/03.Java/01.Java%20%E5%9F%BA%E7%A1%80/01.BigDecimal%20%E8%AF%A6%E8%A7%A3.html",relativePath:"01.Java 知识体系/03.Java/01.Java 基础/01.BigDecimal 详解.md",key:"v-4d3b354d",path:"/pages/f7214d/",headers:[{level:1,title:"BigDecimal 常见方法",slug:"bigdecimal-常见方法",normalizedTitle:"bigdecimal 常见方法",charIndex:89},{level:2,title:"创建",slug:"创建",normalizedTitle:"创建",charIndex:109},{level:2,title:"加减乘除",slug:"加减乘除",normalizedTitle:"加减乘除",charIndex:388},{level:2,title:"保留几位小数",slug:"保留几位小数",normalizedTitle:"保留几位小数",charIndex:629},{level:2,title:"大小比较",slug:"大小比较",normalizedTitle:"大小比较",charIndex:924}],headersStr:"BigDecimal 常见方法 创建 加减乘除 保留几位小数 大小比较",content:"使用BigDecimal进行浮点数的运算，避免精度丢失。\n\n通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过BigDecimal来做的。\n\n\n# BigDecimal 常见方法\n\n\n# 创建\n\n为了防止精度丢失，使用BigDecimal(String)构造方法或者BigDecimal valueOf(double val) 静态方法来创建BigDecimal 对象。\n\n> 【强制】禁止使用构造方法 BigDecimal(double)的方式把 double 值转化为 BigDecimal 对象。 说明：BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。 如：BigDecimal g = new BigDecimal(0.1F); 实际的存储值为：0.10000000149\n\n\n# 加减乘除\n\n//两个BigDecimal对象相加\npublic BigDecimal add(BigDecimal augend)\n//两个BigDecimal对象相减\npublic BigDecimal subtract(BigDecimal subtrahend)\n//两个BigDecimal对象相乘\npublic BigDecimal multiply(BigDecimal multiplicand)\n//两个BigDecimal对象相除（使用3个参数版本，scale表示保留几位小数，roundingMode 代表保留规则）。roundingMode值为BigDecimal.ROUND_HALF_UP表示四舍五入\npublic BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)\n\n\n\n# 保留几位小数\n\npublic BigDecimal setScale(int newScale, int roundingMode)\n\n\n * newScale：保留几位小数\n * roundingMode：保留规则。BigDecimal.ROUND_HALF_UP为四舍五入\n\n\n# 大小比较\n\npublic int compareTo(BigDecimal val)\n\n\n使用a.compareTo(b)进行大小比较：\n\n * -1：a 小于 b\n * 0：a 等于 b\n * 1：a 大于 b\n\n> 【强制】BigDecimal 的等值比较应使用 compareTo()方法，而不是 equals()方法。 说明：equals()方法会比较值和精度（1.0 与 1.00 返回结果为 false），而 compareTo()则会忽略精度。",normalizedContent:"使用bigdecimal进行浮点数的运算，避免精度丢失。\n\n通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过bigdecimal来做的。\n\n\n# bigdecimal 常见方法\n\n\n# 创建\n\n为了防止精度丢失，使用bigdecimal(string)构造方法或者bigdecimal valueof(double val) 静态方法来创建bigdecimal 对象。\n\n> 【强制】禁止使用构造方法 bigdecimal(double)的方式把 double 值转化为 bigdecimal 对象。 说明：bigdecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。 如：bigdecimal g = new bigdecimal(0.1f); 实际的存储值为：0.10000000149\n\n\n# 加减乘除\n\n//两个bigdecimal对象相加\npublic bigdecimal add(bigdecimal augend)\n//两个bigdecimal对象相减\npublic bigdecimal subtract(bigdecimal subtrahend)\n//两个bigdecimal对象相乘\npublic bigdecimal multiply(bigdecimal multiplicand)\n//两个bigdecimal对象相除（使用3个参数版本，scale表示保留几位小数，roundingmode 代表保留规则）。roundingmode值为bigdecimal.round_half_up表示四舍五入\npublic bigdecimal divide(bigdecimal divisor, int scale, int roundingmode)\n\n\n\n# 保留几位小数\n\npublic bigdecimal setscale(int newscale, int roundingmode)\n\n\n * newscale：保留几位小数\n * roundingmode：保留规则。bigdecimal.round_half_up为四舍五入\n\n\n# 大小比较\n\npublic int compareto(bigdecimal val)\n\n\n使用a.compareto(b)进行大小比较：\n\n * -1：a 小于 b\n * 0：a 等于 b\n * 1：a 大于 b\n\n> 【强制】bigdecimal 的等值比较应使用 compareto()方法，而不是 equals()方法。 说明：equals()方法会比较值和精度（1.0 与 1.00 返回结果为 false），而 compareto()则会忽略精度。",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"Java 集合常用使用技巧",frontmatter:{title:"Java 集合常用使用技巧",date:"2023-10-23T23:54:27.000Z",permalink:"/pages/33fb2e/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/03.Java/02.Java%20%E5%AE%B9%E5%99%A8/01.Java%20%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.html",relativePath:"01.Java 知识体系/03.Java/02.Java 容器/01.Java 集合常用使用技巧.md",key:"v-f225e21e",path:"/pages/33fb2e/",headers:[{level:1,title:"集合判空",slug:"集合判空",normalizedTitle:"集合判空",charIndex:2},{level:1,title:"集合转Map",slug:"集合转map",normalizedTitle:"集合转map",charIndex:846},{level:1,title:"集合遍历",slug:"集合遍历",normalizedTitle:"集合遍历",charIndex:1305},{level:1,title:"集合去重",slug:"集合去重",normalizedTitle:"集合去重",charIndex:1744},{level:1,title:"集合转数组",slug:"集合转数组",normalizedTitle:"集合转数组",charIndex:2431},{level:1,title:"数组转集合",slug:"数组转集合",normalizedTitle:"数组转集合",charIndex:2817},{level:1,title:"返回空集合",slug:"返回空集合",normalizedTitle:"返回空集合",charIndex:4770},{level:1,title:"集合复用",slug:"集合复用",normalizedTitle:"集合复用",charIndex:5057}],headersStr:"集合判空 集合转Map 集合遍历 集合去重 集合转数组 数组转集合 返回空集合 集合复用",content:'# 集合判空\n\n《阿里巴巴 Java 开发手册》的描述如下：\n\n> 判断所有集合内部的元素是否为空，使用 isEmpty() 方法，而不是 size()==0 的方式。\n\n这是因为 isEmpty() 方法的可读性更好，并且时间复杂度为 O(1)。\n\n绝大部分我们使用的集合的 size() 方法的时间复杂度也是 O(1)，不过，也有很多复杂度不是 O(1) 的，比如 java.util.concurrent 包下的某些集合（ConcurrentLinkedQueue 、ConcurrentHashMap...）。\n\n下面是 ConcurrentHashMap 的 size() 方法和 isEmpty() 方法的源码。\n\npublic int size() {\n    long n = sumCount();\n    return ((n < 0L) ? 0 :\n            (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :\n            (int)n);\n}\nfinal long sumCount() {\n    CounterCell[] as = counterCells; CounterCell a;\n    long sum = baseCount;\n    if (as != null) {\n        for (int i = 0; i < as.length; ++i) {\n            if ((a = as[i]) != null)\n                sum += a.value;\n        }\n    }\n    return sum;\n}\npublic boolean isEmpty() {\n    return sumCount() <= 0L; // ignore transient negative values\n}\n\n\n\n\n# 集合转Map\n\n《阿里巴巴 Java 开发手册》的描述如下：\n\n> 在使用 java.util.stream.Collectors 类的 toMap() 方法转为 Map 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。\n\nclass Person {\n    private String name;\n    private String phoneNumber;\n     // getters and setters\n}\n\nList<Person> bookList = new ArrayList<>();\nbookList.add(new Person("jack","18163138123"));\nbookList.add(new Person("martin",null));\n// 空指针异常\nbookList.stream().collect(Collectors.toMap(Person::getName, Person::getPhoneNumber));\n\n\n\n\n# 集合遍历\n\n《阿里巴巴 Java 开发手册》的描述如下：\n\n> 不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。\n\nforeach 语法糖底层其实还是依赖 Iterator 。不过， remove/add 操作直接调用的是集合自己的方法，而不是 Iterator 的 remove/add方法。\n\n这就导致 Iterator 莫名其妙地发现自己有元素被 remove/add ，然后，它就会抛出一个 ConcurrentModificationException 来提示用户发生了并发修改异常。这就是单线程状态下产生的 fail-fast 机制。\n\n> fail-fast 机制 ：多个线程对 fail-fast 集合进行修改的时候，可能会抛出ConcurrentModificationException。 即使是单线程下也有可能会出现这种情况\n\n\n# 集合去重\n\n《阿里巴巴 Java 开发手册》的描述如下：\n\n> 可以利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains() 进行遍历去重或者判断包含操作。\n\n这里以 HashSet 和 ArrayList 为例说明。\n\n// Set 去重代码示例\npublic static <T> Set<T> removeDuplicateBySet(List<T> data) {\n\n    if (CollectionUtils.isEmpty(data)) {\n        return new HashSet<>();\n    }\n    return new HashSet<>(data);\n}\n\n// List 去重代码示例\npublic static <T> List<T> removeDuplicateByList(List<T> data) {\n\n    if (CollectionUtils.isEmpty(data)) {\n        return new ArrayList<>();\n\n    }\n    List<T> result = new ArrayList<>(data.size());\n    for (T current : data) {\n        if (!result.contains(current)) {\n            result.add(current);\n        }\n    }\n    return result;\n}\n\n\n\n\n\n# 集合转数组\n\n《阿里巴巴 Java 开发手册》的描述如下：\n\n> 使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一致、长度为 0 的空数组。\n\ntoArray(T[] array) 方法的参数是一个泛型数组，如果 toArray 方法中没有传递任何参数的话返回的是 Object类 型数组。\n\nString [] s= new String[]{\n    "dog", "lazy", "a", "over", "jumps", "fox", "brown", "quick", "A"\n};\nList<String> list = Arrays.asList(s);\nCollections.reverse(list);\n//没有指定类型的话会报错\ns=list.toArray(new String[0]);\n\n\n\n\n# 数组转集合\n\n《阿里巴巴 Java 开发手册》的描述如下：\n\n> 使用工具类 Arrays.asList() 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。\n\nArrays.asList()将一个数组转换为一个 List 集合。\n\nString[] myArray = {"Apple", "Banana", "Orange"};\nList<String> myList = Arrays.asList(myArray);\n//上面两个语句等价于下面一条语句\nList<String> myList = Arrays.asList("Apple","Banana", "Orange");\n\n\n使用注意事项：\n\n 1. Arrays.asList()是泛型方法，传递的数组必须是对象数组，而不是基本类型。\n\nint[] myArray = {1, 2, 3};\nList myList = Arrays.asList(myArray);\nSystem.out.println(myList.size());//1\nSystem.out.println(myList.get(0));//数组地址值\nSystem.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsException\nint[] array = (int[]) myList.get(0);\nSystem.out.println(array[0]);//1\n\n\n当传入一个原生数据类型数组时，Arrays.asList() 的真正得到的参数就不是数组中的元素，而是数组对象本身！\n\n使用包装类型数组就可以解决这个问题。\n\nInteger[] myArray = {1, 2, 3};\n\n\n 2. 使用集合的修改方法: add()、remove()、clear()会抛出异常。\n\nList myList = Arrays.asList(1, 2, 3);\nmyList.add(4);//运行时报错：UnsupportedOperationException\nmyList.remove(1);//运行时报错：UnsupportedOperationException\nmyList.clear();//运行时报错：UnsupportedOperationException\n\n\nArrays.asList() 方法返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。\n\nList myList = Arrays.asList(1, 2, 3);\nSystem.out.println(myList.getClass());//class java.util.Arrays$ArrayList\n\n\n那我们如何正确的将数组转换为 ArrayList ?\n\n 1. 手动实现工具类\n\n//JDK1.5+\nstatic <T> List<T> arrayToList(final T[] array) {\n  final List<T> l = new ArrayList<T>(array.length);\n\n  for (final T s : array) {\n    l.add(s);\n  }\n  return l;\n}\n\n\nInteger [] myArray = { 1, 2, 3 };\nSystem.out.println(arrayToList(myArray).getClass());//class java.util.ArrayList\n\n\n\n 2. 最简便的方法\n\nList list = new ArrayList<>(Arrays.asList("a", "b", "c"))\n\n\n 3. 使用 Java8 的 Stream(推荐)\n\nInteger [] myArray = { 1, 2, 3 };\nList myList = Arrays.stream(myArray).collect(Collectors.toList());\n//基本类型也可以实现转换（依赖boxed的装箱操作）\nint [] myArray2 = { 1, 2, 3 };\nList myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());\n\n\n\n\n# 返回空集合\n\n//空List\nCollections.emptyList();\n//空Set\nCollections.emptySet();\n//空Map\nCollections.emptyMap();\n\n\n当需要一个空集合时，直接使用上面的三个方法返回空集合。\n\n注意：这些空集合不能调用add方法，否则会直接抛出异常。\n\n使用这些空集合的好处：\n\n 1. 避免内存浪费。使用new ArrayList()等方法会有初始大小，多少会占用一定内存空间。\n 2. 编码方便，避免NULL值判断。如果方法返回类型是List，返回空集合，避免方法调用者进行NULL判断。\n\n\n# 集合复用\n\nArrayList使用clear()方法可以直接复用无需再次扩容。\n\nHashMap如果需要批处理大量数据，可以分批处理，处理完一个一批后，使用clear()方法清除数据，再装载下一批数据进行处理，这样只要扩容一次。',normalizedContent:'# 集合判空\n\n《阿里巴巴 java 开发手册》的描述如下：\n\n> 判断所有集合内部的元素是否为空，使用 isempty() 方法，而不是 size()==0 的方式。\n\n这是因为 isempty() 方法的可读性更好，并且时间复杂度为 o(1)。\n\n绝大部分我们使用的集合的 size() 方法的时间复杂度也是 o(1)，不过，也有很多复杂度不是 o(1) 的，比如 java.util.concurrent 包下的某些集合（concurrentlinkedqueue 、concurrenthashmap...）。\n\n下面是 concurrenthashmap 的 size() 方法和 isempty() 方法的源码。\n\npublic int size() {\n    long n = sumcount();\n    return ((n < 0l) ? 0 :\n            (n > (long)integer.max_value) ? integer.max_value :\n            (int)n);\n}\nfinal long sumcount() {\n    countercell[] as = countercells; countercell a;\n    long sum = basecount;\n    if (as != null) {\n        for (int i = 0; i < as.length; ++i) {\n            if ((a = as[i]) != null)\n                sum += a.value;\n        }\n    }\n    return sum;\n}\npublic boolean isempty() {\n    return sumcount() <= 0l; // ignore transient negative values\n}\n\n\n\n\n# 集合转map\n\n《阿里巴巴 java 开发手册》的描述如下：\n\n> 在使用 java.util.stream.collectors 类的 tomap() 方法转为 map 集合时，一定要注意当 value 为 null 时会抛 npe 异常。\n\nclass person {\n    private string name;\n    private string phonenumber;\n     // getters and setters\n}\n\nlist<person> booklist = new arraylist<>();\nbooklist.add(new person("jack","18163138123"));\nbooklist.add(new person("martin",null));\n// 空指针异常\nbooklist.stream().collect(collectors.tomap(person::getname, person::getphonenumber));\n\n\n\n\n# 集合遍历\n\n《阿里巴巴 java 开发手册》的描述如下：\n\n> 不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 iterator 方式，如果并发操作，需要对 iterator 对象加锁。\n\nforeach 语法糖底层其实还是依赖 iterator 。不过， remove/add 操作直接调用的是集合自己的方法，而不是 iterator 的 remove/add方法。\n\n这就导致 iterator 莫名其妙地发现自己有元素被 remove/add ，然后，它就会抛出一个 concurrentmodificationexception 来提示用户发生了并发修改异常。这就是单线程状态下产生的 fail-fast 机制。\n\n> fail-fast 机制 ：多个线程对 fail-fast 集合进行修改的时候，可能会抛出concurrentmodificationexception。 即使是单线程下也有可能会出现这种情况\n\n\n# 集合去重\n\n《阿里巴巴 java 开发手册》的描述如下：\n\n> 可以利用 set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 list 的 contains() 进行遍历去重或者判断包含操作。\n\n这里以 hashset 和 arraylist 为例说明。\n\n// set 去重代码示例\npublic static <t> set<t> removeduplicatebyset(list<t> data) {\n\n    if (collectionutils.isempty(data)) {\n        return new hashset<>();\n    }\n    return new hashset<>(data);\n}\n\n// list 去重代码示例\npublic static <t> list<t> removeduplicatebylist(list<t> data) {\n\n    if (collectionutils.isempty(data)) {\n        return new arraylist<>();\n\n    }\n    list<t> result = new arraylist<>(data.size());\n    for (t current : data) {\n        if (!result.contains(current)) {\n            result.add(current);\n        }\n    }\n    return result;\n}\n\n\n\n\n\n# 集合转数组\n\n《阿里巴巴 java 开发手册》的描述如下：\n\n> 使用集合转数组的方法，必须使用集合的 toarray(t[] array)，传入的是类型完全一致、长度为 0 的空数组。\n\ntoarray(t[] array) 方法的参数是一个泛型数组，如果 toarray 方法中没有传递任何参数的话返回的是 object类 型数组。\n\nstring [] s= new string[]{\n    "dog", "lazy", "a", "over", "jumps", "fox", "brown", "quick", "a"\n};\nlist<string> list = arrays.aslist(s);\ncollections.reverse(list);\n//没有指定类型的话会报错\ns=list.toarray(new string[0]);\n\n\n\n\n# 数组转集合\n\n《阿里巴巴 java 开发手册》的描述如下：\n\n> 使用工具类 arrays.aslist() 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 add/remove/clear 方法会抛出 unsupportedoperationexception 异常。\n\narrays.aslist()将一个数组转换为一个 list 集合。\n\nstring[] myarray = {"apple", "banana", "orange"};\nlist<string> mylist = arrays.aslist(myarray);\n//上面两个语句等价于下面一条语句\nlist<string> mylist = arrays.aslist("apple","banana", "orange");\n\n\n使用注意事项：\n\n 1. arrays.aslist()是泛型方法，传递的数组必须是对象数组，而不是基本类型。\n\nint[] myarray = {1, 2, 3};\nlist mylist = arrays.aslist(myarray);\nsystem.out.println(mylist.size());//1\nsystem.out.println(mylist.get(0));//数组地址值\nsystem.out.println(mylist.get(1));//报错：arrayindexoutofboundsexception\nint[] array = (int[]) mylist.get(0);\nsystem.out.println(array[0]);//1\n\n\n当传入一个原生数据类型数组时，arrays.aslist() 的真正得到的参数就不是数组中的元素，而是数组对象本身！\n\n使用包装类型数组就可以解决这个问题。\n\ninteger[] myarray = {1, 2, 3};\n\n\n 2. 使用集合的修改方法: add()、remove()、clear()会抛出异常。\n\nlist mylist = arrays.aslist(1, 2, 3);\nmylist.add(4);//运行时报错：unsupportedoperationexception\nmylist.remove(1);//运行时报错：unsupportedoperationexception\nmylist.clear();//运行时报错：unsupportedoperationexception\n\n\narrays.aslist() 方法返回的并不是 java.util.arraylist ，而是 java.util.arrays 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。\n\nlist mylist = arrays.aslist(1, 2, 3);\nsystem.out.println(mylist.getclass());//class java.util.arrays$arraylist\n\n\n那我们如何正确的将数组转换为 arraylist ?\n\n 1. 手动实现工具类\n\n//jdk1.5+\nstatic <t> list<t> arraytolist(final t[] array) {\n  final list<t> l = new arraylist<t>(array.length);\n\n  for (final t s : array) {\n    l.add(s);\n  }\n  return l;\n}\n\n\ninteger [] myarray = { 1, 2, 3 };\nsystem.out.println(arraytolist(myarray).getclass());//class java.util.arraylist\n\n\n\n 2. 最简便的方法\n\nlist list = new arraylist<>(arrays.aslist("a", "b", "c"))\n\n\n 3. 使用 java8 的 stream(推荐)\n\ninteger [] myarray = { 1, 2, 3 };\nlist mylist = arrays.stream(myarray).collect(collectors.tolist());\n//基本类型也可以实现转换（依赖boxed的装箱操作）\nint [] myarray2 = { 1, 2, 3 };\nlist mylist = arrays.stream(myarray2).boxed().collect(collectors.tolist());\n\n\n\n\n# 返回空集合\n\n//空list\ncollections.emptylist();\n//空set\ncollections.emptyset();\n//空map\ncollections.emptymap();\n\n\n当需要一个空集合时，直接使用上面的三个方法返回空集合。\n\n注意：这些空集合不能调用add方法，否则会直接抛出异常。\n\n使用这些空集合的好处：\n\n 1. 避免内存浪费。使用new arraylist()等方法会有初始大小，多少会占用一定内存空间。\n 2. 编码方便，避免null值判断。如果方法返回类型是list，返回空集合，避免方法调用者进行null判断。\n\n\n# 集合复用\n\narraylist使用clear()方法可以直接复用无需再次扩容。\n\nhashmap如果需要批处理大量数据，可以分批处理，处理完一个一批后，使用clear()方法清除数据，再装载下一批数据进行处理，这样只要扩容一次。',charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"Java 异常体系",frontmatter:{title:"Java 异常体系",date:"2023-10-23T23:54:17.000Z",permalink:"/pages/8f19aa/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/03.Java/01.Java%20%E5%9F%BA%E7%A1%80/02.Java%20%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.html",relativePath:"01.Java 知识体系/03.Java/01.Java 基础/02.Java 异常体系.md",key:"v-09788617",path:"/pages/8f19aa/",headersStr:null,content:"异常处理流程：程序抛出异常，程序不会向下执行，除非异常被try...catch。",normalizedContent:"异常处理流程：程序抛出异常，程序不会向下执行，除非异常被try...catch。",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"ArrayList 源码分析及扩容机制",frontmatter:{title:"ArrayList 源码分析及扩容机制",date:"2023-10-23T23:54:27.000Z",permalink:"/pages/528ca4/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/03.Java/02.Java%20%E5%AE%B9%E5%99%A8/02.ArrayList%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6.html",relativePath:"01.Java 知识体系/03.Java/02.Java 容器/02.ArrayList 源码分析及扩容机制.md",key:"v-8a778884",path:"/pages/528ca4/",headers:[{level:1,title:"扩容机制",slug:"扩容机制",normalizedTitle:"扩容机制",charIndex:481}],headersStr:"扩容机制",content:"ArrayList类继承关系：\n\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n\n\n * RandomAccess：RandomAccess接口是一个标记接口，用以标记实现的List集合具备快速随机访问的能力。当一个List拥有快速随机访问功能时，其遍历方法采用for循环最快速。而没有快速随机访问功能的List，遍历的时候采用Iterator迭代器最快速。\n * Cloneable：支持克隆。\n * Serializable：支持序列化。保存数据的数组被transient 标记的字段不会被序列化，所以肯定自己实现了系列化（writeObject和readObject方法）\n\nArrayList的底层数据结构是数组。数据存放在Object[] elementData这个数组;\n\ntransient Object[] elementData;\n\n\n\n# 扩容机制\n\nArrayList 在初始化时，如果没有指定容量大小。那么默认初始容量就是10。\n\nprivate static final int DEFAULT_CAPACITY = 10;\npublic ArrayList() {\n\tthis.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n\n\n在第一次添加元素时\n\n public boolean add(E e) {\n     ensureCapacityInternal(size + 1);  // Increments modCount!!\n     elementData[size++] = e;\n     return true;\n}\n\n\nensureCapacityInternal方法里面进行扩容操作。\n\n private void ensureCapacityInternal(int minCapacity) {\n     ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n }\n\n\ncalculateCapacity方法计算所需要的容量，ensureExplicitCapacity方法判断是否需要扩容及进行扩容操作。\n\n当使用不指定容量的构造函数初始化，第一次执行calculateCapacity方法返回值就是DEFAULT_CAPACITY（也就是10）。\n\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n\n\n当所需容量minCapacity大于elementData的长度时，就会调用grow方法执行扩容操作。\n\n此时，elementData 数组长度为0,所以需要调用grow方法进行扩容。\n\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n\n    // overflow-conscious code\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n\n\ngrow方法会先计算要数组要扩容的容量，然后Arrays.copyOf方法将原先的数组数据浅拷贝到新的扩容数组里面。\n\n数组要扩容的容量的计算主要有两个判断：\n\n * 计算原先数组的容量，然后将这容量加上这个容量右移1位后的长度（近似1.5倍）。计算出的长度跟所需的最小容量进行比较，取两者最大值为newCapacity。\n * 然后newCapacity如果大于MAX_ARRAY_SIZE，那就调用hugeCapacity方法获取最大容量。否则newCapacity值不变。\n   * 如果所需的最小容量 minCapacity小于MAX_ARRAY_SIZE，那么newCapacity值为MAX_ARRAY_SIZE(Integer.MAX_VALUE - 8)。否则newCapacity值为Integer.MAX_VALUE（2^31-1）。\n\nprivate void grow(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = elementData.length;\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n\n\nprivate static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n",normalizedContent:"arraylist类继承关系：\n\npublic class arraylist<e> extends abstractlist<e>\n        implements list<e>, randomaccess, cloneable, java.io.serializable\n\n\n * randomaccess：randomaccess接口是一个标记接口，用以标记实现的list集合具备快速随机访问的能力。当一个list拥有快速随机访问功能时，其遍历方法采用for循环最快速。而没有快速随机访问功能的list，遍历的时候采用iterator迭代器最快速。\n * cloneable：支持克隆。\n * serializable：支持序列化。保存数据的数组被transient 标记的字段不会被序列化，所以肯定自己实现了系列化（writeobject和readobject方法）\n\narraylist的底层数据结构是数组。数据存放在object[] elementdata这个数组;\n\ntransient object[] elementdata;\n\n\n\n# 扩容机制\n\narraylist 在初始化时，如果没有指定容量大小。那么默认初始容量就是10。\n\nprivate static final int default_capacity = 10;\npublic arraylist() {\n\tthis.elementdata = defaultcapacity_empty_elementdata;\n}\n\n\n在第一次添加元素时\n\n public boolean add(e e) {\n     ensurecapacityinternal(size + 1);  // increments modcount!!\n     elementdata[size++] = e;\n     return true;\n}\n\n\nensurecapacityinternal方法里面进行扩容操作。\n\n private void ensurecapacityinternal(int mincapacity) {\n     ensureexplicitcapacity(calculatecapacity(elementdata, mincapacity));\n }\n\n\ncalculatecapacity方法计算所需要的容量，ensureexplicitcapacity方法判断是否需要扩容及进行扩容操作。\n\n当使用不指定容量的构造函数初始化，第一次执行calculatecapacity方法返回值就是default_capacity（也就是10）。\n\nprivate static int calculatecapacity(object[] elementdata, int mincapacity) {\n    if (elementdata == defaultcapacity_empty_elementdata) {\n        return math.max(default_capacity, mincapacity);\n    }\n    return mincapacity;\n}\n\n\n当所需容量mincapacity大于elementdata的长度时，就会调用grow方法执行扩容操作。\n\n此时，elementdata 数组长度为0,所以需要调用grow方法进行扩容。\n\nprivate void ensureexplicitcapacity(int mincapacity) {\n    modcount++;\n\n    // overflow-conscious code\n    if (mincapacity - elementdata.length > 0)\n        grow(mincapacity);\n}\n\n\ngrow方法会先计算要数组要扩容的容量，然后arrays.copyof方法将原先的数组数据浅拷贝到新的扩容数组里面。\n\n数组要扩容的容量的计算主要有两个判断：\n\n * 计算原先数组的容量，然后将这容量加上这个容量右移1位后的长度（近似1.5倍）。计算出的长度跟所需的最小容量进行比较，取两者最大值为newcapacity。\n * 然后newcapacity如果大于max_array_size，那就调用hugecapacity方法获取最大容量。否则newcapacity值不变。\n   * 如果所需的最小容量 mincapacity小于max_array_size，那么newcapacity值为max_array_size(integer.max_value - 8)。否则newcapacity值为integer.max_value（2^31-1）。\n\nprivate void grow(int mincapacity) {\n        // overflow-conscious code\n        int oldcapacity = elementdata.length;\n        int newcapacity = oldcapacity + (oldcapacity >> 1);\n        if (newcapacity - mincapacity < 0)\n            newcapacity = mincapacity;\n        if (newcapacity - max_array_size > 0)\n            newcapacity = hugecapacity(mincapacity);\n        // mincapacity is usually close to size, so this is a win:\n        elementdata = arrays.copyof(elementdata, newcapacity);\n    }\n\n\nprivate static int hugecapacity(int mincapacity) {\n        if (mincapacity < 0) // overflow\n            throw new outofmemoryerror();\n        return (mincapacity > max_array_size) ?\n            integer.max_value :\n            max_array_size;\n    }\n",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"HashMap 源码及底层数据结构分析",frontmatter:{title:"HashMap 源码及底层数据结构分析",date:"2023-10-23T23:54:27.000Z",permalink:"/pages/a794bb/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/03.Java/02.Java%20%E5%AE%B9%E5%99%A8/03.HashMap%20%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html",relativePath:"01.Java 知识体系/03.Java/02.Java 容器/03.HashMap 源码及底层数据结构分析.md",key:"v-6cc42844",path:"/pages/a794bb/",headers:[{level:1,title:"HashMap 简介",slug:"hashmap-简介",normalizedTitle:"hashmap 简介",charIndex:2},{level:1,title:"HashMap 底层数据结构分析",slug:"hashmap-底层数据结构分析",normalizedTitle:"hashmap 底层数据结构分析",charIndex:479},{level:2,title:"JDK1.8之前",slug:"jdk1-8之前",normalizedTitle:"jdk1.8之前",charIndex:500},{level:2,title:"JDK1.8之后",slug:"jdk1-8之后",normalizedTitle:"jdk1.8之后",charIndex:164},{level:1,title:"HashMap 源码分析",slug:"hashmap-源码分析",normalizedTitle:"hashmap 源码分析",charIndex:1033},{level:2,title:"成员属性",slug:"成员属性",normalizedTitle:"成员属性",charIndex:1050},{level:2,title:"内存静态类",slug:"内存静态类",normalizedTitle:"内存静态类",charIndex:2631},{level:2,title:"构造方法",slug:"构造方法",normalizedTitle:"构造方法",charIndex:4566},{level:2,title:"put 方法",slug:"put-方法",normalizedTitle:"put 方法",charIndex:6424},{level:2,title:"get 方法",slug:"get-方法",normalizedTitle:"get 方法",charIndex:9097},{level:2,title:"resize 方法",slug:"resize-方法",normalizedTitle:"resize 方法",charIndex:10067}],headersStr:"HashMap 简介 HashMap 底层数据结构分析 JDK1.8之前 JDK1.8之后 HashMap 源码分析 成员属性 内存静态类 构造方法 put 方法 get 方法 resize 方法",content:'# HashMap 简介\n\nHashMap 是存储键值对的，基于哈希表的Map接口实现的，是线程不安全的。\n\nHashMap可以存储Null键和Null值。但是Null键只能有一个，Null值可以有很多个。\n\nJDK1.8 之前HashMap由数组+链表组成。数组是存储数据的主体，链表是为了解决哈希冲突而存在的（拉链法）。\n\nJDK1.8之后HashMap有数组+链表+红黑树组成。当链表个数大于阈值（默认为8）时，会先判断当前数组长度是否小于64，如果小于64，就先扩容数组，而不转换成红黑树，如果大于等于，就转换成红黑树，以减少搜索时间。\n\nHashMap 默认的初始化容量大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， HashMap 总是使用 2 的幂作为哈希表的大小。\n\n什么是桶？\n\nHashMap的底层数组中可以存储元素的位置被称为“桶（bucket）。\n\n拉链法是什么？\n\n所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\n\n\n\n\n# HashMap 底层数据结构分析\n\n\n# JDK1.8之前\n\nJDK1.8之前HashMap底层是数组和链表。\n\nHashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。\n\n什么是扰动函数？\n\n所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。\n\n\n# JDK1.8之后\n\nJDK1.8之后HashMap底层是数组+链表+红黑树。\n\n相比于之前的版本，JDK1.8 以后在解决哈希冲突时有了较大的变化。\n\n当链表长度大于阈值（默认为 8）时，会首先调用 treeifyBin()方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 resize() 方法对数组扩容。\n\n\n\n\n# HashMap 源码分析\n\n\n# 成员属性\n\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable {\n    // 序列号\n    private static final long serialVersionUID = 362498820763181265L;\n    //默认的初始容量-必须是二的幂次方。这里为16\n\tstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n    //最大容量，如果其中一个带有参数的构造函数隐式指定了更高的值，则使用该容量,而不是要指定的值。必须是二的幂次方\n    static final int MAXIMUM_CAPACITY = 1 << 30;\n\t//默认的加载因子\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\t//当桶(bucket)上的结点数大于这个值时会转成红黑树.该值必须大于2，并且应至少为8\n    static final int TREEIFY_THRESHOLD = 8;\n    //当桶(bucket)上的结点数小于这个值时树转链表.应小于TREEIFY_THRESHOLD，且最多为6\n    static final int UNTREEIFY_THRESHOLD = 6;\n    //桶中结构转化为红黑树对应的table的最小大小.至少为4*TREEIFY_THRESHOLD\n    static final int MIN_TREEIFY_CAPACITY = 64;\n     // 存储元素的数组，总是2的幂次倍\n    transient Node<k,v>[] table;\n    // 存放具体元素的集\n    transient Set<map.entry<k,v>> entrySet;\n    // 存放元素的个数，注意这个不等于数组的长度。\n    transient int size;\n    // 每次扩容和更改map结构的计数器\n    transient int modCount;\n    // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容\n    int threshold;\n    // 加载因子\n    final float loadFactor;   \n}\n\n\n * loadFactor 加载因子\n   \n   * loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表 的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。\n   * loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。\n   * 给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。\n\n * threshold 临界值：threshold = capacity * loadFactor，当 Size>=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩容的一个标准。\n\n\n# 内存静态类\n\nNode 节点类源码:\n\n// 继承自 Map.Entry<K,V>\nstatic class Node<K,V> implements Map.Entry<K,V> {\n       final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较\n       final K key;//键\n       V value;//值\n       // 指向下一个节点\n       Node<K,V> next;\n       Node(int hash, K key, V value, Node<K,V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n        public final K getKey()        { return key; }\n        public final V getValue()      { return value; }\n        public final String toString() { return key + "=" + value; }\n        // 重写hashCode()方法\n        public final int hashCode() {\n            return Objects.hashCode(key) ^ Objects.hashCode(value);\n        }\n\n        public final V setValue(V newValue) {\n            V oldValue = value;\n            value = newValue;\n            return oldValue;\n        }\n        // 重写 equals() 方法\n        public final boolean equals(Object o) {\n            if (o == this)\n                return true;\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n                if (Objects.equals(key, e.getKey()) &&\n                    Objects.equals(value, e.getValue()))\n                    return true;\n            }\n            return false;\n        }\n}\n\n\n\n树节点类源码:\n\nstatic final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n        TreeNode<K,V> parent;  // 父\n        TreeNode<K,V> left;    // 左\n        TreeNode<K,V> right;   // 右\n        TreeNode<K,V> prev;    // needed to unlink next upon deletion\n        boolean red;           // 判断颜色\n        TreeNode(int hash, K key, V val, Node<K,V> next) {\n            super(hash, key, val, next);\n        }\n        // 返回根节点\n        final TreeNode<K,V> root() {\n            for (TreeNode<K,V> r = this, p;;) {\n                if ((p = r.parent) == null)\n                    return r;\n                r = p;\n       }\n\n\n\n\n# 构造方法\n\n    // 默认构造函数。\n    public HashMap() {\n        this.loadFactor = DEFAULT_LOAD_FACTOR; // all   other fields defaulted\n     }\n\n     // 包含另一个“Map”的构造函数\n     public HashMap(Map<? extends K, ? extends V> m) {\n         this.loadFactor = DEFAULT_LOAD_FACTOR;\n         putMapEntries(m, false);\n     }\n\n     // 指定“初始容量大小”的构造函数\n     public HashMap(int initialCapacity) {\n         this(initialCapacity, DEFAULT_LOAD_FACTOR);\n     }\n\n     // 指定“初始容量大小”和“加载因子”的构造函数\n     public HashMap(int initialCapacity, float loadFactor) {\n         if (initialCapacity < 0)\n             throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity);\n         if (initialCapacity > MAXIMUM_CAPACITY)\n             initialCapacity = MAXIMUM_CAPACITY;\n         if (loadFactor <= 0 || Float.isNaN(loadFactor))\n             throw new IllegalArgumentException("Illegal load factor: " + loadFactor);\n         this.loadFactor = loadFactor;\n         this.threshold = tableSizeFor(initialCapacity);\n     }\n\n\n\nputMapEntries 方法：\n\nfinal void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {\n    int s = m.size();\n    if (s > 0) {\n        // 判断table是否已经初始化\n        if (table == null) { // pre-size\n            // 未初始化，s为m的实际元素个数。计算出所需容量\n            float ft = ((float)s / loadFactor) + 1.0F;\n            int t = ((ft < (float)MAXIMUM_CAPACITY) ?\n                    (int)ft : MAXIMUM_CAPACITY);\n            // 计算得到的容量t大于临界值，则初始化临界值\n            if (t > threshold)\n                threshold = tableSizeFor(t);\n        }\n        // 已初始化，并且m元素个数大于临界值，进行扩容处理\n        else if (s > threshold)\n            resize();\n        // 将m中的所有元素添加至HashMap中\n        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n            K key = e.getKey();\n            V value = e.getValue();\n            putVal(hash(key), key, value, false, evict);\n        }\n    }\n}\n\n\n\n\n# put 方法\n\nHashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。\n\n对 putVal 方法添加元素的分析如下：\n\n 1. 如果定位到的数组位置没有元素 就直接插入。\n\n 2. 如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，并将旧的Value直接返回，如果 key 不相同，就判断 p 是否是一个树节点，如果是就叫这个元素添加到树中。如果不是就遍历链表插入(插入的是链表尾部)。\n\npublic V put(K key, V value) {\n\treturn putVal(hash(key), key, value, false, true);\n}\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    //table未初始化或者长度为0，就进行扩容\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    //(n - 1) & hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n\t//桶中已经存在元素\n    else {\n        Node<K,V> e; K k;\n        // 比较桶中第一个元素(数组中的结点)跟新添加元素的hash值相等，key相等\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            // 将第一个元素赋值给e，用e来记录\n            e = p;\n        // hash值不相等，即key不相等。并且为红黑树结点\n        else if (p instanceof TreeNode)\n            //添加元素到树中\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        //链表结点\n        else {\n            //使用尾插法插入数据到链表\n            for (int binCount = 0; ; ++binCount) {\n                // 到达链表的尾部\n                if ((e = p.next) == null) {\n                    //在尾部插入新结点\n                    p.next = newNode(hash, key, value, null);\n                    //当链表长度大于8（TREEIFY_THRESHOLD = 8）时。调用treeifyBin方法尝试转成红黑树.\n                    //当数组长度大于等于64时就转换成红黑树。否则将会扩容数组\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    // 跳出循环\n                    break;\n                }\n                // 判断链表中结点的key值与插入的元素的key值是否相等\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 相等，跳出循环\n                    break;\n                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表\n                p = e;\n            }\n        }\n        // 表示在桶中找到key值、hash值与插入元素相等的结点\n        if (e != null) { // existing mapping for key\n            // 记录e的valu\n            V oldValue = e.value;\n            // onlyIfAbsent为false或者旧值为null\n            if (!onlyIfAbsent || oldValue == null)\n                //用新值替换旧值\n                e.value = value;\n            // 访问后回调\n            afterNodeAccess(e);\n            // 返回旧值\n            return oldValue;\n        }\n    }\n    ++modCount;\n    //元素个数大于临界值时，进行扩容。先添加元素再扩容 \n    if (++size > threshold)\n        resize();\n    // 插入后回调\n    afterNodeInsertion(evict);\n    return null;\n}\n\n\n\n# get 方法\n\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        // 数组元素相等\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        // 桶中不止一个节点\n        if ((e = first.next) != null) {\n            // 在树中get\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            // 在链表中get\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n\n\n\n\n# resize 方法\n\n进行扩容，扩容会产生性能消耗（Hash分配，遍历原hash表的所有元素，树的拆分），应该尽量避免resize。\n\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            //容量超过最大值就不再扩充\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            //没超过最大值，就扩充为用来的2倍\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // double threshold\n        }\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        else {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n    \t//计算新的resize上限（临界值）\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n        @SuppressWarnings({"rawtypes","unchecked"})\n            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) {\n            // 把每个bucket都移动到新的buckets中\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n',normalizedContent:'# hashmap 简介\n\nhashmap 是存储键值对的，基于哈希表的map接口实现的，是线程不安全的。\n\nhashmap可以存储null键和null值。但是null键只能有一个，null值可以有很多个。\n\njdk1.8 之前hashmap由数组+链表组成。数组是存储数据的主体，链表是为了解决哈希冲突而存在的（拉链法）。\n\njdk1.8之后hashmap有数组+链表+红黑树组成。当链表个数大于阈值（默认为8）时，会先判断当前数组长度是否小于64，如果小于64，就先扩容数组，而不转换成红黑树，如果大于等于，就转换成红黑树，以减少搜索时间。\n\nhashmap 默认的初始化容量大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， hashmap 总是使用 2 的幂作为哈希表的大小。\n\n什么是桶？\n\nhashmap的底层数组中可以存储元素的位置被称为“桶（bucket）。\n\n拉链法是什么？\n\n所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\n\n\n\n\n# hashmap 底层数据结构分析\n\n\n# jdk1.8之前\n\njdk1.8之前hashmap底层是数组和链表。\n\nhashmap 通过 key 的 hashcode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。\n\n什么是扰动函数？\n\n所谓扰动函数指的就是 hashmap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashcode() 方法 换句话说使用扰动函数之后可以减少碰撞。\n\n\n# jdk1.8之后\n\njdk1.8之后hashmap底层是数组+链表+红黑树。\n\n相比于之前的版本，jdk1.8 以后在解决哈希冲突时有了较大的变化。\n\n当链表长度大于阈值（默认为 8）时，会首先调用 treeifybin()方法。这个方法会根据 hashmap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 resize() 方法对数组扩容。\n\n\n\n\n# hashmap 源码分析\n\n\n# 成员属性\n\npublic class hashmap<k,v> extends abstractmap<k,v>\n    implements map<k,v>, cloneable, serializable {\n    // 序列号\n    private static final long serialversionuid = 362498820763181265l;\n    //默认的初始容量-必须是二的幂次方。这里为16\n\tstatic final int default_initial_capacity = 1 << 4; // aka 16\n    //最大容量，如果其中一个带有参数的构造函数隐式指定了更高的值，则使用该容量,而不是要指定的值。必须是二的幂次方\n    static final int maximum_capacity = 1 << 30;\n\t//默认的加载因子\n    static final float default_load_factor = 0.75f;\n\t//当桶(bucket)上的结点数大于这个值时会转成红黑树.该值必须大于2，并且应至少为8\n    static final int treeify_threshold = 8;\n    //当桶(bucket)上的结点数小于这个值时树转链表.应小于treeify_threshold，且最多为6\n    static final int untreeify_threshold = 6;\n    //桶中结构转化为红黑树对应的table的最小大小.至少为4*treeify_threshold\n    static final int min_treeify_capacity = 64;\n     // 存储元素的数组，总是2的幂次倍\n    transient node<k,v>[] table;\n    // 存放具体元素的集\n    transient set<map.entry<k,v>> entryset;\n    // 存放元素的个数，注意这个不等于数组的长度。\n    transient int size;\n    // 每次扩容和更改map结构的计数器\n    transient int modcount;\n    // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容\n    int threshold;\n    // 加载因子\n    final float loadfactor;   \n}\n\n\n * loadfactor 加载因子\n   \n   * loadfactor 加载因子是控制数组存放数据的疏密程度，loadfactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表 的长度增加，loadfactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。\n   * loadfactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadfactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。\n   * 给定的默认容量为 16，负载因子为 0.75。map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。\n\n * threshold 临界值：threshold = capacity * loadfactor，当 size>=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩容的一个标准。\n\n\n# 内存静态类\n\nnode 节点类源码:\n\n// 继承自 map.entry<k,v>\nstatic class node<k,v> implements map.entry<k,v> {\n       final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较\n       final k key;//键\n       v value;//值\n       // 指向下一个节点\n       node<k,v> next;\n       node(int hash, k key, v value, node<k,v> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n        public final k getkey()        { return key; }\n        public final v getvalue()      { return value; }\n        public final string tostring() { return key + "=" + value; }\n        // 重写hashcode()方法\n        public final int hashcode() {\n            return objects.hashcode(key) ^ objects.hashcode(value);\n        }\n\n        public final v setvalue(v newvalue) {\n            v oldvalue = value;\n            value = newvalue;\n            return oldvalue;\n        }\n        // 重写 equals() 方法\n        public final boolean equals(object o) {\n            if (o == this)\n                return true;\n            if (o instanceof map.entry) {\n                map.entry<?,?> e = (map.entry<?,?>)o;\n                if (objects.equals(key, e.getkey()) &&\n                    objects.equals(value, e.getvalue()))\n                    return true;\n            }\n            return false;\n        }\n}\n\n\n\n树节点类源码:\n\nstatic final class treenode<k,v> extends linkedhashmap.entry<k,v> {\n        treenode<k,v> parent;  // 父\n        treenode<k,v> left;    // 左\n        treenode<k,v> right;   // 右\n        treenode<k,v> prev;    // needed to unlink next upon deletion\n        boolean red;           // 判断颜色\n        treenode(int hash, k key, v val, node<k,v> next) {\n            super(hash, key, val, next);\n        }\n        // 返回根节点\n        final treenode<k,v> root() {\n            for (treenode<k,v> r = this, p;;) {\n                if ((p = r.parent) == null)\n                    return r;\n                r = p;\n       }\n\n\n\n\n# 构造方法\n\n    // 默认构造函数。\n    public hashmap() {\n        this.loadfactor = default_load_factor; // all   other fields defaulted\n     }\n\n     // 包含另一个“map”的构造函数\n     public hashmap(map<? extends k, ? extends v> m) {\n         this.loadfactor = default_load_factor;\n         putmapentries(m, false);\n     }\n\n     // 指定“初始容量大小”的构造函数\n     public hashmap(int initialcapacity) {\n         this(initialcapacity, default_load_factor);\n     }\n\n     // 指定“初始容量大小”和“加载因子”的构造函数\n     public hashmap(int initialcapacity, float loadfactor) {\n         if (initialcapacity < 0)\n             throw new illegalargumentexception("illegal initial capacity: " + initialcapacity);\n         if (initialcapacity > maximum_capacity)\n             initialcapacity = maximum_capacity;\n         if (loadfactor <= 0 || float.isnan(loadfactor))\n             throw new illegalargumentexception("illegal load factor: " + loadfactor);\n         this.loadfactor = loadfactor;\n         this.threshold = tablesizefor(initialcapacity);\n     }\n\n\n\nputmapentries 方法：\n\nfinal void putmapentries(map<? extends k, ? extends v> m, boolean evict) {\n    int s = m.size();\n    if (s > 0) {\n        // 判断table是否已经初始化\n        if (table == null) { // pre-size\n            // 未初始化，s为m的实际元素个数。计算出所需容量\n            float ft = ((float)s / loadfactor) + 1.0f;\n            int t = ((ft < (float)maximum_capacity) ?\n                    (int)ft : maximum_capacity);\n            // 计算得到的容量t大于临界值，则初始化临界值\n            if (t > threshold)\n                threshold = tablesizefor(t);\n        }\n        // 已初始化，并且m元素个数大于临界值，进行扩容处理\n        else if (s > threshold)\n            resize();\n        // 将m中的所有元素添加至hashmap中\n        for (map.entry<? extends k, ? extends v> e : m.entryset()) {\n            k key = e.getkey();\n            v value = e.getvalue();\n            putval(hash(key), key, value, false, evict);\n        }\n    }\n}\n\n\n\n\n# put 方法\n\nhashmap 只提供了 put 用于添加元素，putval 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。\n\n对 putval 方法添加元素的分析如下：\n\n 1. 如果定位到的数组位置没有元素 就直接插入。\n\n 2. 如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，并将旧的value直接返回，如果 key 不相同，就判断 p 是否是一个树节点，如果是就叫这个元素添加到树中。如果不是就遍历链表插入(插入的是链表尾部)。\n\npublic v put(k key, v value) {\n\treturn putval(hash(key), key, value, false, true);\n}\nfinal v putval(int hash, k key, v value, boolean onlyifabsent,\n                   boolean evict) {\n    node<k,v>[] tab; node<k,v> p; int n, i;\n    //table未初始化或者长度为0，就进行扩容\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    //(n - 1) & hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newnode(hash, key, value, null);\n\t//桶中已经存在元素\n    else {\n        node<k,v> e; k k;\n        // 比较桶中第一个元素(数组中的结点)跟新添加元素的hash值相等，key相等\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            // 将第一个元素赋值给e，用e来记录\n            e = p;\n        // hash值不相等，即key不相等。并且为红黑树结点\n        else if (p instanceof treenode)\n            //添加元素到树中\n            e = ((treenode<k,v>)p).puttreeval(this, tab, hash, key, value);\n        //链表结点\n        else {\n            //使用尾插法插入数据到链表\n            for (int bincount = 0; ; ++bincount) {\n                // 到达链表的尾部\n                if ((e = p.next) == null) {\n                    //在尾部插入新结点\n                    p.next = newnode(hash, key, value, null);\n                    //当链表长度大于8（treeify_threshold = 8）时。调用treeifybin方法尝试转成红黑树.\n                    //当数组长度大于等于64时就转换成红黑树。否则将会扩容数组\n                    if (bincount >= treeify_threshold - 1) // -1 for 1st\n                        treeifybin(tab, hash);\n                    // 跳出循环\n                    break;\n                }\n                // 判断链表中结点的key值与插入的元素的key值是否相等\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 相等，跳出循环\n                    break;\n                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表\n                p = e;\n            }\n        }\n        // 表示在桶中找到key值、hash值与插入元素相等的结点\n        if (e != null) { // existing mapping for key\n            // 记录e的valu\n            v oldvalue = e.value;\n            // onlyifabsent为false或者旧值为null\n            if (!onlyifabsent || oldvalue == null)\n                //用新值替换旧值\n                e.value = value;\n            // 访问后回调\n            afternodeaccess(e);\n            // 返回旧值\n            return oldvalue;\n        }\n    }\n    ++modcount;\n    //元素个数大于临界值时，进行扩容。先添加元素再扩容 \n    if (++size > threshold)\n        resize();\n    // 插入后回调\n    afternodeinsertion(evict);\n    return null;\n}\n\n\n\n# get 方法\n\npublic v get(object key) {\n    node<k,v> e;\n    return (e = getnode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal node<k,v> getnode(int hash, object key) {\n    node<k,v>[] tab; node<k,v> first, e; int n; k k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        // 数组元素相等\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        // 桶中不止一个节点\n        if ((e = first.next) != null) {\n            // 在树中get\n            if (first instanceof treenode)\n                return ((treenode<k,v>)first).gettreenode(hash, key);\n            // 在链表中get\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n\n\n\n\n# resize 方法\n\n进行扩容，扩容会产生性能消耗（hash分配，遍历原hash表的所有元素，树的拆分），应该尽量避免resize。\n\nfinal node<k,v>[] resize() {\n        node<k,v>[] oldtab = table;\n        int oldcap = (oldtab == null) ? 0 : oldtab.length;\n        int oldthr = threshold;\n        int newcap, newthr = 0;\n        if (oldcap > 0) {\n            //容量超过最大值就不再扩充\n            if (oldcap >= maximum_capacity) {\n                threshold = integer.max_value;\n                return oldtab;\n            }\n            //没超过最大值，就扩充为用来的2倍\n            else if ((newcap = oldcap << 1) < maximum_capacity &&\n                     oldcap >= default_initial_capacity)\n                newthr = oldthr << 1; // double threshold\n        }\n        else if (oldthr > 0) // initial capacity was placed in threshold\n            newcap = oldthr;\n        else {               // zero initial threshold signifies using defaults\n            newcap = default_initial_capacity;\n            newthr = (int)(default_load_factor * default_initial_capacity);\n        }\n    \t//计算新的resize上限（临界值）\n        if (newthr == 0) {\n            float ft = (float)newcap * loadfactor;\n            newthr = (newcap < maximum_capacity && ft < (float)maximum_capacity ?\n                      (int)ft : integer.max_value);\n        }\n        threshold = newthr;\n        @suppresswarnings({"rawtypes","unchecked"})\n            node<k,v>[] newtab = (node<k,v>[])new node[newcap];\n        table = newtab;\n        if (oldtab != null) {\n            // 把每个bucket都移动到新的buckets中\n            for (int j = 0; j < oldcap; ++j) {\n                node<k,v> e;\n                if ((e = oldtab[j]) != null) {\n                    oldtab[j] = null;\n                    if (e.next == null)\n                        newtab[e.hash & (newcap - 1)] = e;\n                    else if (e instanceof treenode)\n                        ((treenode<k,v>)e).split(this, newtab, j, oldcap);\n                    else { // preserve order\n                        node<k,v> lohead = null, lotail = null;\n                        node<k,v> hihead = null, hitail = null;\n                        node<k,v> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldcap) == 0) {\n                                if (lotail == null)\n                                    lohead = e;\n                                else\n                                    lotail.next = e;\n                                lotail = e;\n                            }\n                            else {\n                                if (hitail == null)\n                                    hihead = e;\n                                else\n                                    hitail.next = e;\n                                hitail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (lotail != null) {\n                            lotail.next = null;\n                            newtab[j] = lohead;\n                        }\n                        if (hitail != null) {\n                            hitail.next = null;\n                            newtab[j + oldcap] = hihead;\n                        }\n                    }\n                }\n            }\n        }\n        return newtab;\n    }\n',charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"并发编程基础",frontmatter:{title:"并发编程基础",date:"2023-10-23T23:54:39.000Z",permalink:"/pages/571a8d/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/03.Java/03.Java%20%E5%B9%B6%E5%8F%91/01.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html",relativePath:"01.Java 知识体系/03.Java/03.Java 并发/01.并发编程基础.md",key:"v-0322d41e",path:"/pages/571a8d/",headers:[{level:1,title:"并发编程三个特性",slug:"并发编程三个特性",normalizedTitle:"并发编程三个特性",charIndex:2},{level:1,title:"进程和线程",slug:"进程和线程",normalizedTitle:"进程和线程",charIndex:187},{level:1,title:"并发与并行",slug:"并发与并行",normalizedTitle:"并发与并行",charIndex:352},{level:1,title:"同步和异步",slug:"同步和异步",normalizedTitle:"同步和异步",charIndex:443},{level:1,title:"用户线程和守护线程",slug:"用户线程和守护线程",normalizedTitle:"用户线程和守护线程",charIndex:527},{level:1,title:"线程的状态",slug:"线程的状态",normalizedTitle:"线程的状态",charIndex:652}],headersStr:"并发编程三个特性 进程和线程 并发与并行 同步和异步 用户线程和守护线程 线程的状态",content:"# 并发编程三个特性\n\n * 原子性：一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。\n * 可见性：当一个线程对共享变量进行修改，其他线程可以立即看到修改后的值。\n * 有序性：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。\n\n\n# 进程和线程\n\n * 进程：操作系统在运行一个程序时，就会为其创建一个进程。比如，启动一个 Java 程序，操作系统就会创建一个Java进程。\n * 线程：操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程里可以创建多个线程。这些线程都有自己的程序计数器、Java虚拟机栈、本地方法栈等，并且能够访问共享的内存变量。\n\n\n# 并发与并行\n\n * 并发：两个及两个以上的作业在同一时间段内执行。\n * 并行：两个及两个以上的作业在同一时刻执行。\n\n两者区分的关键点是：是否是同时执行，同时执行是并行。\n\n\n# 同步和异步\n\n * 同步：发出一个调用之后，在没有得到结果之前，该调用就不可以返回，一直等待。\n * 异步：发出一个调用后，不用等待结果返回，该调用直接返回。\n\n\n# 用户线程和守护线程\n\n * 用户线程：平时用到的普通线程。\n * 守护线程（Daemon 线程）：运行在后台，是一种特殊的线程，比如垃圾回收\n\n当主线程结束后，用户线程还在运行，JVM 存活。如果没有用户线程，都是守护线程，JVM 结束 。\n\n\n# 线程的状态\n\nThread.State保存了所有线程状态。\n\n * NEW：初始状态，线程被创建出来但没有被调用start()。\n * RUNNABLE：运行状态，线程被调用了start()等待运行的状态。\n * BLOCKED：阻塞状态，需要等待锁释放。\n * WAITING ：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）\n * TIMED_WAITING：超时等待状态，可以在指定的时间内自行返回而不是像WAITING那样一直等待。\n * TERMINATED：终止状态，表示该线程已经运行完毕。",normalizedContent:"# 并发编程三个特性\n\n * 原子性：一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。\n * 可见性：当一个线程对共享变量进行修改，其他线程可以立即看到修改后的值。\n * 有序性：代码在执行的过程中的先后顺序，java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。\n\n\n# 进程和线程\n\n * 进程：操作系统在运行一个程序时，就会为其创建一个进程。比如，启动一个 java 程序，操作系统就会创建一个java进程。\n * 线程：操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程里可以创建多个线程。这些线程都有自己的程序计数器、java虚拟机栈、本地方法栈等，并且能够访问共享的内存变量。\n\n\n# 并发与并行\n\n * 并发：两个及两个以上的作业在同一时间段内执行。\n * 并行：两个及两个以上的作业在同一时刻执行。\n\n两者区分的关键点是：是否是同时执行，同时执行是并行。\n\n\n# 同步和异步\n\n * 同步：发出一个调用之后，在没有得到结果之前，该调用就不可以返回，一直等待。\n * 异步：发出一个调用后，不用等待结果返回，该调用直接返回。\n\n\n# 用户线程和守护线程\n\n * 用户线程：平时用到的普通线程。\n * 守护线程（daemon 线程）：运行在后台，是一种特殊的线程，比如垃圾回收\n\n当主线程结束后，用户线程还在运行，jvm 存活。如果没有用户线程，都是守护线程，jvm 结束 。\n\n\n# 线程的状态\n\nthread.state保存了所有线程状态。\n\n * new：初始状态，线程被创建出来但没有被调用start()。\n * runnable：运行状态，线程被调用了start()等待运行的状态。\n * blocked：阻塞状态，需要等待锁释放。\n * waiting ：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）\n * timed_waiting：超时等待状态，可以在指定的时间内自行返回而不是像waiting那样一直等待。\n * terminated：终止状态，表示该线程已经运行完毕。",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"Java 线程池详解",frontmatter:{title:"Java 线程池详解",date:"2023-10-23T23:54:39.000Z",permalink:"/pages/adbda5/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/03.Java/03.Java%20%E5%B9%B6%E5%8F%91/02.Java%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3.html",relativePath:"01.Java 知识体系/03.Java/03.Java 并发/02.Java 线程池详解.md",key:"v-65476117",path:"/pages/adbda5/",headers:[{level:1,title:"线程池介绍",slug:"线程池介绍",normalizedTitle:"线程池介绍",charIndex:2},{level:1,title:"线程池创建的两种方式",slug:"线程池创建的两种方式",normalizedTitle:"线程池创建的两种方式",charIndex:301},{level:1,title:"ThreadPoolExecutor 类介绍",slug:"threadpoolexecutor-类介绍",normalizedTitle:"threadpoolexecutor 类介绍",charIndex:878},{level:2,title:"构造方法",slug:"构造方法",normalizedTitle:"构造方法",charIndex:952},{level:1,title:"线程池最佳实践",slug:"线程池最佳实践",normalizedTitle:"线程池最佳实践",charIndex:3020},{level:1,title:"Reference",slug:"reference",normalizedTitle:"reference",charIndex:3087}],headersStr:"线程池介绍 线程池创建的两种方式 ThreadPoolExecutor 类介绍 构造方法 线程池最佳实践 Reference",content:"# 线程池介绍\n\n线程池就是管理一系列线程的资源池，其提供了一种限制和管理线程资源的方式。每个线程池还维护一些基本统计信息，例如已完成任务的数量。\n\n线程池的好处：\n\n * 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n * 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。\n * 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\n\n线程池一般用于执行多个不相关联的耗时任务，没有多线程的情况下，任务顺序执行，使用了线程池的话可让多个不相关联的任务同时执行。\n\n\n# 线程池创建的两种方式\n\n方式一：通过ThreadPoolExecutor构造函数来创建（推荐）。\n\n\n\n方式二：通过 Executor 框架的工具类 Executors 来创建。\n\n我们可以创建多种类型的 ThreadPoolExecutor：\n\n * FixedThreadPool：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。\n * SingleThreadExecutor： 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。\n * CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。\n * ScheduledThreadPool：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。\n\n对应 Executors 工具类中的方法如图所示：\n\n\n\n\n# ThreadPoolExecutor 类介绍\n\n线程池实现类 ThreadPoolExecutor 是 Executor 框架最核心的类。\n\n\n# 构造方法\n\nThreadPoolExecutor 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生\n\n/**\n * 用给定的初始参数创建一个新的ThreadPoolExecutor。\n */\npublic ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量\n                          int maximumPoolSize,//线程池的最大线程数\n                          long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间\n                          TimeUnit unit,//时间单位\n                          BlockingQueue<Runnable> workQueue,//任务队列，用来储存等待执行任务的队列\n                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可\n                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务\n                           ) {\n    if (corePoolSize < 0 ||\n        maximumPoolSize <= 0 ||\n        maximumPoolSize < corePoolSize ||\n        keepAliveTime < 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.corePoolSize = corePoolSize;\n    this.maximumPoolSize = maximumPoolSize;\n    this.workQueue = workQueue;\n    this.keepAliveTime = unit.toNanos(keepAliveTime);\n    this.threadFactory = threadFactory;\n    this.handler = handler;\n}\n\n\nThreadPoolExecutor 3 个最重要的参数：\n\n * corePoolSize : 任务队列未达到队列容量时，最大可以同时运行的线程数量。\n * maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。\n * workQueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。\n\nThreadPoolExecutor其他常见参数 :\n\n * keepAliveTime:线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁。\n * unit : keepAliveTime 参数的时间单位。\n * threadFactory :executor 创建新线程的时候会用到。\n * handler :饱和策略。\n\n\n\nThreadPoolExecutor 饱和策略定义:\n\n如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，ThreadPoolTaskExecutor 定义一些策略:\n\n * ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。\n * ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。\n * ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉。\n * ThreadPoolExecutor.DiscardOldestPolicy：此策略将丢弃最早的未处理的任务请求。\n\n\n# 线程池最佳实践\n\nJava 线程池最佳实践这篇文章总结了一些使用线程池的时候应该注意的东西，实际项目使用线程池之前可以看看。\n\n\n# Reference\n\n * https://javaguide.cn/java/concurrent/java-thread-pool-summary.html",normalizedContent:"# 线程池介绍\n\n线程池就是管理一系列线程的资源池，其提供了一种限制和管理线程资源的方式。每个线程池还维护一些基本统计信息，例如已完成任务的数量。\n\n线程池的好处：\n\n * 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n * 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。\n * 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\n\n线程池一般用于执行多个不相关联的耗时任务，没有多线程的情况下，任务顺序执行，使用了线程池的话可让多个不相关联的任务同时执行。\n\n\n# 线程池创建的两种方式\n\n方式一：通过threadpoolexecutor构造函数来创建（推荐）。\n\n\n\n方式二：通过 executor 框架的工具类 executors 来创建。\n\n我们可以创建多种类型的 threadpoolexecutor：\n\n * fixedthreadpool：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。\n * singlethreadexecutor： 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。\n * cachedthreadpool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。\n * scheduledthreadpool：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。\n\n对应 executors 工具类中的方法如图所示：\n\n\n\n\n# threadpoolexecutor 类介绍\n\n线程池实现类 threadpoolexecutor 是 executor 框架最核心的类。\n\n\n# 构造方法\n\nthreadpoolexecutor 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生\n\n/**\n * 用给定的初始参数创建一个新的threadpoolexecutor。\n */\npublic threadpoolexecutor(int corepoolsize,//线程池的核心线程数量\n                          int maximumpoolsize,//线程池的最大线程数\n                          long keepalivetime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间\n                          timeunit unit,//时间单位\n                          blockingqueue<runnable> workqueue,//任务队列，用来储存等待执行任务的队列\n                          threadfactory threadfactory,//线程工厂，用来创建线程，一般默认即可\n                          rejectedexecutionhandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务\n                           ) {\n    if (corepoolsize < 0 ||\n        maximumpoolsize <= 0 ||\n        maximumpoolsize < corepoolsize ||\n        keepalivetime < 0)\n        throw new illegalargumentexception();\n    if (workqueue == null || threadfactory == null || handler == null)\n        throw new nullpointerexception();\n    this.corepoolsize = corepoolsize;\n    this.maximumpoolsize = maximumpoolsize;\n    this.workqueue = workqueue;\n    this.keepalivetime = unit.tonanos(keepalivetime);\n    this.threadfactory = threadfactory;\n    this.handler = handler;\n}\n\n\nthreadpoolexecutor 3 个最重要的参数：\n\n * corepoolsize : 任务队列未达到队列容量时，最大可以同时运行的线程数量。\n * maximumpoolsize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。\n * workqueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。\n\nthreadpoolexecutor其他常见参数 :\n\n * keepalivetime:线程池中的线程数量大于 corepoolsize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepalivetime才会被回收销毁。\n * unit : keepalivetime 参数的时间单位。\n * threadfactory :executor 创建新线程的时候会用到。\n * handler :饱和策略。\n\n\n\nthreadpoolexecutor 饱和策略定义:\n\n如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，threadpooltaskexecutor 定义一些策略:\n\n * threadpoolexecutor.abortpolicy：抛出 rejectedexecutionexception来拒绝新任务的处理。\n * threadpoolexecutor.callerrunspolicy：调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。\n * threadpoolexecutor.discardpolicy：不处理新任务，直接丢弃掉。\n * threadpoolexecutor.discardoldestpolicy：此策略将丢弃最早的未处理的任务请求。\n\n\n# 线程池最佳实践\n\njava 线程池最佳实践这篇文章总结了一些使用线程池的时候应该注意的东西，实际项目使用线程池之前可以看看。\n\n\n# reference\n\n * https://javaguide.cn/java/concurrent/java-thread-pool-summary.html",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"Java 锁",frontmatter:{title:"Java 锁",date:"2023-11-02T14:59:10.000Z",permalink:"/pages/737a52/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/03.Java/03.Java%20%E5%B9%B6%E5%8F%91/04.Java%20%E9%94%81.html",relativePath:"01.Java 知识体系/03.Java/03.Java 并发/04.Java 锁.md",key:"v-5ea26f44",path:"/pages/737a52/",headers:[{level:1,title:"synchronized 关键字",slug:"synchronized-关键字",normalizedTitle:"synchronized 关键字",charIndex:275},{level:2,title:"synchronized 锁升级",slug:"synchronized-锁升级",normalizedTitle:"synchronized 锁升级",charIndex:296},{level:3,title:"无锁",slug:"无锁",normalizedTitle:"无锁",charIndex:535},{level:3,title:"偏向锁",slug:"偏向锁",normalizedTitle:"偏向锁",charIndex:403},{level:4,title:"偏向锁撤销",slug:"偏向锁撤销",normalizedTitle:"偏向锁撤销",charIndex:816},{level:3,title:"轻量级锁",slug:"轻量级锁",normalizedTitle:"轻量级锁",charIndex:407},{level:3,title:"重量级锁",slug:"重量级锁",normalizedTitle:"重量级锁",charIndex:366},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1346},{level:1,title:"todo",slug:"todo",normalizedTitle:"todo",charIndex:1355}],headersStr:"synchronized 关键字 synchronized 锁升级 无锁 偏向锁 偏向锁撤销 轻量级锁 重量级锁 总结 todo",content:"Java 中有哪些锁?\n\nJava 的锁可以分为：\n\n * 悲观锁/乐观锁：线程是否需要锁定同步资源，锁住是悲观锁，不锁住是乐观锁\n * 共享锁/独占锁：多线程情况下，是否可以共享同一把锁，可以是共享锁，不可以是独占锁\n * 公平锁/非公平锁：多线程情况下，是否需要排队，排队是公平锁，尝试插队，插队失败后再排队是非公平锁\n * 可中断锁/非可中断锁：是否可以中断\n * 可重入锁/不可重入锁：同一个线程是否可以重复获取同一把锁，可以是可以重入锁，不可以是不可以重入锁。\n * 非自旋锁/自旋锁：等待锁的过程，阻塞是非自旋锁，自旋是自旋锁。\n\n\n# synchronized 关键字\n\n\n# synchronized 锁升级\n\n为什么要对 synchronized 进行锁升级？\n\nJDK1.6 之前 synchronized 属于重量级锁。\n\nJDK1.6 之后，为了减少获取锁和释放锁的性能消耗，引入了偏向锁和轻量级锁。\n\nsynchronized 锁升级过程：\n\n\n\nsynchronized 锁的原理：synchronized 用的锁是存在 Java 对象头里的 Mark Word 中，锁升级功能主要依赖 MarkWord 中偏向锁位和锁标志位。\n\n\n\n\n# 无锁\n\n未加锁对象的 Mark Word 中偏向锁位+锁标志位为001。\n\n\n# 偏向锁\n\n偏向锁：当锁一直被同一个线程获取到时，这个线程会一直拥有这把锁，直到发生锁竞争。\n\n偏向锁对象的 Mark Word 中偏向锁位+锁标志位为101，并且会记录拥有锁的线程对应的指针（通过 CAS 方式更新线程ID）。当线程尝试获取偏向锁时，会判断当前线程ID和对象头存储的线程ID是否一致，一致的话就无需重新获取锁。\n\n持有偏向锁的线程不会主动释放偏向锁。\n\nJVM 默认开启偏向锁，可以使用 JVM 参数 -XX:-UseBiasedLocking关闭偏向锁。\n\n# 偏向锁撤销\n\n当出现锁竞争时，持有偏向锁的线程才会撤销偏向锁。\n\n撤销偏向锁需要等待全局安全点（该时间点没有字节码在执行），同时检查持有偏向锁的线程是否还在执行：\n\n * 如果持有偏向锁的线程还在执行，这时会取消偏向锁升级为轻量级锁。轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。\n * 如果持有偏向锁的线程执行完成，持有偏向锁的线程会将对象头设置成无锁状态撤销偏向锁，竞争线程通过CAS更新对象头，获取偏向锁。\n\n\n\n\n# 轻量级锁\n\n轻量级锁对象的 Mark Word 中偏向锁位+锁标志位为000。\n\n轻量级锁是为了线程近乎交替执行同步块时提高性能。\n\n原持有偏向锁的线程获取轻量级锁，竞争线程 CAS 自旋等待获取锁。\n\n轻量级锁规定了自旋的次数，自旋到一定次数依然没有成功，会升级到重量级锁。\n\n为什么要规定自旋次数？\n\n因为线程自旋会消耗CPU，不限制次数的话，对CPU性能消耗过大。\n\n轻量级锁与偏向锁的区别？\n\n持有轻量级锁的线程执行完成会自动释放锁，而持有偏向锁的线程执行完不会主动释放锁。\n\n\n# 重量级锁\n\n重量级锁对象的 Mark Word 中偏向锁位+锁标志位为010。\n\n\n# 总结\n\n\n\n\n# todo\n\n问题：\n\n * 对象在内存中如何存储\n * CAS 概念\n * 锁自旋是什么",normalizedContent:"java 中有哪些锁?\n\njava 的锁可以分为：\n\n * 悲观锁/乐观锁：线程是否需要锁定同步资源，锁住是悲观锁，不锁住是乐观锁\n * 共享锁/独占锁：多线程情况下，是否可以共享同一把锁，可以是共享锁，不可以是独占锁\n * 公平锁/非公平锁：多线程情况下，是否需要排队，排队是公平锁，尝试插队，插队失败后再排队是非公平锁\n * 可中断锁/非可中断锁：是否可以中断\n * 可重入锁/不可重入锁：同一个线程是否可以重复获取同一把锁，可以是可以重入锁，不可以是不可以重入锁。\n * 非自旋锁/自旋锁：等待锁的过程，阻塞是非自旋锁，自旋是自旋锁。\n\n\n# synchronized 关键字\n\n\n# synchronized 锁升级\n\n为什么要对 synchronized 进行锁升级？\n\njdk1.6 之前 synchronized 属于重量级锁。\n\njdk1.6 之后，为了减少获取锁和释放锁的性能消耗，引入了偏向锁和轻量级锁。\n\nsynchronized 锁升级过程：\n\n\n\nsynchronized 锁的原理：synchronized 用的锁是存在 java 对象头里的 mark word 中，锁升级功能主要依赖 markword 中偏向锁位和锁标志位。\n\n\n\n\n# 无锁\n\n未加锁对象的 mark word 中偏向锁位+锁标志位为001。\n\n\n# 偏向锁\n\n偏向锁：当锁一直被同一个线程获取到时，这个线程会一直拥有这把锁，直到发生锁竞争。\n\n偏向锁对象的 mark word 中偏向锁位+锁标志位为101，并且会记录拥有锁的线程对应的指针（通过 cas 方式更新线程id）。当线程尝试获取偏向锁时，会判断当前线程id和对象头存储的线程id是否一致，一致的话就无需重新获取锁。\n\n持有偏向锁的线程不会主动释放偏向锁。\n\njvm 默认开启偏向锁，可以使用 jvm 参数 -xx:-usebiasedlocking关闭偏向锁。\n\n# 偏向锁撤销\n\n当出现锁竞争时，持有偏向锁的线程才会撤销偏向锁。\n\n撤销偏向锁需要等待全局安全点（该时间点没有字节码在执行），同时检查持有偏向锁的线程是否还在执行：\n\n * 如果持有偏向锁的线程还在执行，这时会取消偏向锁升级为轻量级锁。轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。\n * 如果持有偏向锁的线程执行完成，持有偏向锁的线程会将对象头设置成无锁状态撤销偏向锁，竞争线程通过cas更新对象头，获取偏向锁。\n\n\n\n\n# 轻量级锁\n\n轻量级锁对象的 mark word 中偏向锁位+锁标志位为000。\n\n轻量级锁是为了线程近乎交替执行同步块时提高性能。\n\n原持有偏向锁的线程获取轻量级锁，竞争线程 cas 自旋等待获取锁。\n\n轻量级锁规定了自旋的次数，自旋到一定次数依然没有成功，会升级到重量级锁。\n\n为什么要规定自旋次数？\n\n因为线程自旋会消耗cpu，不限制次数的话，对cpu性能消耗过大。\n\n轻量级锁与偏向锁的区别？\n\n持有轻量级锁的线程执行完成会自动释放锁，而持有偏向锁的线程执行完不会主动释放锁。\n\n\n# 重量级锁\n\n重量级锁对象的 mark word 中偏向锁位+锁标志位为010。\n\n\n# 总结\n\n\n\n\n# todo\n\n问题：\n\n * 对象在内存中如何存储\n * cas 概念\n * 锁自旋是什么",charsets:{cjk:!0},lastUpdated:"2023/11/14, 06:07:13",lastUpdatedTimestamp:1699942033e3},{title:"CompletableFuture 详解",frontmatter:{title:"CompletableFuture 详解",date:"2023-10-23T23:54:39.000Z",permalink:"/pages/77c217/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/03.Java/03.Java%20%E5%B9%B6%E5%8F%91/03.CompletableFuture%20%E8%AF%A6%E8%A7%A3.html",relativePath:"01.Java 知识体系/03.Java/03.Java 并发/03.CompletableFuture 详解.md",key:"v-7dc35ca5",path:"/pages/77c217/",headers:[{level:1,title:"Future 介绍",slug:"future-介绍",normalizedTitle:"future 介绍",charIndex:332},{level:1,title:"CompletableFuture 介绍",slug:"completablefuture-介绍",normalizedTitle:"completablefuture 介绍",charIndex:1336},{level:1,title:"CompletableFuture 常见操作",slug:"completablefuture-常见操作",normalizedTitle:"completablefuture 常见操作",charIndex:2281},{level:2,title:"创建 CompletableFuture",slug:"创建-completablefuture",normalizedTitle:"创建 completablefuture",charIndex:2308},{level:2,title:"处理异步结算的结果",slug:"处理异步结算的结果",normalizedTitle:"处理异步结算的结果",charIndex:2876},{level:3,title:"thenApply()",slug:"thenapply",normalizedTitle:"thenapply()",charIndex:2935},{level:3,title:"thenAccept() 和 thenRun()",slug:"thenaccept-和thenrun",normalizedTitle:"thenaccept() 和 thenrun()",charIndex:null},{level:3,title:"whenComplete()",slug:"whencomplete",normalizedTitle:"whencomplete()",charIndex:2979},{level:2,title:"异常处理",slug:"异常处理",normalizedTitle:"异常处理",charIndex:4110},{level:2,title:"组合 CompletableFuture",slug:"组合-completablefuture",normalizedTitle:"组合 completablefuture",charIndex:5173},{level:3,title:"thenCompose()和thenCombine（）",slug:"thencompose-和thencombine",normalizedTitle:"thencompose()和thencombine（）",charIndex:5198},{level:2,title:"并行运行多个 CompletableFuture",slug:"并行运行多个-completablefuture",normalizedTitle:"并行运行多个 completablefuture",charIndex:6153},{level:1,title:"CompletableFuture 使用建议",slug:"completablefuture-使用建议",normalizedTitle:"completablefuture 使用建议",charIndex:7304},{level:2,title:"使用自定义线程池",slug:"使用自定义线程池",normalizedTitle:"使用自定义线程池",charIndex:2592},{level:2,title:"尽量避免使用 get()",slug:"尽量避免使用-get",normalizedTitle:"尽量避免使用 get()",charIndex:7743},{level:2,title:"正确进行异常处理",slug:"正确进行异常处理",normalizedTitle:"正确进行异常处理",charIndex:8444},{level:1,title:"Reference",slug:"reference",normalizedTitle:"reference",charIndex:8789}],headersStr:"Future 介绍 CompletableFuture 介绍 CompletableFuture 常见操作 创建 CompletableFuture 处理异步结算的结果 thenApply() thenAccept() 和 thenRun() whenComplete() 异常处理 组合 CompletableFuture thenCompose()和thenCombine（） 并行运行多个 CompletableFuture CompletableFuture 使用建议 使用自定义线程池 尽量避免使用 get() 正确进行异常处理 Reference",content:'一个接口可能需要调用 N 个其他服务的接口，这在项目开发中还是挺常见的。举个例子：用户请求获取订单信息，可能需要调用用户信息、商品详情、物流信息、商品推荐等接口，最后再汇总数据统一返回。\n\n如果是串行（按顺序依次执行每个任务）执行的话，接口的响应速度会非常慢。考虑到这些接口之间有大部分都是 无前后顺序关联 的，可以 并行执行 ，就比如说调用获取商品详情的时候，可以同时调用获取物流信息。通过并行执行多个任务的方式，接口的响应速度会得到大幅优化。\n\n\n\n对于存在前后顺序关系的接口调用，可以进行编排，如下图所示。\n\n\n\n对于 Java 程序来说，Java 8 才被引入的 CompletableFuture 可以帮助我们来做多个任务的编排，功能非常强大。\n\n\n# Future 介绍\n\nFuture 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。\n\n这其实就是多线程中经典的 Future 模式，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。\n\n在 Java 中，Future 类只是一个泛型接口，位于 java.util.concurrent 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：\n\n * 取消任务；\n * 判断任务是否被取消;\n * 判断任务是否已经执行完成;\n * 获取任务执行结果。\n\n// V 代表了Future执行的任务返回值的类型\npublic interface Future<V> {\n    // 取消任务执行\n    // 成功取消返回 true，否则返回 false\n    boolean cancel(boolean mayInterruptIfRunning);\n    // 判断任务是否被取消\n    boolean isCancelled();\n    // 判断任务是否已经执行完成\n    boolean isDone();\n    // 获取任务执行结果\n    V get() throws InterruptedException, ExecutionException;\n    // 指定时间内没有返回计算结果就抛出 TimeOutException 异常\n    V get(long timeout, TimeUnit unit)\n\n        throws InterruptedException, ExecutionException, TimeoutExceptio\n\n}\n\n\n\n简单理解就是：我有一个任务，提交给了 Future 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 Future 那里直接取出任务执行结果。\n\n\n# CompletableFuture 介绍\n\nFuture 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 get() 方法为阻塞调用。\n\nJava 8 才被引入CompletableFuture 类可以解决Future 的这些缺陷。CompletableFuture 除了提供了更为好用和强大的 Future 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。\n\n下面我们来简单看看 CompletableFuture 类的定义。\n\npublic class CompletableFuture<T> implements Future<T>, CompletionStage<T> {\n}\n\n\n\n可以看到，CompletableFuture 同时实现了 Future 和 CompletionStage 接口。\n\n\n\nCompletionStage 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。\n\nCompletableFuture 除了提供了更为好用和强大的 Future 特性之外，还提供了函数式编程的能力。\n\n\n\nFuture 接口有 5 个方法：\n\n * boolean cancel(boolean mayInterruptIfRunning)：尝试取消执行任务。\n * boolean isCancelled()：判断任务是否被取消。\n * boolean isDone()：判断任务是否已经被执行完成。\n * get()：等待任务执行完成并获取运算结果。\n * get(long timeout, TimeUnit unit)：多了一个超时时间。\n\nCompletionStage 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。\n\nCompletionStage 接口中的方法比较多，CompletableFuture 的函数式能力就是这个接口赋予的。从这个接口的方法参数你就可以发现其大量使用了 Java8 引入的函数式编程。\n\n\n\n\n# CompletableFuture 常见操作\n\n\n# 创建 CompletableFuture\n\n 1. 通过 new 关键字。\n    \n    CompletableFuture<RpcResponse<Object>> resultFuture = new CompletableFuture<>();\n    \n    \n\n 2. 基于 CompletableFuture 自带的静态工厂方法：runAsync()、supplyAsync() 。\n    \n    static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier);\n    // 使用自定义线程池(推荐)\n    static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor);\n    static CompletableFuture<Void> runAsync(Runnable runnable);\n    // 使用自定义线程池(推荐)\n    static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor);\n    \n    \n\n\n# 处理异步结算的结果\n\n当我们获取到异步计算的结果之后，还可以对其进行进一步的处理，比较常用的方法有下面几个：\n\n * thenApply()\n * thenAccept()\n * thenRun()\n * whenComplete()\n\n\n# thenApply()\n\nthenApply() 方法接受一个 Function 实例，用它来处理结果。\n\nCompletableFuture<String> future = CompletableFuture.completedFuture("hello!")\n        .thenApply(s -> s + "world!");\nassertEquals("hello!world!", future.get());\n// 这次调用将被忽略。\nfuture.thenApply(s -> s + "nice!");\nassertEquals("hello!world!", future.get());\n\n\n\n\n# thenAccept()和thenRun()\n\n如果你不需要从回调函数中获取返回结果，可以使用 thenAccept() 或者 thenRun()。这两个方法的区别在于 thenRun() 不能访问异步计算的结果。\n\nCompletableFuture.completedFuture("hello!")\n        .thenApply(s -> s + "world!").thenApply(s -> s + "nice!").thenAccept(System.out::println);//hello!world!nice!\n\nCompletableFuture.completedFuture("hello!")\n        .thenApply(s -> s + "world!").thenApply(s -> s + "nice!").thenRun(() -> System.out.println("hello!"));//hello!\n\n\n\n\n# whenComplete()\n\nCompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "hello!")\n        .whenComplete((res, ex) -> {\n            // res 代表返回的结果\n            // ex 的类型为 Throwable ，代表抛出的异常\n            System.out.println(res);\n            // 这里没有抛出异常所有为 null\n            assertNull(ex);\n        });\nassertEquals("hello!", future.get());\n\n\n\n\n# 异常处理\n\n你可以通过 handle() 方法来处理任务执行过程中可能出现的抛出异常的情况。\n\nCompletableFuture<String> future\n        = CompletableFuture.supplyAsync(() -> {\n    if (true) {\n        throw new RuntimeException("Computation error!");\n    }\n    return "hello!";\n}).handle((res, ex) -> {\n    // res 代表返回的结果\n    // ex 的类型为 Throwable ，代表抛出的异常\n    return res != null ? res : "world!";\n});\nassertEquals("world!", future.get());\n\n\n\n还可以通过 exceptionally() 方法来处理异常情况。\n\nCompletableFuture<String> future\n        = CompletableFuture.supplyAsync(() -> {\n    if (true) {\n        throw new RuntimeException("Computation error!");\n    }\n    return "hello!";\n}).exceptionally(ex -> {\n    System.out.println(ex.toString());// CompletionException\n    return "world!";\n});\nassertEquals("world!", future.get());\n\n\n\n如果你想让 CompletableFuture 的结果就是异常的话，可以使用 completeExceptionally() 方法为其赋值。\n\nCompletableFuture<String> completableFuture = new CompletableFuture<>();\n// ...\ncompletableFuture.completeExceptionally(\n  new RuntimeException("Calculation failed!"));\n// ...\ncompletableFuture.get(); // ExecutionException\n\n\n\n\n# 组合 CompletableFuture\n\n\n# thenCompose()和thenCombine（）\n\n使用 thenCompose() 按顺序链接两个 CompletableFuture 对象，实现异步的任务链。它的作用是将前一个任务的返回结果作为下一个任务的输入参数，从而形成一个依赖关系。\n\nCompletableFuture<String> future\n        = CompletableFuture.supplyAsync(() -> "hello!")\n        .thenCompose(s -> CompletableFuture.supplyAsync(() -> s + "world!"));\nassertEquals("hello!world!", future.get());\n\n\n\n和 thenCompose() 方法类似的还有 thenCombine() 方法， 它同样可以组合两个 CompletableFuture 对象。\n\nCompletableFuture<String> completableFuture\n        = CompletableFuture.supplyAsync(() -> "hello!")\n        .thenCombine(CompletableFuture.supplyAsync(\n                () -> "world!"), (s1, s2) -> s1 + s2)\n        .thenCompose(s -> CompletableFuture.supplyAsync(() -> s + "nice!"));\nassertEquals("hello!world!nice!", completableFuture.get());\n\n\n\n那 thenCompose() 和 thenCombine() 有什么区别呢？\n\n * thenCompose() 可以链接两个 CompletableFuture 对象，并将前一个任务的返回结果作为下一个任务的参数，它们之间存在着先后顺序。\n\n * thenCombine() 会在两个任务都执行完成后，把两个任务的结果合并。两个任务是并行执行的，它们之间并没有先后依赖顺序。\n\n\n# 并行运行多个 CompletableFuture\n\n你可以通过 CompletableFuture 的 allOf()这个静态方法来并行运行多个 CompletableFuture 。\n\n实际项目中，我们经常需要并行运行多个互不相关的任务，这些任务之间没有依赖关系，可以互相独立地运行。\n\n比说我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。像这种情况我们就可以使用并行运行多个 CompletableFuture 来处理。\n\n示例代码如下：\n\nCompletableFuture<Void> task1 =\n  CompletableFuture.supplyAsync(()->{\n    //自定义业务操作\n  });\n......\nCompletableFuture<Void> task6 =\n  CompletableFuture.supplyAsync(()->{\n    //自定义业务操作\n  });\n......\n CompletableFuture<Void> headerFuture=CompletableFuture.allOf(task1,.....,task6);\n\n  try {\n    headerFuture.join();\n  } catch (Exception ex) {\n    ......\n  }\nSystem.out.println("all done. ");\n\n\n\n经常和 allOf() 方法拿来对比的是 anyOf() 方法。allOf() 方法会等到所有的 CompletableFuture 都运行完成之后再返回，调用 join() 可以让程序等future1 和 future2 都运行完了之后再继续执行。\n\nCompletableFuture<Void> completableFuture = CompletableFuture.allOf(future1, future2);\ncompletableFuture.join();\nassertTrue(completableFuture.isDone());\nSystem.out.println("all futures done...");\n\n\n\nanyOf() 方法不会等待所有的 CompletableFuture 都运行完成之后再返回，只要有一个执行完成即可！\n\nCompletableFuture<Object> f = CompletableFuture.anyOf(future1, future2);\nSystem.out.println(f.get());\n\n\n\n\n# CompletableFuture 使用建议\n\n\n# 使用自定义线程池\n\n我们上面的代码示例中，为了方便，都没有选择自定义线程池。实际项目中，这是不可取的。\n\nCompletableFuture 默认使用ForkJoinPool.commonPool() 作为执行器，这个线程池是全局共享的，可能会被其他任务占用，导致性能下降或者饥饿。因此，建议使用自定义的线程池来执行 CompletableFuture 的异步任务，可以提高并发度和灵活性。\n\nprivate ThreadPoolExecutor executor = new ThreadPoolExecutor(10, 10,\n        0L, TimeUnit.MILLISECONDS,\n        new LinkedBlockingQueue<Runnable>());\n\nCompletableFuture.runAsync(() -> {\n \t\t//...\n}, executor);\n\n\n\n\n# 尽量避免使用 get()\n\nCompletableFuture的get()方法是阻塞的，尽量避免使用。如果必须要使用的话，需要添加超时时间，否则可能会导致主线程一直等待，无法执行其他任务。\n\n    CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n        try {\n            Thread.sleep(10_000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return "Hello, world!";\n    });\n\n    // 获取异步任务的返回值，设置超时时间为 5 秒\n    try {\n        String result = future.get(5, TimeUnit.SECONDS);\n        System.out.println(result);\n    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n        // 处理异常\n        e.printStackTrace();\n    }\n}\n\n\n\n上面这段代码在调用 get() 时抛出了 TimeoutException 异常。这样我们就可以在异常处理中进行相应的操作，比如取消任务、重试任务、记录日志等。\n\n\n# 正确进行异常处理\n\n使用 CompletableFuture的时候一定要以正确的方式进行异常处理，避免异常丢失或者出现不可控问题。\n\n下面是一些建议：\n\n * 使用 whenComplete 方法可以在任务完成时触发回调函数，并正确地处理异常，而不是让异常被吞噬或丢失。\n * 使用 exceptionally 方法可以处理异常并重新抛出，以便异常能够传播到后续阶段，而不是让异常被忽略或终止。\n * 使用 handle 方法可以处理正常的返回结果和异常，并返回一个新的结果，而不是让异常影响正常的业务逻辑。\n * 使用 CompletableFuture.allOf 方法可以组合多个 CompletableFuture，并统一处理所有任务的异常，而不是让异常处理过于冗长或重复\n\n\n# Reference\n\n * CompletableFuture原理与实践-外卖商家端API的异步化 - 美团技术团队\n\n * CompletableFuture 详解 | JavaGuide(Java面试 + 学习指南)',normalizedContent:'一个接口可能需要调用 n 个其他服务的接口，这在项目开发中还是挺常见的。举个例子：用户请求获取订单信息，可能需要调用用户信息、商品详情、物流信息、商品推荐等接口，最后再汇总数据统一返回。\n\n如果是串行（按顺序依次执行每个任务）执行的话，接口的响应速度会非常慢。考虑到这些接口之间有大部分都是 无前后顺序关联 的，可以 并行执行 ，就比如说调用获取商品详情的时候，可以同时调用获取物流信息。通过并行执行多个任务的方式，接口的响应速度会得到大幅优化。\n\n\n\n对于存在前后顺序关系的接口调用，可以进行编排，如下图所示。\n\n\n\n对于 java 程序来说，java 8 才被引入的 completablefuture 可以帮助我们来做多个任务的编排，功能非常强大。\n\n\n# future 介绍\n\nfuture 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。\n\n这其实就是多线程中经典的 future 模式，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 java 语言独有。\n\n在 java 中，future 类只是一个泛型接口，位于 java.util.concurrent 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：\n\n * 取消任务；\n * 判断任务是否被取消;\n * 判断任务是否已经执行完成;\n * 获取任务执行结果。\n\n// v 代表了future执行的任务返回值的类型\npublic interface future<v> {\n    // 取消任务执行\n    // 成功取消返回 true，否则返回 false\n    boolean cancel(boolean mayinterruptifrunning);\n    // 判断任务是否被取消\n    boolean iscancelled();\n    // 判断任务是否已经执行完成\n    boolean isdone();\n    // 获取任务执行结果\n    v get() throws interruptedexception, executionexception;\n    // 指定时间内没有返回计算结果就抛出 timeoutexception 异常\n    v get(long timeout, timeunit unit)\n\n        throws interruptedexception, executionexception, timeoutexceptio\n\n}\n\n\n\n简单理解就是：我有一个任务，提交给了 future 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 future 那里直接取出任务执行结果。\n\n\n# completablefuture 介绍\n\nfuture 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 get() 方法为阻塞调用。\n\njava 8 才被引入completablefuture 类可以解决future 的这些缺陷。completablefuture 除了提供了更为好用和强大的 future 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。\n\n下面我们来简单看看 completablefuture 类的定义。\n\npublic class completablefuture<t> implements future<t>, completionstage<t> {\n}\n\n\n\n可以看到，completablefuture 同时实现了 future 和 completionstage 接口。\n\n\n\ncompletionstage 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。\n\ncompletablefuture 除了提供了更为好用和强大的 future 特性之外，还提供了函数式编程的能力。\n\n\n\nfuture 接口有 5 个方法：\n\n * boolean cancel(boolean mayinterruptifrunning)：尝试取消执行任务。\n * boolean iscancelled()：判断任务是否被取消。\n * boolean isdone()：判断任务是否已经被执行完成。\n * get()：等待任务执行完成并获取运算结果。\n * get(long timeout, timeunit unit)：多了一个超时时间。\n\ncompletionstage 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。\n\ncompletionstage 接口中的方法比较多，completablefuture 的函数式能力就是这个接口赋予的。从这个接口的方法参数你就可以发现其大量使用了 java8 引入的函数式编程。\n\n\n\n\n# completablefuture 常见操作\n\n\n# 创建 completablefuture\n\n 1. 通过 new 关键字。\n    \n    completablefuture<rpcresponse<object>> resultfuture = new completablefuture<>();\n    \n    \n\n 2. 基于 completablefuture 自带的静态工厂方法：runasync()、supplyasync() 。\n    \n    static <u> completablefuture<u> supplyasync(supplier<u> supplier);\n    // 使用自定义线程池(推荐)\n    static <u> completablefuture<u> supplyasync(supplier<u> supplier, executor executor);\n    static completablefuture<void> runasync(runnable runnable);\n    // 使用自定义线程池(推荐)\n    static completablefuture<void> runasync(runnable runnable, executor executor);\n    \n    \n\n\n# 处理异步结算的结果\n\n当我们获取到异步计算的结果之后，还可以对其进行进一步的处理，比较常用的方法有下面几个：\n\n * thenapply()\n * thenaccept()\n * thenrun()\n * whencomplete()\n\n\n# thenapply()\n\nthenapply() 方法接受一个 function 实例，用它来处理结果。\n\ncompletablefuture<string> future = completablefuture.completedfuture("hello!")\n        .thenapply(s -> s + "world!");\nassertequals("hello!world!", future.get());\n// 这次调用将被忽略。\nfuture.thenapply(s -> s + "nice!");\nassertequals("hello!world!", future.get());\n\n\n\n\n# thenaccept()和thenrun()\n\n如果你不需要从回调函数中获取返回结果，可以使用 thenaccept() 或者 thenrun()。这两个方法的区别在于 thenrun() 不能访问异步计算的结果。\n\ncompletablefuture.completedfuture("hello!")\n        .thenapply(s -> s + "world!").thenapply(s -> s + "nice!").thenaccept(system.out::println);//hello!world!nice!\n\ncompletablefuture.completedfuture("hello!")\n        .thenapply(s -> s + "world!").thenapply(s -> s + "nice!").thenrun(() -> system.out.println("hello!"));//hello!\n\n\n\n\n# whencomplete()\n\ncompletablefuture<string> future = completablefuture.supplyasync(() -> "hello!")\n        .whencomplete((res, ex) -> {\n            // res 代表返回的结果\n            // ex 的类型为 throwable ，代表抛出的异常\n            system.out.println(res);\n            // 这里没有抛出异常所有为 null\n            assertnull(ex);\n        });\nassertequals("hello!", future.get());\n\n\n\n\n# 异常处理\n\n你可以通过 handle() 方法来处理任务执行过程中可能出现的抛出异常的情况。\n\ncompletablefuture<string> future\n        = completablefuture.supplyasync(() -> {\n    if (true) {\n        throw new runtimeexception("computation error!");\n    }\n    return "hello!";\n}).handle((res, ex) -> {\n    // res 代表返回的结果\n    // ex 的类型为 throwable ，代表抛出的异常\n    return res != null ? res : "world!";\n});\nassertequals("world!", future.get());\n\n\n\n还可以通过 exceptionally() 方法来处理异常情况。\n\ncompletablefuture<string> future\n        = completablefuture.supplyasync(() -> {\n    if (true) {\n        throw new runtimeexception("computation error!");\n    }\n    return "hello!";\n}).exceptionally(ex -> {\n    system.out.println(ex.tostring());// completionexception\n    return "world!";\n});\nassertequals("world!", future.get());\n\n\n\n如果你想让 completablefuture 的结果就是异常的话，可以使用 completeexceptionally() 方法为其赋值。\n\ncompletablefuture<string> completablefuture = new completablefuture<>();\n// ...\ncompletablefuture.completeexceptionally(\n  new runtimeexception("calculation failed!"));\n// ...\ncompletablefuture.get(); // executionexception\n\n\n\n\n# 组合 completablefuture\n\n\n# thencompose()和thencombine（）\n\n使用 thencompose() 按顺序链接两个 completablefuture 对象，实现异步的任务链。它的作用是将前一个任务的返回结果作为下一个任务的输入参数，从而形成一个依赖关系。\n\ncompletablefuture<string> future\n        = completablefuture.supplyasync(() -> "hello!")\n        .thencompose(s -> completablefuture.supplyasync(() -> s + "world!"));\nassertequals("hello!world!", future.get());\n\n\n\n和 thencompose() 方法类似的还有 thencombine() 方法， 它同样可以组合两个 completablefuture 对象。\n\ncompletablefuture<string> completablefuture\n        = completablefuture.supplyasync(() -> "hello!")\n        .thencombine(completablefuture.supplyasync(\n                () -> "world!"), (s1, s2) -> s1 + s2)\n        .thencompose(s -> completablefuture.supplyasync(() -> s + "nice!"));\nassertequals("hello!world!nice!", completablefuture.get());\n\n\n\n那 thencompose() 和 thencombine() 有什么区别呢？\n\n * thencompose() 可以链接两个 completablefuture 对象，并将前一个任务的返回结果作为下一个任务的参数，它们之间存在着先后顺序。\n\n * thencombine() 会在两个任务都执行完成后，把两个任务的结果合并。两个任务是并行执行的，它们之间并没有先后依赖顺序。\n\n\n# 并行运行多个 completablefuture\n\n你可以通过 completablefuture 的 allof()这个静态方法来并行运行多个 completablefuture 。\n\n实际项目中，我们经常需要并行运行多个互不相关的任务，这些任务之间没有依赖关系，可以互相独立地运行。\n\n比说我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。像这种情况我们就可以使用并行运行多个 completablefuture 来处理。\n\n示例代码如下：\n\ncompletablefuture<void> task1 =\n  completablefuture.supplyasync(()->{\n    //自定义业务操作\n  });\n......\ncompletablefuture<void> task6 =\n  completablefuture.supplyasync(()->{\n    //自定义业务操作\n  });\n......\n completablefuture<void> headerfuture=completablefuture.allof(task1,.....,task6);\n\n  try {\n    headerfuture.join();\n  } catch (exception ex) {\n    ......\n  }\nsystem.out.println("all done. ");\n\n\n\n经常和 allof() 方法拿来对比的是 anyof() 方法。allof() 方法会等到所有的 completablefuture 都运行完成之后再返回，调用 join() 可以让程序等future1 和 future2 都运行完了之后再继续执行。\n\ncompletablefuture<void> completablefuture = completablefuture.allof(future1, future2);\ncompletablefuture.join();\nasserttrue(completablefuture.isdone());\nsystem.out.println("all futures done...");\n\n\n\nanyof() 方法不会等待所有的 completablefuture 都运行完成之后再返回，只要有一个执行完成即可！\n\ncompletablefuture<object> f = completablefuture.anyof(future1, future2);\nsystem.out.println(f.get());\n\n\n\n\n# completablefuture 使用建议\n\n\n# 使用自定义线程池\n\n我们上面的代码示例中，为了方便，都没有选择自定义线程池。实际项目中，这是不可取的。\n\ncompletablefuture 默认使用forkjoinpool.commonpool() 作为执行器，这个线程池是全局共享的，可能会被其他任务占用，导致性能下降或者饥饿。因此，建议使用自定义的线程池来执行 completablefuture 的异步任务，可以提高并发度和灵活性。\n\nprivate threadpoolexecutor executor = new threadpoolexecutor(10, 10,\n        0l, timeunit.milliseconds,\n        new linkedblockingqueue<runnable>());\n\ncompletablefuture.runasync(() -> {\n \t\t//...\n}, executor);\n\n\n\n\n# 尽量避免使用 get()\n\ncompletablefuture的get()方法是阻塞的，尽量避免使用。如果必须要使用的话，需要添加超时时间，否则可能会导致主线程一直等待，无法执行其他任务。\n\n    completablefuture<string> future = completablefuture.supplyasync(() -> {\n        try {\n            thread.sleep(10_000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        return "hello, world!";\n    });\n\n    // 获取异步任务的返回值，设置超时时间为 5 秒\n    try {\n        string result = future.get(5, timeunit.seconds);\n        system.out.println(result);\n    } catch (interruptedexception | executionexception | timeoutexception e) {\n        // 处理异常\n        e.printstacktrace();\n    }\n}\n\n\n\n上面这段代码在调用 get() 时抛出了 timeoutexception 异常。这样我们就可以在异常处理中进行相应的操作，比如取消任务、重试任务、记录日志等。\n\n\n# 正确进行异常处理\n\n使用 completablefuture的时候一定要以正确的方式进行异常处理，避免异常丢失或者出现不可控问题。\n\n下面是一些建议：\n\n * 使用 whencomplete 方法可以在任务完成时触发回调函数，并正确地处理异常，而不是让异常被吞噬或丢失。\n * 使用 exceptionally 方法可以处理异常并重新抛出，以便异常能够传播到后续阶段，而不是让异常被忽略或终止。\n * 使用 handle 方法可以处理正常的返回结果和异常，并返回一个新的结果，而不是让异常影响正常的业务逻辑。\n * 使用 completablefuture.allof 方法可以组合多个 completablefuture，并统一处理所有任务的异常，而不是让异常处理过于冗长或重复\n\n\n# reference\n\n * completablefuture原理与实践-外卖商家端api的异步化 - 美团技术团队\n\n * completablefuture 详解 | javaguide(java面试 + 学习指南)',charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"Java 8 新特性",frontmatter:{title:"Java 8 新特性",date:"2023-10-23T23:54:53.000Z",permalink:"/pages/b6b76e/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/03.Java/04.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/01.Java8%20%E6%96%B0%E7%89%B9%E6%80%A7/01.Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7.html",relativePath:"01.Java 知识体系/03.Java/04.Java 新特性/01.Java8 新特性/01.Java 8 新特性.md",key:"v-770d0f42",path:"/pages/b6b76e/",headers:[{level:2,title:"接口的默认方法",slug:"接口的默认方法",normalizedTitle:"接口的默认方法",charIndex:2},{level:2,title:"Lambda表达式",slug:"lambda表达式",normalizedTitle:"lambda表达式",charIndex:227},{level:3,title:"表达式作用域",slug:"表达式作用域",normalizedTitle:"表达式作用域",charIndex:1071},{level:4,title:"访问局部变量",slug:"访问局部变量",normalizedTitle:"访问局部变量",charIndex:1081},{level:4,title:"访问成员变量和静态变量",slug:"访问成员变量和静态变量",normalizedTitle:"访问成员变量和静态变量",charIndex:1400},{level:4,title:"访问接口默认方法",slug:"访问接口默认方法",normalizedTitle:"访问接口默认方法",charIndex:1756},{level:2,title:"函数式接口",slug:"函数式接口",normalizedTitle:"函数式接口",charIndex:336},{level:3,title:"内置函数式接口",slug:"内置函数式接口",normalizedTitle:"内置函数式接口",charIndex:2517},{level:4,title:"Predicate",slug:"predicate",normalizedTitle:"predicate",charIndex:2528},{level:4,title:"Function",slug:"function",normalizedTitle:"function",charIndex:1916},{level:4,title:"Supplier",slug:"supplier",normalizedTitle:"supplier",charIndex:3376},{level:4,title:"Consumer",slug:"consumer",normalizedTitle:"consumer",charIndex:3570},{level:4,title:"Comparator",slug:"comparator",normalizedTitle:"comparator",charIndex:686},{level:2,title:"方法和构造函数引用",slug:"方法和构造函数引用",normalizedTitle:"方法和构造函数引用",charIndex:4093},{level:2,title:"Optional",slug:"optional",normalizedTitle:"optional",charIndex:5368},{level:2,title:"Stream",slug:"stream",normalizedTitle:"stream",charIndex:5895},{level:3,title:"Filter(过滤)",slug:"filter-过滤",normalizedTitle:"filter(过滤)",charIndex:6456},{level:3,title:"Sorted(排序)",slug:"sorted-排序",normalizedTitle:"sorted(排序)",charIndex:6714},{level:3,title:"Map(映射)",slug:"map-映射",normalizedTitle:"map(映射)",charIndex:7202},{level:3,title:"Match(匹配)",slug:"match-匹配",normalizedTitle:"match(匹配)",charIndex:7572},{level:3,title:"Count(计数)",slug:"count-计数",normalizedTitle:"count(计数)",charIndex:7916},{level:3,title:"Reduce(规约)",slug:"reduce-规约",normalizedTitle:"reduce(规约)",charIndex:8018},{level:3,title:"最终流——collect方法",slug:"最终流-collect方法",normalizedTitle:"最终流——collect方法",charIndex:8816},{level:2,title:"Parallel Streams(并行流)",slug:"parallel-streams-并行流",normalizedTitle:"parallel streams(并行流)",charIndex:9075},{level:2,title:"Maps",slug:"maps",normalizedTitle:"maps",charIndex:9938},{level:3,title:"putIfAbsent",slug:"putifabsent",normalizedTitle:"putifabsent",charIndex:10070},{level:3,title:"computeIfAbsent和computeIfPresent",slug:"computeifabsent和computeifpresent",normalizedTitle:"computeifabsent和computeifpresent",charIndex:10521},{level:3,title:"remove",slug:"remove",normalizedTitle:"remove",charIndex:11228},{level:3,title:"getOrDefault",slug:"getordefault",normalizedTitle:"getordefault",charIndex:11340},{level:3,title:"merge",slug:"merge",normalizedTitle:"merge",charIndex:11448}],headersStr:"接口的默认方法 Lambda表达式 表达式作用域 访问局部变量 访问成员变量和静态变量 访问接口默认方法 函数式接口 内置函数式接口 Predicate Function Supplier Consumer Comparator 方法和构造函数引用 Optional Stream Filter(过滤) Sorted(排序) Map(映射) Match(匹配) Count(计数) Reduce(规约) 最终流——collect方法 Parallel Streams(并行流) Maps putIfAbsent computeIfAbsent和computeIfPresent remove getOrDefault merge",content:'# 接口的默认方法\n\nJava8能够通过default关键字给接口添加默认方法。也称为虚拟扩展方法。\n\npackage java8.defaultmethod;\n\npublic interface Formula {\n    double calculate(int a);\n\n    //接口默认方法\n    default double sqrt(int a) {\n        return Math.sqrt(a);\n    }\n}\n\n\n\n# Lambda表达式\n\nLambda 表达式可以简洁地表示一个行为或者传递代码。Lambda 表达式可以看成匿名函数，和匿名类一样，它也能作为参数传递给一个方法。\n\nLambda 表达式有三个部分：\n\n * 参数列表——函数式接口的唯一抽象方法的参数\n * 箭头——箭头->把参数列表与 Lambda 主体分隔开。\n * Lambda 主体——函数式接口唯一抽象方法的方法体\n\n\n\nLambda 的基本语法：\n\n * 表达式-风格\n   \n   (parameters) -> expression\n   \n\n * 块-风格\n   \n   (parameters) -> { statements; }\n   \n\n使用Lambda必须具有接口，并且接口中的抽象方法只有一个。\n\nJava8之前排序字符串\n\n List<String> names = Arrays.asList("peter", "anna", "mike", "xenia");\n        Collections.sort(names, new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                return o1.compareTo(o2);\n            }\n        });\n\n\nJava8使用Lambda表达式排序字符串\n\n Collections.sort(names, (String a, String b) -> {\n            return a.compareTo(b);\n        });\n\n\n函数体只有一行代码的，可以去掉大括号和return关键字，变的更简洁\n\n Collections.sort(names, (a, b) -> a.compareTo(b));\n\n\n\n# 表达式作用域\n\n# 访问局部变量\n\nlambda可以引用外部局部变量，但是引用的变量不能再修改（具有隐式final含义），不过引用的变量可以不声明final。\n\nint num = 1;\nArrays.asList(1, 2, 3).sort((a, b) -> {\n    //lambda表达式引用的变量不能再修改（具有隐式final含义），但是引用的变量可以不声明final\n    num = num + 2;  //Variable used in lambda expression should be final or effectively final \n    return a > b ? a : b;\n});\n        \n\n\n# 访问成员变量和静态变量\n\nlambda表达式可以读写成员变量和静态变量\n\npublic class LambdaScope {\n    static int outerStaticNum;\n    int outerNum;\n\n    void testScope() {\n        //lambda表达式可以读写成员变量和静态变量\n        Coverter<Integer, String> outerCoverter = (from) -> {\n            outerNum = 21;\n            outerStaticNum = 32;\n            return String.valueOf(from);\n        };\n    }\n}\n\n\n# 访问接口默认方法\n\nlambda表达式无法访问接口默认方法。\n\n\n# 函数式接口\n\n为了使现有的函数友好支持Lambda表达式，增加函数式接口的概念。\n\n函数式接口是指仅仅包含一个抽象方法，但是可以有多个非抽象方法（也就是接口的默认方法）的接口。这种接口可以被隐式的转换成lambda表达式。\n\nJava8增加一个注解@FunctionalInterface声明是一个函数式接口，如果接口多于一个抽象方法，编译器就会报错。但是这个注解不是必须的，只要接口只包含一个抽象方法，虚拟机会自动判断该接口的为函数式接口。\n\n示例：\n\n/**\n * @FunctionalInterface声明是一个函数式接口，如果接口多于一个抽象方法，这个注解就会报错\n */\n@FunctionalInterface\npublic interface Coverter<F, T> {\n    T convert(F f);\n}\nCoverter<String, Integer> coverter = (s) -> Integer.valueOf(s);\nInteger convert = coverter.convert("33");\nSystem.out.println(convert.getClass());\n\n\n大部分函数式接口都不用自己写，Java8都实现好了，这些接口都放在java.util.function包里。\n\n注意： 如果一个接口中声明的抽象方法是重写了超类Object类中任意一个public方法，那么这些抽象方法并不会算入接口的抽象方法数量中。因为任何接口的实现都会从其父类Object或其它地方获得这些方法的实现。 比如Comparator接口有两个抽象方法，但是 equals并不算入抽象方法数量。\n\n\n# 内置函数式接口\n\n# Predicate\n\nPredicate接口是只有一个参数返回布尔类型值的断言型接口。该接口包含多种默认方法将Predicate组合成其他复杂的逻辑（比如：与、或、非）\n\nPredicate<String> predicate = (s) -> s.length() > 0;\nboolean testResult;\ntestResult = predicate.test("word"); //true\ntestResult = predicate.negate().test("word"); //false\nSystem.out.println(testResult);\n\nPredicate<String> isEmpty = String::isEmpty;\ntestResult = isEmpty.test(""); //true\nSystem.out.println(testResult);\n\nPredicate<String> isNotEmpty = isEmpty.negate();\ntestResult = isNotEmpty.test(""); //false\nSystem.out.println(testResult);\n\n\n# Function\n\nFunction 接口接收一个参数生成结果。默认方法（compose, andThen）可以将多个函数链接到一起。\n\nFunction<String, Integer> toInteger = Integer::valueOf;\nFunction<String, String> backToString = toInteger.andThen(String::valueOf);\nString applyStr = backToString.apply("23");\nSystem.out.println(applyStr.getClass()); //class java.lang.String\n\n\n# Supplier\n\nSupplier 接口产生给点泛型类型的结果，不接受任何参数\n\nSupplier<Person> personSupplier = Person::new;\nPerson person = personSupplier.get();\nSystem.out.println(person); //Person{name=\'null\', nike=\'null\'}\n\n\n# Consumer\n\nConsumer 接口表示要对单个输入参数执行的操作\n\nConsumer<Person> personConsumer = (p) -> System.out.println(p.nike);\npersonConsumer.accept(new Person("张三", "zhangsan")); //zhangsan\n\n\n# Comparator\n\nComparator 是老Java的经典接口，Java8添加了多种默认方法\n\nComparator<Person> personComparator = (p1, p2) -> p1.name.compareTo(p2.name);\nPerson p1 = new Person("John", "Doe");\nPerson p2 = new Person("Alice", "Wonderland");\nSystem.out.println(personComparator.compare(p1, p2)); //9\nSystem.out.println(personComparator.reversed().compare(p1, p2)); //-9\n\n\n\n# 方法和构造函数引用\n\nJava8支持通过::关键字传递方法或构造函数的引用。\n\n静态方法的引用：\n\nCoverter<String, Integer> coverter = Integer::valueOf;\nInteger convert = coverter.convert("22");\nSystem.out.println(convert.getClass());\n\n\n对象方法引用：\n\npackage java8.references;\n\npublic class SomeThing {\n    String startWith(String s) {\n        return String.valueOf(s.charAt(0));\n    }\n}\nSomeThing someThing = new SomeThing();\nCoverter<String, String> coverterStr = someThing::startWith;\nString firstChar = coverterStr.convert("lucky");\nSystem.out.println(firstChar);\n\n\n构造方法的引用：定义一个多构造方法的类\n\npackage java8.references;\n\npublic class Person {\n    String name;\n    String nike;\n\n    public Person() {\n    }\n\n    public Person(String name, String nike) {\n        this.name = name;\n        this.nike = nike;\n    }\n\n    @Override\n    public String toString() {\n        return "Person{" +\n                "name=\'" + name + \'\\\'\' +\n                ", nike=\'" + nike + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n定义一个创建Person对象的工厂接口\n\npublic interface PersonFactory<P extends Person> {\n    P create(String name, String nike);\n}\n\n\n通过Person::new将构造方法引用传给PersonFactory。Java编译器会自动根据create传递参数个数选择合适的构造方法。\n\nPersonFactory<Person> personPersonFactory = Person::new;\nPerson person = personPersonFactory.create("张", "三");\nSystem.out.println(person);\n\n\n\n# Optional\n\nOptional 是用来防止NullPointerException 的漂亮工具。 Optional 是一个简单的容器，其值可能是null或者不是null。在Java8应该返回Optional 而不是null。\n\n//为非空的值创建一个Optional\nOptional<String> optional = Optional.of("bdm");\n//如果值存在返回ture，否则返回false\nboolean present = optional.isPresent(); //true\n//如果有值将值返回，否则抛出NoSuchElementException异常\nString bdm = optional.get(); //bdm\n//如果有值将值返回，否则返回指定的其它值\nString orElseVal = optional.orElse("empty"); //bdm\n//如果Optional实例有值则为其调用consumer，否则不做处理\noptional.ifPresent((t) -> System.out.println("ifPresent:" + t)); //ifPresent:bdm\n\n\n\n# Stream\n\njava.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection 的子类，List 或者 Set， Map 不支持。Stream 的操作可以串行执行或者并行执行。\n\nJava 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。\n\n下面介绍Stream 常用方法，先准备数据\n\nList<String> stringList = new ArrayList<>();\nstringList.add("ddd2");\nstringList.add("aaa2");\nstringList.add("bbb1");\nstringList.add("aaa1");\nstringList.add("bbb3");\nstringList.add("ccc");\nstringList.add("bbb2");\nstringList.add("ddd1");\n\n\n\n# Filter(过滤)\n\n过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。\n\nstringList.stream().filter(s -> s.startsWith("a")).forEach(s -> System.out.println(s));\n\n\n\n# Sorted(排序)\n\nsorted（排序 ）是个中间操作，如果没有指定自定义Comparator的话，会使用默认排序。 排序之后原有的数据源不会改变。\n\n //sorted 排序 中间操作 如果没有指定Comparator的话，会使用默认排序 排序之后stringList不会改变\nstringList.stream().sorted().forEach(s -> System.out.println(s));\n\n\n多字段排序：\n\n//对象集合以类属性一降序 属性二升序\nlist.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()).thenComparing(类::属性二));\n\n\n\n区分：\n\n//方式一：先以属性一升序，再属性一降序排序\nComparator.comparing(类::属性一).reversed();\n//方式二：直接将属性一降序排序\nComparator.comparing(类::属性一,Comparator.reverseOrder());\n\n\n\n# Map(映射)\n\nmap是个中间操作，会将元素根据指定的 Function 接口依次将元素转成另外的对象。 返回的Stream类型是根据map传递进去的函数的返回值决定的。\n\nstringList.stream().map(String::toUpperCase).forEach(item -> System.out.println(item));\n\n\n给MenuInfo的字段赋值。\n\nList<MenuInfo> menuInfoList = menuInfoList.stream().map(e -> {\n            e.setMenuName(e.getMeunCode());\n            return e;\n        }).collect(Collectors.toList());\n\n\n\n# Match(匹配)\n\n所有匹配操作都是最终操作。Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream，并返回一个 boolean 类型的值。\n\nboolean matchResult;\nmatchResult = stringList.stream().anyMatch(s -> s.startsWith("a")); //true\nmatchResult = stringList.stream().allMatch(s -> s.startsWith("a")); //false\nmatchResult = stringList.stream().noneMatch(s -> s.startsWith("a")); //false\n\n\n\n# Count(计数)\n\n计数是一个 最终操作，返回Stream中元素的个数，返回值类型是 long。\n\nlong count = stringList.stream().count(); //8\n\n\n\n# Reduce(规约)\n\n这是一个 最终操作 ，允许通过指定的函数来将stream中的多个元素规约为一个元素，规约后的结果是通过Optional 接口表示的。\n\nOptional<String> reduce = stringList.stream().reduce((s1, s2) -> s1 + "#" + s2); //ddd2#aaa2#bbb1#aaa1#bbb3#ccc#bbb2#ddd1\nreduce.ifPresent(System.out::println);\n\nString concatReduce = Stream.of("A", "B", "C", "D").reduce("", (s1, s2) -> s1.concat(s2)); //ABCD\n// 求最小值，minValue = -3.0\ndouble minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min);\n// 求和，sumValue = 10, 有起始值\nint sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);\n// 求和，sumValue = 10, 无起始值\nsumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();\n\nreduce = Stream.of("a", "B", "c", "D", "e", "F").filter(s -> s.compareTo("Z") > 0).reduce((s1, s2) -> s1.concat(s2)); //ace\nreduce.ifPresent(System.out::println);\n\n\n\n# 最终流——collect方法\n\ngroupingBy（分组）：\n\n根据菜单类型进行分组\n\nmenu.stream().collect(Collectors.groupingBy(Menu::getMenuType, Collectors.toList()));\n\n\nList转Map：\n\nMap<String, String> menuMap = menu.stream().collect(Collectors.toMap(Menu::getMenuType, Menu.getMwnuName()));\n\n\n\n# Parallel Streams(并行流)\n\nStream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。\n\n首先我们创建一个没有重复元素的大表：\n\nint max = 10000;\nList<String> values = new ArrayList<>(max);\nfor (int i = 0; i < max; i++) {\n    UUID uuid = UUID.randomUUID();\n    values.add(uuid.toString());\n}\n\n\n首先使用串行流排序\n\nlong t0 = System.nanoTime();\nlong count = values.stream().sorted().count();\nSystem.out.println(count);\nlong t1 = System.nanoTime();\nlong millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);\nSystem.out.println(String.format("sequential sort took: %d ms", millis)); //84 ms\n\n\n然后使用并行流排序\n\nt0 = System.nanoTime();\ncount = values.parallelStream().sorted().count();\nSystem.out.println(count);\nt1 = System.nanoTime();\nmillis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);\nSystem.out.println(String.format("sequential sort took: %d ms", millis)); //44 ms\n\n\n并行流快了50%，只要将stream改成parallelStream即可。\n\n\n# Maps\n\nMaps不支持stream，不过map.keySet().stream(),map.values().stream()和map.entrySet().stream()可以转换成stream。\n\nJava8中Maps还提供新的方法处理日常任务。\n\n\n# putIfAbsent\n\nputIfAbsent在放入数据时，如果存在重复的key，那么putIfAbsent不会放入值。\n\nMap<Integer, String> map = new HashMap();\nmap.put(1, "zhagnsan");\nmap.put(2, "lisi");\nmap.keySet().stream();\nmap.values().stream();\nmap.entrySet().stream();\n\n\n//putIfAbsent在放入数据时，如果存在重复的key，那么putIfAbsent不会放入值。\nmap.putIfAbsent(2, "wangwu");\nSystem.out.println(map.get(2)); //lisi\n\n//如果放入数据的key已经存在与Map中，最后放入的数据会覆盖之前存在的数据\nmap.put(2, "wangwu");\nSystem.out.println(map.get(2)); //wangwu\n\n\n\n# computeIfAbsent和computeIfPresent\n\n数据准备：\n\nMap<Integer, String> map = new HashMap<>();\nfor (int i = 0; i < 10; i++) {\n    map.put(i, "val" + i);\n}\nmap.forEach((key, value) -> System.out.print(value + " ")); //val0 val1 val2 val3 val4 val5 val6 val7 val8 val9\n\n\ncomputeIfAbsent：根据key找value，如果返回值为null，则执行第二个参数的方法体，将方法体的值返回并存到map。\n\nmap.computeIfAbsent(3, val -> "bdm" + val); //val3\nmap.computeIfAbsent(23, val -> "bdm" + val); //bdm23\n\n\ncomputeIfPresent：根据key找value，如果找到对应value，就将值传到第二个参数方法体执行，将方法体的值返回并存到map。如果找不到对应的value，就不执行方法体。\n\nmap.computeIfPresent(3, (k, v) -> v + "aa"); //val3aa\nSystem.out.println(map.get(3));\nmap.computeIfPresent(23, (k, v) -> v + "aa"); //null\nSystem.out.println(map.get(23));\n\n\n\n# remove\n\n在map删除键值都配置的项。\n\nmap.remove(3, "val33");\nmap.get(3) //val3\nmap.remove(3, "val3");\nmap.get(3) //null\n\n\n\n# getOrDefault\n\n通过key获取value，如果获取的value值为null，就将第二个参数的值返回。\n\nmap.getOrDefault(42, "not found")//not found\n\n\n\n# merge\n\nMerge 做的事情是如果键名不存在则插入，否则对原键对应的值做合并操作并重新插入到map中。\n\nmap.merge(9, "aa", (val, newVal) -> val.concat(newVal));\nmap.get(9); //val9aa\nmap.merge(10, "bb", (val, newVal) -> val.concat(newVal));\nmap.get(10); //bb\n',normalizedContent:'# 接口的默认方法\n\njava8能够通过default关键字给接口添加默认方法。也称为虚拟扩展方法。\n\npackage java8.defaultmethod;\n\npublic interface formula {\n    double calculate(int a);\n\n    //接口默认方法\n    default double sqrt(int a) {\n        return math.sqrt(a);\n    }\n}\n\n\n\n# lambda表达式\n\nlambda 表达式可以简洁地表示一个行为或者传递代码。lambda 表达式可以看成匿名函数，和匿名类一样，它也能作为参数传递给一个方法。\n\nlambda 表达式有三个部分：\n\n * 参数列表——函数式接口的唯一抽象方法的参数\n * 箭头——箭头->把参数列表与 lambda 主体分隔开。\n * lambda 主体——函数式接口唯一抽象方法的方法体\n\n\n\nlambda 的基本语法：\n\n * 表达式-风格\n   \n   (parameters) -> expression\n   \n\n * 块-风格\n   \n   (parameters) -> { statements; }\n   \n\n使用lambda必须具有接口，并且接口中的抽象方法只有一个。\n\njava8之前排序字符串\n\n list<string> names = arrays.aslist("peter", "anna", "mike", "xenia");\n        collections.sort(names, new comparator<string>() {\n            @override\n            public int compare(string o1, string o2) {\n                return o1.compareto(o2);\n            }\n        });\n\n\njava8使用lambda表达式排序字符串\n\n collections.sort(names, (string a, string b) -> {\n            return a.compareto(b);\n        });\n\n\n函数体只有一行代码的，可以去掉大括号和return关键字，变的更简洁\n\n collections.sort(names, (a, b) -> a.compareto(b));\n\n\n\n# 表达式作用域\n\n# 访问局部变量\n\nlambda可以引用外部局部变量，但是引用的变量不能再修改（具有隐式final含义），不过引用的变量可以不声明final。\n\nint num = 1;\narrays.aslist(1, 2, 3).sort((a, b) -> {\n    //lambda表达式引用的变量不能再修改（具有隐式final含义），但是引用的变量可以不声明final\n    num = num + 2;  //variable used in lambda expression should be final or effectively final \n    return a > b ? a : b;\n});\n        \n\n\n# 访问成员变量和静态变量\n\nlambda表达式可以读写成员变量和静态变量\n\npublic class lambdascope {\n    static int outerstaticnum;\n    int outernum;\n\n    void testscope() {\n        //lambda表达式可以读写成员变量和静态变量\n        coverter<integer, string> outercoverter = (from) -> {\n            outernum = 21;\n            outerstaticnum = 32;\n            return string.valueof(from);\n        };\n    }\n}\n\n\n# 访问接口默认方法\n\nlambda表达式无法访问接口默认方法。\n\n\n# 函数式接口\n\n为了使现有的函数友好支持lambda表达式，增加函数式接口的概念。\n\n函数式接口是指仅仅包含一个抽象方法，但是可以有多个非抽象方法（也就是接口的默认方法）的接口。这种接口可以被隐式的转换成lambda表达式。\n\njava8增加一个注解@functionalinterface声明是一个函数式接口，如果接口多于一个抽象方法，编译器就会报错。但是这个注解不是必须的，只要接口只包含一个抽象方法，虚拟机会自动判断该接口的为函数式接口。\n\n示例：\n\n/**\n * @functionalinterface声明是一个函数式接口，如果接口多于一个抽象方法，这个注解就会报错\n */\n@functionalinterface\npublic interface coverter<f, t> {\n    t convert(f f);\n}\ncoverter<string, integer> coverter = (s) -> integer.valueof(s);\ninteger convert = coverter.convert("33");\nsystem.out.println(convert.getclass());\n\n\n大部分函数式接口都不用自己写，java8都实现好了，这些接口都放在java.util.function包里。\n\n注意： 如果一个接口中声明的抽象方法是重写了超类object类中任意一个public方法，那么这些抽象方法并不会算入接口的抽象方法数量中。因为任何接口的实现都会从其父类object或其它地方获得这些方法的实现。 比如comparator接口有两个抽象方法，但是 equals并不算入抽象方法数量。\n\n\n# 内置函数式接口\n\n# predicate\n\npredicate接口是只有一个参数返回布尔类型值的断言型接口。该接口包含多种默认方法将predicate组合成其他复杂的逻辑（比如：与、或、非）\n\npredicate<string> predicate = (s) -> s.length() > 0;\nboolean testresult;\ntestresult = predicate.test("word"); //true\ntestresult = predicate.negate().test("word"); //false\nsystem.out.println(testresult);\n\npredicate<string> isempty = string::isempty;\ntestresult = isempty.test(""); //true\nsystem.out.println(testresult);\n\npredicate<string> isnotempty = isempty.negate();\ntestresult = isnotempty.test(""); //false\nsystem.out.println(testresult);\n\n\n# function\n\nfunction 接口接收一个参数生成结果。默认方法（compose, andthen）可以将多个函数链接到一起。\n\nfunction<string, integer> tointeger = integer::valueof;\nfunction<string, string> backtostring = tointeger.andthen(string::valueof);\nstring applystr = backtostring.apply("23");\nsystem.out.println(applystr.getclass()); //class java.lang.string\n\n\n# supplier\n\nsupplier 接口产生给点泛型类型的结果，不接受任何参数\n\nsupplier<person> personsupplier = person::new;\nperson person = personsupplier.get();\nsystem.out.println(person); //person{name=\'null\', nike=\'null\'}\n\n\n# consumer\n\nconsumer 接口表示要对单个输入参数执行的操作\n\nconsumer<person> personconsumer = (p) -> system.out.println(p.nike);\npersonconsumer.accept(new person("张三", "zhangsan")); //zhangsan\n\n\n# comparator\n\ncomparator 是老java的经典接口，java8添加了多种默认方法\n\ncomparator<person> personcomparator = (p1, p2) -> p1.name.compareto(p2.name);\nperson p1 = new person("john", "doe");\nperson p2 = new person("alice", "wonderland");\nsystem.out.println(personcomparator.compare(p1, p2)); //9\nsystem.out.println(personcomparator.reversed().compare(p1, p2)); //-9\n\n\n\n# 方法和构造函数引用\n\njava8支持通过::关键字传递方法或构造函数的引用。\n\n静态方法的引用：\n\ncoverter<string, integer> coverter = integer::valueof;\ninteger convert = coverter.convert("22");\nsystem.out.println(convert.getclass());\n\n\n对象方法引用：\n\npackage java8.references;\n\npublic class something {\n    string startwith(string s) {\n        return string.valueof(s.charat(0));\n    }\n}\nsomething something = new something();\ncoverter<string, string> coverterstr = something::startwith;\nstring firstchar = coverterstr.convert("lucky");\nsystem.out.println(firstchar);\n\n\n构造方法的引用：定义一个多构造方法的类\n\npackage java8.references;\n\npublic class person {\n    string name;\n    string nike;\n\n    public person() {\n    }\n\n    public person(string name, string nike) {\n        this.name = name;\n        this.nike = nike;\n    }\n\n    @override\n    public string tostring() {\n        return "person{" +\n                "name=\'" + name + \'\\\'\' +\n                ", nike=\'" + nike + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n定义一个创建person对象的工厂接口\n\npublic interface personfactory<p extends person> {\n    p create(string name, string nike);\n}\n\n\n通过person::new将构造方法引用传给personfactory。java编译器会自动根据create传递参数个数选择合适的构造方法。\n\npersonfactory<person> personpersonfactory = person::new;\nperson person = personpersonfactory.create("张", "三");\nsystem.out.println(person);\n\n\n\n# optional\n\noptional 是用来防止nullpointerexception 的漂亮工具。 optional 是一个简单的容器，其值可能是null或者不是null。在java8应该返回optional 而不是null。\n\n//为非空的值创建一个optional\noptional<string> optional = optional.of("bdm");\n//如果值存在返回ture，否则返回false\nboolean present = optional.ispresent(); //true\n//如果有值将值返回，否则抛出nosuchelementexception异常\nstring bdm = optional.get(); //bdm\n//如果有值将值返回，否则返回指定的其它值\nstring orelseval = optional.orelse("empty"); //bdm\n//如果optional实例有值则为其调用consumer，否则不做处理\noptional.ifpresent((t) -> system.out.println("ifpresent:" + t)); //ifpresent:bdm\n\n\n\n# stream\n\njava.util.stream 表示能应用在一组元素上一次执行的操作序列。stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回stream本身，这样你就可以将多个操作依次串起来。stream 的创建需要指定一个数据源，比如 java.util.collection 的子类，list 或者 set， map 不支持。stream 的操作可以串行执行或者并行执行。\n\njava 8扩展了集合类，可以通过 collection.stream() 或者 collection.parallelstream() 来创建一个stream。\n\n下面介绍stream 常用方法，先准备数据\n\nlist<string> stringlist = new arraylist<>();\nstringlist.add("ddd2");\nstringlist.add("aaa2");\nstringlist.add("bbb1");\nstringlist.add("aaa1");\nstringlist.add("bbb3");\nstringlist.add("ccc");\nstringlist.add("bbb2");\nstringlist.add("ddd1");\n\n\n\n# filter(过滤)\n\n过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他stream操作（比如foreach）。foreach需要一个函数来对过滤后的元素依次执行。foreach是一个最终操作，所以我们不能在foreach之后来执行其他stream操作。\n\nstringlist.stream().filter(s -> s.startswith("a")).foreach(s -> system.out.println(s));\n\n\n\n# sorted(排序)\n\nsorted（排序 ）是个中间操作，如果没有指定自定义comparator的话，会使用默认排序。 排序之后原有的数据源不会改变。\n\n //sorted 排序 中间操作 如果没有指定comparator的话，会使用默认排序 排序之后stringlist不会改变\nstringlist.stream().sorted().foreach(s -> system.out.println(s));\n\n\n多字段排序：\n\n//对象集合以类属性一降序 属性二升序\nlist.stream().sorted(comparator.comparing(类::属性一,comparator.reverseorder()).thencomparing(类::属性二));\n\n\n\n区分：\n\n//方式一：先以属性一升序，再属性一降序排序\ncomparator.comparing(类::属性一).reversed();\n//方式二：直接将属性一降序排序\ncomparator.comparing(类::属性一,comparator.reverseorder());\n\n\n\n# map(映射)\n\nmap是个中间操作，会将元素根据指定的 function 接口依次将元素转成另外的对象。 返回的stream类型是根据map传递进去的函数的返回值决定的。\n\nstringlist.stream().map(string::touppercase).foreach(item -> system.out.println(item));\n\n\n给menuinfo的字段赋值。\n\nlist<menuinfo> menuinfolist = menuinfolist.stream().map(e -> {\n            e.setmenuname(e.getmeuncode());\n            return e;\n        }).collect(collectors.tolist());\n\n\n\n# match(匹配)\n\n所有匹配操作都是最终操作。stream提供了多种匹配操作，允许检测指定的predicate是否匹配整个stream，并返回一个 boolean 类型的值。\n\nboolean matchresult;\nmatchresult = stringlist.stream().anymatch(s -> s.startswith("a")); //true\nmatchresult = stringlist.stream().allmatch(s -> s.startswith("a")); //false\nmatchresult = stringlist.stream().nonematch(s -> s.startswith("a")); //false\n\n\n\n# count(计数)\n\n计数是一个 最终操作，返回stream中元素的个数，返回值类型是 long。\n\nlong count = stringlist.stream().count(); //8\n\n\n\n# reduce(规约)\n\n这是一个 最终操作 ，允许通过指定的函数来将stream中的多个元素规约为一个元素，规约后的结果是通过optional 接口表示的。\n\noptional<string> reduce = stringlist.stream().reduce((s1, s2) -> s1 + "#" + s2); //ddd2#aaa2#bbb1#aaa1#bbb3#ccc#bbb2#ddd1\nreduce.ifpresent(system.out::println);\n\nstring concatreduce = stream.of("a", "b", "c", "d").reduce("", (s1, s2) -> s1.concat(s2)); //abcd\n// 求最小值，minvalue = -3.0\ndouble minvalue = stream.of(-1.5, 1.0, -3.0, -2.0).reduce(double.max_value, double::min);\n// 求和，sumvalue = 10, 有起始值\nint sumvalue = stream.of(1, 2, 3, 4).reduce(0, integer::sum);\n// 求和，sumvalue = 10, 无起始值\nsumvalue = stream.of(1, 2, 3, 4).reduce(integer::sum).get();\n\nreduce = stream.of("a", "b", "c", "d", "e", "f").filter(s -> s.compareto("z") > 0).reduce((s1, s2) -> s1.concat(s2)); //ace\nreduce.ifpresent(system.out::println);\n\n\n\n# 最终流——collect方法\n\ngroupingby（分组）：\n\n根据菜单类型进行分组\n\nmenu.stream().collect(collectors.groupingby(menu::getmenutype, collectors.tolist()));\n\n\nlist转map：\n\nmap<string, string> menumap = menu.stream().collect(collectors.tomap(menu::getmenutype, menu.getmwnuname()));\n\n\n\n# parallel streams(并行流)\n\nstream有串行和并行两种，串行stream上的操作是在一个线程中依次完成，而并行stream则是在多个线程上同时执行。\n\n首先我们创建一个没有重复元素的大表：\n\nint max = 10000;\nlist<string> values = new arraylist<>(max);\nfor (int i = 0; i < max; i++) {\n    uuid uuid = uuid.randomuuid();\n    values.add(uuid.tostring());\n}\n\n\n首先使用串行流排序\n\nlong t0 = system.nanotime();\nlong count = values.stream().sorted().count();\nsystem.out.println(count);\nlong t1 = system.nanotime();\nlong millis = timeunit.nanoseconds.tomillis(t1 - t0);\nsystem.out.println(string.format("sequential sort took: %d ms", millis)); //84 ms\n\n\n然后使用并行流排序\n\nt0 = system.nanotime();\ncount = values.parallelstream().sorted().count();\nsystem.out.println(count);\nt1 = system.nanotime();\nmillis = timeunit.nanoseconds.tomillis(t1 - t0);\nsystem.out.println(string.format("sequential sort took: %d ms", millis)); //44 ms\n\n\n并行流快了50%，只要将stream改成parallelstream即可。\n\n\n# maps\n\nmaps不支持stream，不过map.keyset().stream(),map.values().stream()和map.entryset().stream()可以转换成stream。\n\njava8中maps还提供新的方法处理日常任务。\n\n\n# putifabsent\n\nputifabsent在放入数据时，如果存在重复的key，那么putifabsent不会放入值。\n\nmap<integer, string> map = new hashmap();\nmap.put(1, "zhagnsan");\nmap.put(2, "lisi");\nmap.keyset().stream();\nmap.values().stream();\nmap.entryset().stream();\n\n\n//putifabsent在放入数据时，如果存在重复的key，那么putifabsent不会放入值。\nmap.putifabsent(2, "wangwu");\nsystem.out.println(map.get(2)); //lisi\n\n//如果放入数据的key已经存在与map中，最后放入的数据会覆盖之前存在的数据\nmap.put(2, "wangwu");\nsystem.out.println(map.get(2)); //wangwu\n\n\n\n# computeifabsent和computeifpresent\n\n数据准备：\n\nmap<integer, string> map = new hashmap<>();\nfor (int i = 0; i < 10; i++) {\n    map.put(i, "val" + i);\n}\nmap.foreach((key, value) -> system.out.print(value + " ")); //val0 val1 val2 val3 val4 val5 val6 val7 val8 val9\n\n\ncomputeifabsent：根据key找value，如果返回值为null，则执行第二个参数的方法体，将方法体的值返回并存到map。\n\nmap.computeifabsent(3, val -> "bdm" + val); //val3\nmap.computeifabsent(23, val -> "bdm" + val); //bdm23\n\n\ncomputeifpresent：根据key找value，如果找到对应value，就将值传到第二个参数方法体执行，将方法体的值返回并存到map。如果找不到对应的value，就不执行方法体。\n\nmap.computeifpresent(3, (k, v) -> v + "aa"); //val3aa\nsystem.out.println(map.get(3));\nmap.computeifpresent(23, (k, v) -> v + "aa"); //null\nsystem.out.println(map.get(23));\n\n\n\n# remove\n\n在map删除键值都配置的项。\n\nmap.remove(3, "val33");\nmap.get(3) //val3\nmap.remove(3, "val3");\nmap.get(3) //null\n\n\n\n# getordefault\n\n通过key获取value，如果获取的value值为null，就将第二个参数的值返回。\n\nmap.getordefault(42, "not found")//not found\n\n\n\n# merge\n\nmerge 做的事情是如果键名不存在则插入，否则对原键对应的值做合并操作并重新插入到map中。\n\nmap.merge(9, "aa", (val, newval) -> val.concat(newval));\nmap.get(9); //val9aa\nmap.merge(10, "bb", (val, newval) -> val.concat(newval));\nmap.get(10); //bb\n',charsets:{cjk:!0},lastUpdated:"2023/11/02, 03:07:46",lastUpdatedTimestamp:1698894466e3},{title:"Java 8 并行流",frontmatter:{title:"Java 8 并行流",date:"2023-11-02T10:39:59.000Z",permalink:"/pages/f2f56b/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/03.Java/04.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/01.Java8%20%E6%96%B0%E7%89%B9%E6%80%A7/02.Java%208%20%E5%B9%B6%E8%A1%8C%E6%B5%81.html",relativePath:"01.Java 知识体系/03.Java/04.Java 新特性/01.Java8 新特性/02.Java 8 并行流.md",key:"v-854b12bc",path:"/pages/f2f56b/",headers:[{level:1,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:357}],headersStr:"参考资料",content:"什么是并行流？\n\n并行流就是将一个流的内容分成多个数据块，并用不同的线程分别处理每个不同数据块的流。\n\n如何使用并行流？\n\n使用 parallelStream() 方法使用并行流或者通过 stream.parallel() 将普通流转换成并行流。\n\n并行流原理：并行流内部使用了默认的 ForkJoinPool 线程池。默认的线程数量就是处理器的核心数。java.util.concurrent.ForkJoinPool.common.parallelism 可以改变线程池大小。不过该值是全局变量。改变他会影响所有并行流。目前还无法为每个流配置专属的线程数。\n\n并行流使用注意事项：\n\n * 并行流并不一定时最快的处理方式。\n * 并行流虽然轻易实现了多线程，但是并没有解决多线程中共享变量的修改问题。\n\n\n# 参考资料\n\n * Java8并行流：执行速度快的飞起！-阿里云开发者社区",normalizedContent:"什么是并行流？\n\n并行流就是将一个流的内容分成多个数据块，并用不同的线程分别处理每个不同数据块的流。\n\n如何使用并行流？\n\n使用 parallelstream() 方法使用并行流或者通过 stream.parallel() 将普通流转换成并行流。\n\n并行流原理：并行流内部使用了默认的 forkjoinpool 线程池。默认的线程数量就是处理器的核心数。java.util.concurrent.forkjoinpool.common.parallelism 可以改变线程池大小。不过该值是全局变量。改变他会影响所有并行流。目前还无法为每个流配置专属的线程数。\n\n并行流使用注意事项：\n\n * 并行流并不一定时最快的处理方式。\n * 并行流虽然轻易实现了多线程，但是并没有解决多线程中共享变量的修改问题。\n\n\n# 参考资料\n\n * java8并行流：执行速度快的飞起！-阿里云开发者社区",charsets:{cjk:!0},lastUpdated:"2023/11/02, 03:07:46",lastUpdatedTimestamp:1698894466e3},{title:"JVM 垃圾收集",frontmatter:{title:"JVM 垃圾收集",date:"2023-10-23T23:55:07.000Z",permalink:"/pages/5bf174/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/03.Java/05.JVM/02.JVM%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86.html",relativePath:"01.Java 知识体系/03.Java/05.JVM/02.JVM 垃圾收集.md",key:"v-76b6bfea",path:"/pages/5bf174/",headers:[{level:1,title:"相关概念",slug:"相关概念",normalizedTitle:"相关概念",charIndex:2},{level:2,title:"STW",slug:"stw",normalizedTitle:"stw",charIndex:11},{level:2,title:"saft point（安全点）",slug:"saft-point-安全点",normalizedTitle:"saft point（安全点）",charIndex:61},{level:2,title:"垃圾回收类型",slug:"垃圾回收类型",normalizedTitle:"垃圾回收类型",charIndex:432},{level:1,title:"对象已经死亡？",slug:"对象已经死亡",normalizedTitle:"对象已经死亡？",charIndex:703},{level:2,title:"引用计数算法",slug:"引用计数算法",normalizedTitle:"引用计数算法",charIndex:715},{level:2,title:"可达性分析算法",slug:"可达性分析算法",normalizedTitle:"可达性分析算法",charIndex:1289},{level:2,title:"不可达的对象并非“非死不可”",slug:"不可达的对象并非-非死不可",normalizedTitle:"不可达的对象并非“非死不可”",charIndex:1535},{level:1,title:"垃圾收集算法",slug:"垃圾收集算法",normalizedTitle:"垃圾收集算法",charIndex:1808},{level:2,title:"标记-清除算法",slug:"标记-清除算法",normalizedTitle:"标记-清除算法",charIndex:1819},{level:2,title:"标记-复制算法",slug:"标记-复制算法",normalizedTitle:"标记-复制算法",charIndex:1975},{level:2,title:"标记-整理算法",slug:"标记-整理算法",normalizedTitle:"标记-整理算法",charIndex:2137},{level:2,title:"分代收集算法",slug:"分代收集算法",normalizedTitle:"分代收集算法",charIndex:2240},{level:1,title:"垃圾收集器",slug:"垃圾收集器",normalizedTitle:"垃圾收集器",charIndex:2488},{level:2,title:"Serial 收集器",slug:"serial-收集器",normalizedTitle:"serial 收集器",charIndex:2589},{level:2,title:"Serial Old 收集器",slug:"serial-old-收集器",normalizedTitle:"serial old 收集器",charIndex:2603},{level:2,title:"Parallel Scavenge 收集器",slug:"parallel-scavenge-收集器",normalizedTitle:"parallel scavenge 收集器",charIndex:2630},{level:2,title:"Parallel Old 收集器",slug:"parallel-old-收集器",normalizedTitle:"parallel old 收集器",charIndex:2656},{level:2,title:"ParNew 收集器",slug:"parnew-收集器",normalizedTitle:"parnew 收集器",charIndex:2677},{level:2,title:"CMS 收集器",slug:"cms-收集器",normalizedTitle:"cms 收集器",charIndex:2692},{level:2,title:"G1 收集器",slug:"g1-收集器",normalizedTitle:"g1 收集器",charIndex:2704}],headersStr:"相关概念 STW saft point（安全点） 垃圾回收类型 对象已经死亡？ 引用计数算法 可达性分析算法 不可达的对象并非“非死不可” 垃圾收集算法 标记-清除算法 标记-复制算法 标记-整理算法 分代收集算法 垃圾收集器 Serial 收集器 Serial Old 收集器 Parallel Scavenge 收集器 Parallel Old 收集器 ParNew 收集器 CMS 收集器 G1 收集器",content:'# 相关概念\n\n\n# STW\n\nGC如何需要停止所有应用程序的进程称为STW（Stop-the-world ）。\n\n\n# saft point（安全点）\n\n挂起线程的点\n\n * 从全局观点来看，所有线程必须在GC 运行前，在一个safepoint处阻塞（block）。\n * 从局部观点来看，safepoint是一个代码块中特殊的一点，该处正在执行的线程可以因GC而阻塞。\n * GC的标记阶段需要stop the world，让所有Java线程挂起，这样JVM才可以安全地来标记对象。\n\nsafepoint可以用来实现让所有Java线程挂起的需求。这是一种 "主动式"(Voluntary Suspension)的实现\n\nsafe point指的特定位置主要有:\n\n 1. 循环的末尾 (防止大循环的时候一直不进入safepoint，而其他线程在等待它进入safepoint)\n 2. 方法返回前\n 3. 调用方法的call之后\n 4. 抛出异常的位置\n\n\n# 垃圾回收类型\n\n * 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。Minor GC 非常频繁，回收速度比较快。\n\n * 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集， Major GC 一般比 Minor GC慢 10 倍以上。目前只有CMS收集器会有单独收集老年代的行为。\n\n * 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。\n\n * 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。\n\n\n# 对象已经死亡？\n\n\n# 引用计数算法\n\n给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。\n\n这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。\n\npublic class ReferenceCountingGc {\n    Object instance = null;\n\tpublic static void main(String[] args) {\n\t\tReferenceCountingGc objA = new ReferenceCountingGc();\n\t\tReferenceCountingGc objB = new ReferenceCountingGc();\n\t\tobjA.instance = objB;\n\t\tobjB.instance = objA;\n\t\tobjA = null;\n\t\tobjB = null;\n\n\t}\n}\n\n\n\n\n# 可达性分析算法\n\n这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。\n\n\n\n可作为 GC Roots 的对象包括下面几种:\n\n * 虚拟机栈(栈帧中的本地变量表)中引用的对象\n * 本地方法栈(Native 方法)中引用的对象\n * 方法区中类静态属性引用的对象\n * 方法区中常量引用的对象\n * 所有被同步锁持有的对象\n\n\n# 不可达的对象并非“非死不可”\n\n即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。\n\n被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。\n\n\n# 垃圾收集算法\n\n\n# 标记-清除算法\n\n该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：\n\n 1. 效率问题\n 2. 空间问题（标记清除后会产生大量不连续的碎片）\n\n\n\n\n# 标记-复制算法\n\n为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。标记-复制算法虽然解决了碎片化问题，但是存在空间浪费。\n\n\n\n\n# 标记-整理算法\n\n根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。\n\n\n\n\n# 分代收集算法\n\n当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n\n比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。\n\n\n# 垃圾收集器\n\n串行收集器：使用单线程进行垃圾回收的收集器，每次回收时，串行收集器只有一个工作线程，对于并行能力较弱的计算机来说，串行收集器的专注性和独占性往往有更好的性能表现。\n\n串行收集器：\n\n * Serial 收集器\n * Serial Old 收集器\n\n并行收集器：\n\n * Parallel Scavenge 收集器\n\n * Parallel Old 收集器\n\n * ParNew 收集器\n\n * CMS 收集器\n\n * G1 收集器\n\n有 7 种不同的垃圾回收器，它们分别用于不同分代的垃圾回收。\n\n * 新生代回收器：Serial、ParNew、Parallel Scavenge\n * 老年代回收器：Serial Old、Parallel Old、CMS\n * 整堆回收器：G1\n\n可选的搭配方案：\n\n新生代                 老年代\nSerial              Serial Old\nSerial              CMS\nParNew              Serial Old\nParNew              CMS\nParallel Scavenge   Serial Old\nParallel Scavenge   Parallel Old\nG1                  G1\n\n\n# Serial 收集器\n\nSerial收集器是一个新生代收集器，单线程执行，使用标记-复制算法。它在进行垃圾收集时，必须暂停其他所有的工作线程(用户线程)。是JVM Client模式下默认的新生代收集器。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。\n\n\n\n\n# Serial Old 收集器\n\nSerial收集器的老年代版本，它同样是一个单线程收集器，使用 “标记-整理”算法。也会暂定所有用户线程。\n\n\n# Parallel Scavenge 收集器\n\n配置参数：-XX:+UseParallelGC\n\n目标是达到一个可控制的吞吐量（Throughput）。\n\n吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）。\n\n虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是99%。\n\n\n\n特点：\n\n * 新生代使用并行回收收集器，老年代使用串行收集器\n * 吞吐量优先收集器\n * 新生代收集器复制算法，是并行的多线程收集器。\n\n\n# Parallel Old 收集器\n\n配置参数：-XX:+UseParallelOldGC\n\n特点：\n\n * Parallel Scavenge收集器的老年代版本，使用多线程和 “标记-整理”算法。\n * 在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。\n\n\n# ParNew 收集器\n\n配置参数：-XX:+UseParNewGC\n\n配置参数：-XX:ParallelGCThreads=n 设置并行收集器收集时使用的并行收集线程数。一般最好和计算机的CPU相当\n\n特点：\n\n * 新生代并行（ParNew），老年代串行（Serial Old）\n * Serial收集器的多线程版本\n * 单CPU性能并不如Serial，因为存在线程交互的开销\n\n\n\n\n# CMS 收集器\n\n配置参数：-XX:+UseConcMarkSweepGC 应用CMS收集器。\n\n尽管CMS收集器采用的是 并发回收（非独占式） ，但是在其初始标记和重新标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长。\n\n因此可以说明 目前所有的垃圾收集器都做不到完全不需要“stop-the-World ， 只是尽可能地缩短暂停时间 。\n\n由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。\n\n另外，由于在垃圾收集阶段用户线程没有中断 ，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。\n\n特点:\n\n * 低延迟： 减少STW对用户体验的影响【响应时间和延迟要求高】\n * 并发收集：可以同时执行用户线程\n * CMS收集器 不能像其他收集器那样等到老年代几乎完全被填满了再进行收集 ，而是当堆内存使用率达到某一阈值时，便开始进行回收。\n * CMS收集器的垃圾收集算法采用的是标记清除算法。\n * 会产生内存碎片，导致并发清除后，用户线程可用的空间不足。\n * CMS收集器对CPU资源非常敏感。\n\nCMS垃圾回收器：\n\nCMS整个过程比之前的收集器要复杂，整个过程分为 4 个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。\n\n> ( 涉及STW的阶段主要是：初始标记 和 重新标记 )\n\n * 初始标记（Initial-Mark）阶段 ：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GCRoots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。【STW】\n\n * 并发标记（Concurrent-Mark）阶段 ：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。\n\n * 重新标记（Remark）阶段 ：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了 修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录 ，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。【STW】\n\n * 并发清除（Concurrent-Sweep）阶段 ：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。\n\n\n# G1 收集器\n\n配置参数：-XX:+UseG1Gc 应用G1收集器\n\n配置参数：-XX:MaxGCPauseMillis 指定最大停顿时间\n\n配置参数：-XX:ParallelGCThreads 设置并行回收的线程数量\n\nGarbage-First当今收集器技术发展的最前沿成果之一，G1是一款面向服务端应用的垃圾收集器。大内存，企业配置的垃圾收集器大多都是G1。\n\n特点：\n\n 1. 并行与并发：充分利用多CPU、多核环境下的硬件优势\n 2. 分代收集：不需要其他收集器配合就能独立管理整个GC堆\n 3. 空间整合：“标记—整理”算法实现的收集器，局部上基于“复制”算法不会产生内存空间碎片\n 4. 可预测的停顿：能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒\n\n\n\nG1收集器的运作大致可划分为以下几个步骤：\n\n 1. 初始标记：标记一下GC Roots能直接关联到的对象，需要停顿线程，但耗时很短\n 2. 并发标记：是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行\n 3. 最终标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录\n 4. 筛选回收：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划',normalizedContent:'# 相关概念\n\n\n# stw\n\ngc如何需要停止所有应用程序的进程称为stw（stop-the-world ）。\n\n\n# saft point（安全点）\n\n挂起线程的点\n\n * 从全局观点来看，所有线程必须在gc 运行前，在一个safepoint处阻塞（block）。\n * 从局部观点来看，safepoint是一个代码块中特殊的一点，该处正在执行的线程可以因gc而阻塞。\n * gc的标记阶段需要stop the world，让所有java线程挂起，这样jvm才可以安全地来标记对象。\n\nsafepoint可以用来实现让所有java线程挂起的需求。这是一种 "主动式"(voluntary suspension)的实现\n\nsafe point指的特定位置主要有:\n\n 1. 循环的末尾 (防止大循环的时候一直不进入safepoint，而其他线程在等待它进入safepoint)\n 2. 方法返回前\n 3. 调用方法的call之后\n 4. 抛出异常的位置\n\n\n# 垃圾回收类型\n\n * 新生代收集（minor gc/young gc）：指目标只是新生代的垃圾收集。minor gc 非常频繁，回收速度比较快。\n\n * 老年代收集（major gc/old gc）：指目标只是老年代的垃圾收集， major gc 一般比 minor gc慢 10 倍以上。目前只有cms收集器会有单独收集老年代的行为。\n\n * 整堆收集（full gc）：收集整个java堆和方法区的垃圾收集。\n\n * 混合收集（mixed gc）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有g1收集器会有这种行为。\n\n\n# 对象已经死亡？\n\n\n# 引用计数算法\n\n给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。\n\n这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，如下面代码所示：除了对象 obja 和 objb 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 gc 回收器回收他们。\n\npublic class referencecountinggc {\n    object instance = null;\n\tpublic static void main(string[] args) {\n\t\treferencecountinggc obja = new referencecountinggc();\n\t\treferencecountinggc objb = new referencecountinggc();\n\t\tobja.instance = objb;\n\t\tobjb.instance = obja;\n\t\tobja = null;\n\t\tobjb = null;\n\n\t}\n}\n\n\n\n\n# 可达性分析算法\n\n这个算法的基本思想就是通过一系列的称为 “gc roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 gc roots 没有任何引用链相连的话，则证明此对象是不可用的。\n\n\n\n可作为 gc roots 的对象包括下面几种:\n\n * 虚拟机栈(栈帧中的本地变量表)中引用的对象\n * 本地方法栈(native 方法)中引用的对象\n * 方法区中类静态属性引用的对象\n * 方法区中常量引用的对象\n * 所有被同步锁持有的对象\n\n\n# 不可达的对象并非“非死不可”\n\n即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。\n\n被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。\n\n\n# 垃圾收集算法\n\n\n# 标记-清除算法\n\n该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：\n\n 1. 效率问题\n 2. 空间问题（标记清除后会产生大量不连续的碎片）\n\n\n\n\n# 标记-复制算法\n\n为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。标记-复制算法虽然解决了碎片化问题，但是存在空间浪费。\n\n\n\n\n# 标记-整理算法\n\n根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。\n\n\n\n\n# 分代收集算法\n\n当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n\n比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。\n\n\n# 垃圾收集器\n\n串行收集器：使用单线程进行垃圾回收的收集器，每次回收时，串行收集器只有一个工作线程，对于并行能力较弱的计算机来说，串行收集器的专注性和独占性往往有更好的性能表现。\n\n串行收集器：\n\n * serial 收集器\n * serial old 收集器\n\n并行收集器：\n\n * parallel scavenge 收集器\n\n * parallel old 收集器\n\n * parnew 收集器\n\n * cms 收集器\n\n * g1 收集器\n\n有 7 种不同的垃圾回收器，它们分别用于不同分代的垃圾回收。\n\n * 新生代回收器：serial、parnew、parallel scavenge\n * 老年代回收器：serial old、parallel old、cms\n * 整堆回收器：g1\n\n可选的搭配方案：\n\n新生代                 老年代\nserial              serial old\nserial              cms\nparnew              serial old\nparnew              cms\nparallel scavenge   serial old\nparallel scavenge   parallel old\ng1                  g1\n\n\n# serial 收集器\n\nserial收集器是一个新生代收集器，单线程执行，使用标记-复制算法。它在进行垃圾收集时，必须暂停其他所有的工作线程(用户线程)。是jvm client模式下默认的新生代收集器。对于限定单个cpu的环境来说，serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。\n\n\n\n\n# serial old 收集器\n\nserial收集器的老年代版本，它同样是一个单线程收集器，使用 “标记-整理”算法。也会暂定所有用户线程。\n\n\n# parallel scavenge 收集器\n\n配置参数：-xx:+useparallelgc\n\n目标是达到一个可控制的吞吐量（throughput）。\n\n吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）。\n\n虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是99%。\n\n\n\n特点：\n\n * 新生代使用并行回收收集器，老年代使用串行收集器\n * 吞吐量优先收集器\n * 新生代收集器复制算法，是并行的多线程收集器。\n\n\n# parallel old 收集器\n\n配置参数：-xx:+useparalleloldgc\n\n特点：\n\n * parallel scavenge收集器的老年代版本，使用多线程和 “标记-整理”算法。\n * 在注重吞吐量以及cpu资源敏感的场合，都可以优先考虑parallel scavenge加parallel old收集器。\n\n\n# parnew 收集器\n\n配置参数：-xx:+useparnewgc\n\n配置参数：-xx:parallelgcthreads=n 设置并行收集器收集时使用的并行收集线程数。一般最好和计算机的cpu相当\n\n特点：\n\n * 新生代并行（parnew），老年代串行（serial old）\n * serial收集器的多线程版本\n * 单cpu性能并不如serial，因为存在线程交互的开销\n\n\n\n\n# cms 收集器\n\n配置参数：-xx:+useconcmarksweepgc 应用cms收集器。\n\n尽管cms收集器采用的是 并发回收（非独占式） ，但是在其初始标记和重新标记这两个阶段中仍然需要执行“stop-the-world”机制暂停程序中的工作线程，不过暂停时间并不会太长。\n\n因此可以说明 目前所有的垃圾收集器都做不到完全不需要“stop-the-world ， 只是尽可能地缩短暂停时间 。\n\n由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。\n\n另外，由于在垃圾收集阶段用户线程没有中断 ，所以在cms回收过程中，还应该确保应用程序用户线程有足够的内存可用。\n\n特点:\n\n * 低延迟： 减少stw对用户体验的影响【响应时间和延迟要求高】\n * 并发收集：可以同时执行用户线程\n * cms收集器 不能像其他收集器那样等到老年代几乎完全被填满了再进行收集 ，而是当堆内存使用率达到某一阈值时，便开始进行回收。\n * cms收集器的垃圾收集算法采用的是标记清除算法。\n * 会产生内存碎片，导致并发清除后，用户线程可用的空间不足。\n * cms收集器对cpu资源非常敏感。\n\ncms垃圾回收器：\n\ncms整个过程比之前的收集器要复杂，整个过程分为 4 个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。\n\n> ( 涉及stw的阶段主要是：初始标记 和 重新标记 )\n\n * 初始标记（initial-mark）阶段 ：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出gcroots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。【stw】\n\n * 并发标记（concurrent-mark）阶段 ：从gc roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。\n\n * 重新标记（remark）阶段 ：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了 修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录 ，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。【stw】\n\n * 并发清除（concurrent-sweep）阶段 ：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。\n\n\n# g1 收集器\n\n配置参数：-xx:+useg1gc 应用g1收集器\n\n配置参数：-xx:maxgcpausemillis 指定最大停顿时间\n\n配置参数：-xx:parallelgcthreads 设置并行回收的线程数量\n\ngarbage-first当今收集器技术发展的最前沿成果之一，g1是一款面向服务端应用的垃圾收集器。大内存，企业配置的垃圾收集器大多都是g1。\n\n特点：\n\n 1. 并行与并发：充分利用多cpu、多核环境下的硬件优势\n 2. 分代收集：不需要其他收集器配合就能独立管理整个gc堆\n 3. 空间整合：“标记—整理”算法实现的收集器，局部上基于“复制”算法不会产生内存空间碎片\n 4. 可预测的停顿：能让使用者明确指定在一个长度为m毫秒的时间片段内，消耗在垃圾收集上的时间不得超过n毫秒\n\n\n\ng1收集器的运作大致可划分为以下几个步骤：\n\n 1. 初始标记：标记一下gc roots能直接关联到的对象，需要停顿线程，但耗时很短\n 2. 并发标记：是从gc root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行\n 3. 最终标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录\n 4. 筛选回收：对各个region的回收价值和成本进行排序，根据用户所期望的gc停顿时间来制定回收计划',charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"JVM 常用参数",frontmatter:{title:"JVM 常用参数",date:"2023-10-23T23:55:07.000Z",permalink:"/pages/c5dfa7/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/03.Java/05.JVM/03.JVM%20%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0.html",relativePath:"01.Java 知识体系/03.Java/05.JVM/03.JVM 常用参数.md",key:"v-21848ec2",path:"/pages/c5dfa7/",headers:[{level:1,title:"标准参数、非标准参数、不稳定参",slug:"标准参数、非标准参数、不稳定参",normalizedTitle:"标准参数、非标准参数、不稳定参",charIndex:15},{level:2,title:"标准参数",slug:"标准参数",normalizedTitle:"标准参数",charIndex:15},{level:2,title:"非标准参数",slug:"非标准参数",normalizedTitle:"非标准参数",charIndex:20},{level:2,title:"不稳定参数",slug:"不稳定参数",normalizedTitle:"不稳定参数",charIndex:26},{level:1,title:"常用参数",slug:"常用参数",normalizedTitle:"常用参数",charIndex:1188},{level:2,title:"并行收集器相关参数",slug:"并行收集器相关参数",normalizedTitle:"并行收集器相关参数",charIndex:2301}],headersStr:"标准参数、非标准参数、不稳定参 标准参数 非标准参数 不稳定参数 常用参数 并行收集器相关参数",content:"JVM参数主要分为以下三种： 标准参数、非标准参数、不稳定参数。\n\n\n# 标准参数、非标准参数、不稳定参\n\n\n# 标准参数\n\n标准参数，顾名思义，标准参数中包括功能以及输出的结果都是很稳定的，基本上 不会随着JVM版本的变化而变化 。标准参数以 - 开头，如：java -version、java -jar等，通过java -help可以查询所有的标准参数，\n\n我们可以通过 -help 命令来检索出所有标准参数\n\n\n\n> -help 也是一个标准参数，再比如使用比较多的 -version也是。\n\n\n# 非标准参数\n\n非标准参数以 -X 开头，是标准参数的扩展。对应前面讲的标准化参数，这是非标准化参数。\n\n表示在将来的JVM版本中可能会发生改变，但是这类以-X开始的参数变化的比较小。\n\n我们可以通过 Java -X 命令来检索所有-X 参数。\n\n\n\n我们可以通过设置非标准参数来配置堆的内存分配，常用的非标准参数有：\n\n * -Xms 堆内存的最小值：默认值是总内存/64（且小于1G），默认情况下，当堆中可用内存小于40%时，堆内存会开始增加，一直增加到-Xmx的大小。\n\n * -Xmx 堆内存的最大值：默认值是总内存/64（且小于1G），如果Xms和Xmx都不设置，则两者大小会相同，默认情况下，当堆中可用内存大于70%时，堆内存会开始减少，一直减小到-Xms的大小；\n\n * -Xmn 新生代内存的最大值：包括Eden区和两个Survivor区的总和，写法如：-Xmn1024m\n\n * -Xss 每个线程的栈内存： 默认1M，一般来说是不需要改的。(比较少用)\n\n\n# 不稳定参数\n\n这是我们日常开发中接触到最多的参数类型。这也是非标准化参数，相对来说不稳定，随着JVM版本的变化可能会发生变化，主要用于 JVM调优 和 debug。\n\n不稳定参数以-XX 开头，此类参数的设置很容易引起JVM 性能上的差异，使JVM存在极大的不稳定性。\n\n如果此类参数设置合理将大大提高JVM的性能及稳定性。\n\n不稳定参数分为三类：\n\n * 性能参数：用于JVM的性能调优和内存分配控制，如内存大小的设置；\n * 行为参数：用于改变JVM的基础行为，如GC的方式和算法的选择；\n * 调试参数：用于监控、打印、输出jvm的信息；\n\n不稳定参数语法规则：\n\n 1. 布尔类型参数值：\n    * -XX:+\n    * -XX:-\n\n示例：-XX:+UseG1GC：表示启用G1垃圾收集器\n\n\n 2. 数字类型参数值：\n    * -XX:=\n\n示例：-XX:MaxGCPauseMillis=500 ：表示设置GC的最大停顿时间是500ms\n\n\n 3. 字符串类型参数值：\n    * -XX:=\n\n示例：-XX:HeapDumpPath=./dump.core\n\n\n\n# 常用参数\n\n参数名称                  含义                                      默认值               \n-Xms                  初始堆大小                                   物理内存的1/64(<1GB)   \n-Xmx                  最大堆大小                                   物理内存的1/4(<1GB     \n-Xmn                  年轻代大小                                                     \n-XX:NewSize           设置年轻代大小                                                   \n-XX:MaxNewSize        年轻代最大值                                                    \n-XX:PermSize          设置持久代(perm gen)初始值                      物理内存的1/64         \n-XX:MaxPermSize       设置持久代最大值                                物理内存的1/4          \n-Xss                  每个线程的堆栈大小                                                 \n-XX:ThreadStackSize   线程堆栈大小                                                    \n-XX:NewRatio          年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)                     -XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5，Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。\n-XX:SurvivorRatio     Eden区与Survivor区的大小比值                                      设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10\n\n\n# 并行收集器相关参数\n\n参数名称                    含义                                    默认值\n-XX:+UseParallelGC      Full GC采用parallelMSC                  \n-XX:+UseParNewGC        设置年轻代为并行收集                            \n-XX:ParallelGCThreads   并行收集器的线程数                             \n-XX:+UseParallelOldGC   年老代垃圾收集方式为并行收集(Parallel Compacting)   ",normalizedContent:"jvm参数主要分为以下三种： 标准参数、非标准参数、不稳定参数。\n\n\n# 标准参数、非标准参数、不稳定参\n\n\n# 标准参数\n\n标准参数，顾名思义，标准参数中包括功能以及输出的结果都是很稳定的，基本上 不会随着jvm版本的变化而变化 。标准参数以 - 开头，如：java -version、java -jar等，通过java -help可以查询所有的标准参数，\n\n我们可以通过 -help 命令来检索出所有标准参数\n\n\n\n> -help 也是一个标准参数，再比如使用比较多的 -version也是。\n\n\n# 非标准参数\n\n非标准参数以 -x 开头，是标准参数的扩展。对应前面讲的标准化参数，这是非标准化参数。\n\n表示在将来的jvm版本中可能会发生改变，但是这类以-x开始的参数变化的比较小。\n\n我们可以通过 java -x 命令来检索所有-x 参数。\n\n\n\n我们可以通过设置非标准参数来配置堆的内存分配，常用的非标准参数有：\n\n * -xms 堆内存的最小值：默认值是总内存/64（且小于1g），默认情况下，当堆中可用内存小于40%时，堆内存会开始增加，一直增加到-xmx的大小。\n\n * -xmx 堆内存的最大值：默认值是总内存/64（且小于1g），如果xms和xmx都不设置，则两者大小会相同，默认情况下，当堆中可用内存大于70%时，堆内存会开始减少，一直减小到-xms的大小；\n\n * -xmn 新生代内存的最大值：包括eden区和两个survivor区的总和，写法如：-xmn1024m\n\n * -xss 每个线程的栈内存： 默认1m，一般来说是不需要改的。(比较少用)\n\n\n# 不稳定参数\n\n这是我们日常开发中接触到最多的参数类型。这也是非标准化参数，相对来说不稳定，随着jvm版本的变化可能会发生变化，主要用于 jvm调优 和 debug。\n\n不稳定参数以-xx 开头，此类参数的设置很容易引起jvm 性能上的差异，使jvm存在极大的不稳定性。\n\n如果此类参数设置合理将大大提高jvm的性能及稳定性。\n\n不稳定参数分为三类：\n\n * 性能参数：用于jvm的性能调优和内存分配控制，如内存大小的设置；\n * 行为参数：用于改变jvm的基础行为，如gc的方式和算法的选择；\n * 调试参数：用于监控、打印、输出jvm的信息；\n\n不稳定参数语法规则：\n\n 1. 布尔类型参数值：\n    * -xx:+\n    * -xx:-\n\n示例：-xx:+useg1gc：表示启用g1垃圾收集器\n\n\n 2. 数字类型参数值：\n    * -xx:=\n\n示例：-xx:maxgcpausemillis=500 ：表示设置gc的最大停顿时间是500ms\n\n\n 3. 字符串类型参数值：\n    * -xx:=\n\n示例：-xx:heapdumppath=./dump.core\n\n\n\n# 常用参数\n\n参数名称                  含义                                      默认值               \n-xms                  初始堆大小                                   物理内存的1/64(<1gb)   \n-xmx                  最大堆大小                                   物理内存的1/4(<1gb     \n-xmn                  年轻代大小                                                     \n-xx:newsize           设置年轻代大小                                                   \n-xx:maxnewsize        年轻代最大值                                                    \n-xx:permsize          设置持久代(perm gen)初始值                      物理内存的1/64         \n-xx:maxpermsize       设置持久代最大值                                物理内存的1/4          \n-xss                  每个线程的堆栈大小                                                 \n-xx:threadstacksize   线程堆栈大小                                                    \n-xx:newratio          年轻代(包括eden和两个survivor区)与年老代的比值(除去持久代)                     -xx:newratio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5，xms=xmx并且设置了xmn的情况下，该参数不需要进行设置。\n-xx:survivorratio     eden区与survivor区的大小比值                                      设置为8,则两个survivor区与一个eden区的比值为2:8,一个survivor区占整个年轻代的1/10\n\n\n# 并行收集器相关参数\n\n参数名称                    含义                                    默认值\n-xx:+useparallelgc      full gc采用parallelmsc                  \n-xx:+useparnewgc        设置年轻代为并行收集                            \n-xx:parallelgcthreads   并行收集器的线程数                             \n-xx:+useparalleloldgc   年老代垃圾收集方式为并行收集(parallel compacting)   ",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"JVM 问题排查及调优",frontmatter:{title:"JVM 问题排查及调优",date:"2023-10-23T23:55:07.000Z",permalink:"/pages/7bbf36/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/03.Java/05.JVM/06.JVM%20%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%8F%8A%E8%B0%83%E4%BC%98.html",relativePath:"01.Java 知识体系/03.Java/05.JVM/06.JVM 问题排查及调优.md",key:"v-4cef543f",path:"/pages/7bbf36/",headers:[{level:1,title:"内存溢出排查",slug:"内存溢出排查",normalizedTitle:"内存溢出排查",charIndex:2},{level:1,title:"内存泄漏",slug:"内存泄漏",normalizedTitle:"内存泄漏",charIndex:75},{level:1,title:"JVM 调优",slug:"jvm-调优",normalizedTitle:"jvm 调优",charIndex:357},{level:1,title:"Reference",slug:"reference",normalizedTitle:"reference",charIndex:466}],headersStr:"内存溢出排查 内存泄漏 JVM 调优 Reference",content:"# 内存溢出排查\n\n 1. dump 出内存文件\n 2. Memory Analysis进行分析，定位到造成内存溢出的代码，进行相应的处理。\n\n\n# 内存泄漏\n\n 1. 使用 **jps** 命令获取到当前JVM进程的pid\n 2. 使用 **jstat -gc** 命令观察GC： 如果YGC每次GC掉的内存并不多，每次YGC后都有一部分内存未回收，导致在多次YGC后回收不掉的内存被挪到堆的old区，old满了之后FGC发现也是回收不掉。就基本可以确定是内存泄漏问题\n 3. 使用**jmap -dump**命令生成堆转存快照。\n 4. 使用MAT（ MemoryAnalyzer ）分析dump文件，找到具体内存泄漏的代码。（MAT的 Leak Suspects报表帮助我们定位到内存泄漏的代码 ）\n\n\n# JVM 调优\n\nJVM 调优的主要步骤：\n\n 1. 监控分析GC日志\n 2. 出现GC时间长或者GC频率高就得考虑进行JVM调优\n 3. 分析出现问题的原因，确定调优目标\n 4. 调整参数或者优化代码实现调优\n\n\n# Reference\n\n * https://juejin.cn/post/7128377003224334373#heading-0",normalizedContent:"# 内存溢出排查\n\n 1. dump 出内存文件\n 2. memory analysis进行分析，定位到造成内存溢出的代码，进行相应的处理。\n\n\n# 内存泄漏\n\n 1. 使用 **jps** 命令获取到当前jvm进程的pid\n 2. 使用 **jstat -gc** 命令观察gc： 如果ygc每次gc掉的内存并不多，每次ygc后都有一部分内存未回收，导致在多次ygc后回收不掉的内存被挪到堆的old区，old满了之后fgc发现也是回收不掉。就基本可以确定是内存泄漏问题\n 3. 使用**jmap -dump**命令生成堆转存快照。\n 4. 使用mat（ memoryanalyzer ）分析dump文件，找到具体内存泄漏的代码。（mat的 leak suspects报表帮助我们定位到内存泄漏的代码 ）\n\n\n# jvm 调优\n\njvm 调优的主要步骤：\n\n 1. 监控分析gc日志\n 2. 出现gc时间长或者gc频率高就得考虑进行jvm调优\n 3. 分析出现问题的原因，确定调优目标\n 4. 调整参数或者优化代码实现调优\n\n\n# reference\n\n * https://juejin.cn/post/7128377003224334373#heading-0",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"Java 内存区域",frontmatter:{title:"Java 内存区域",date:"2023-10-23T23:55:07.000Z",permalink:"/pages/ecd0f2/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/03.Java/05.JVM/01.Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.html",relativePath:"01.Java 知识体系/03.Java/05.JVM/01.Java 内存区域.md",key:"v-f445feb8",path:"/pages/ecd0f2/",headers:[{level:1,title:"运行时数据区",slug:"运行时数据区",normalizedTitle:"运行时数据区",charIndex:2},{level:2,title:"程序计数器",slug:"程序计数器",normalizedTitle:"程序计数器",charIndex:37},{level:2,title:"Java 虚拟机栈",slug:"java-虚拟机栈",normalizedTitle:"java 虚拟机栈",charIndex:46},{level:2,title:"本地方法栈",slug:"本地方法栈",normalizedTitle:"本地方法栈",charIndex:59},{level:2,title:"堆",slug:"堆",normalizedTitle:"堆",charIndex:77},{level:2,title:"方法区",slug:"方法区",normalizedTitle:"方法区",charIndex:82}],headersStr:"运行时数据区 程序计数器 Java 虚拟机栈 本地方法栈 堆 方法区",content:"# 运行时数据区\n\nJava 运行时数据区分为：\n\n线程私有的：\n\n * 程序计数器\n * Java 虚拟机栈\n * 本地方法栈\n\n线程共享的：\n\n * 堆\n * 方法区（永久代/元空间）\n * 直接内存（非运行时数据区的一部分）\n\n\n# 程序计数器\n\n程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。\n\n另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。\n\n从上面的介绍中我们知道程序计数器主要有两个作用：\n\n 1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\n 2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\n\n注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。\n\n\n# Java 虚拟机栈\n\nJava虚拟机栈主要给 Java方法使用，所有的 Java 方法调用都是通过栈实现的。方法调用的数据通过栈进行传递，每一次方法调用都有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。\n\n栈由一个个栈帧组成，每个栈帧都拥有：局部变量表、操作数栈、动态链接、方法返回地址。\n\n\n\n * 局部变量表： 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。\n * 操作数栈：用于存放方法执行过程中产生的中间计算结果和计算过程中产生的临时变量\n * 动态链接：主要服务于一个方法需要调用其他方法的场景。 在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在 Class 文件的常量池里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。\n * 方法返回地址： Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， 栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。\n\n程序运行中Java虚拟机栈可能会出现两种错误：\n\n * StackOverFlowError： 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError错误。\n * OutOfMemoryError： 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常\n\n\n# 本地方法栈\n\n和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\n\n本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。\n\n方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError和 OutOfMemoryError 两种错误。\n\n\n# 堆\n\nJava 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。\n\nJava 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代。新生代又有Eden空间、From Survivor空间、To Survivor空间三部分。\n\n堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：\n\n 1. java.lang.OutOfMemoryError: GC Overhead Limit Exceeded ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。\n 2. java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过-Xmx参数配置，若没有特别配置，将会使用默认值。）\n\n\n# 方法区\n\n方法区是一块逻辑区域，Java 虚拟机规范只是规定了方法区的概念和作用，不同的虚拟机方法区的实现也是不同的。\n\n当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。\n\n方法区、永久代、元空间关系？\n\n方法区和永久代以及元空间的关系有点像Java中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作方法区，也就是永久代和元空间是虚拟机对虚拟机规范中方法区的两种实现方式。 永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。",normalizedContent:"# 运行时数据区\n\njava 运行时数据区分为：\n\n线程私有的：\n\n * 程序计数器\n * java 虚拟机栈\n * 本地方法栈\n\n线程共享的：\n\n * 堆\n * 方法区（永久代/元空间）\n * 直接内存（非运行时数据区的一部分）\n\n\n# 程序计数器\n\n程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。\n\n另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。\n\n从上面的介绍中我们知道程序计数器主要有两个作用：\n\n 1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\n 2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\n\n注意：程序计数器是唯一一个不会出现 outofmemoryerror 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。\n\n\n# java 虚拟机栈\n\njava虚拟机栈主要给 java方法使用，所有的 java 方法调用都是通过栈实现的。方法调用的数据通过栈进行传递，每一次方法调用都有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。\n\n栈由一个个栈帧组成，每个栈帧都拥有：局部变量表、操作数栈、动态链接、方法返回地址。\n\n\n\n * 局部变量表： 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。\n * 操作数栈：用于存放方法执行过程中产生的中间计算结果和计算过程中产生的临时变量\n * 动态链接：主要服务于一个方法需要调用其他方法的场景。 在 java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（symbilic reference）保存在 class 文件的常量池里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。\n * 方法返回地址： java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， 栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。\n\n程序运行中java虚拟机栈可能会出现两种错误：\n\n * stackoverflowerror： 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 java 虚拟机栈的最大深度的时候，就抛出 stackoverflowerror错误。\n * outofmemoryerror： 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出outofmemoryerror异常\n\n\n# 本地方法栈\n\n和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 native 方法服务。 在 hotspot 虚拟机中和 java 虚拟机栈合二为一。\n\n本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。\n\n方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 stackoverflowerror和 outofmemoryerror 两种错误。\n\n\n# 堆\n\njava 虚拟机所管理的内存中最大的一块，java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。\n\njava 堆是垃圾收集器管理的主要区域，因此也被称作 gc 堆（garbage collected heap）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以java堆中还可以细分为：新生代和老年代。新生代又有eden空间、from survivor空间、to survivor空间三部分。\n\n堆这里最容易出现的就是 outofmemoryerror 错误，并且出现这种错误之后的表现形式还会有几种，比如：\n\n 1. java.lang.outofmemoryerror: gc overhead limit exceeded ： 当 jvm 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。\n 2. java.lang.outofmemoryerror: java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过-xmx参数配置，若没有特别配置，将会使用默认值。）\n\n\n# 方法区\n\n方法区是一块逻辑区域，java 虚拟机规范只是规定了方法区的概念和作用，不同的虚拟机方法区的实现也是不同的。\n\n当虚拟机要使用一个类时，它需要读取并解析 class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。\n\n方法区、永久代、元空间关系？\n\n方法区和永久代以及元空间的关系有点像java中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作方法区，也就是永久代和元空间是虚拟机对虚拟机规范中方法区的两种实现方式。 永久代是 jdk 1.8 之前的方法区实现，jdk 1.8 及以后方法区的实现变成了元空间。",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"JVM 调优",frontmatter:{title:"JVM 调优",date:"2023-10-23T23:55:07.000Z",permalink:"/pages/b8b917/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/03.Java/05.JVM/05.JVM%20%E8%B0%83%E4%BC%98.html",relativePath:"01.Java 知识体系/03.Java/05.JVM/05.JVM 调优.md",key:"v-76d58b51",path:"/pages/b8b917/",headers:[{level:2,title:"调优原则",slug:"调优原则",normalizedTitle:"调优原则",charIndex:366},{level:2,title:"调优关键指标",slug:"调优关键指标",normalizedTitle:"调优关键指标",charIndex:462},{level:3,title:"吞吐量",slug:"吞吐量",normalizedTitle:"吞吐量",charIndex:44},{level:3,title:"延迟或响应时间",slug:"延迟或响应时间",normalizedTitle:"延迟或响应时间",charIndex:663},{level:3,title:"内存占用",slug:"内存占用",normalizedTitle:"内存占用",charIndex:765},{level:1,title:"JVM调优主要步骤",slug:"jvm调优主要步骤",normalizedTitle:"jvm调优主要步骤",charIndex:869},{level:1,title:"JVM调优实践",slug:"jvm调优实践",normalizedTitle:"jvm调优实践",charIndex:1257},{level:2,title:"分析GC日志",slug:"分析gc日志",normalizedTitle:"分析gc日志",charIndex:889},{level:3,title:"初始参数设置",slug:"初始参数设置",normalizedTitle:"初始参数设置",charIndex:1280},{level:3,title:"GC日志解读",slug:"gc日志解读",normalizedTitle:"gc日志解读",charIndex:2379},{level:3,title:"GC日志可视化分析",slug:"gc日志可视化分析",normalizedTitle:"gc日志可视化分析",charIndex:3554},{level:5,title:"1) JVM内存占用情况：",slug:"_1-jvm内存占用情况",normalizedTitle:"1) jvm内存占用情况：",charIndex:3646},{level:5,title:"2) 关键性能指标：",slug:"_2-关键性能指标",normalizedTitle:"2) 关键性能指标：",charIndex:3954},{level:5,title:"3) GC 可视化交互聚合结果",slug:"_3-gc-可视化交互聚合结果",normalizedTitle:"3) gc 可视化交互聚合结果",charIndex:4128},{level:5,title:"4) GC 统计",slug:"_4-gc-统计",normalizedTitle:"4) gc 统计",charIndex:4207},{level:5,title:"5) GC原因：",slug:"_5-gc原因",normalizedTitle:"5) gc原因：",charIndex:4290},{level:2,title:"堆内存与元空间优化",slug:"堆内存与元空间优化",normalizedTitle:"堆内存与元空间优化",charIndex:4827},{level:2,title:"堆内存内部优化：新生代和老年代比例",slug:"堆内存内部优化-新生代和老年代比例",normalizedTitle:"堆内存内部优化：新生代和老年代比例",charIndex:5048},{level:2,title:"垃圾回收器优化",slug:"垃圾回收器优化",normalizedTitle:"垃圾回收器优化",charIndex:5359},{level:3,title:"G1垃圾收集器（重点）",slug:"g1垃圾收集器-重点",normalizedTitle:"g1垃圾收集器（重点）",charIndex:5625},{level:4,title:"G1垃圾收集器的工作原理",slug:"g1垃圾收集器的工作原理",normalizedTitle:"g1垃圾收集器的工作原理",charIndex:5847},{level:4,title:"G1收集器相关参数",slug:"g1收集器相关参数",normalizedTitle:"g1收集器相关参数",charIndex:6366},{level:1,title:"JVM调优案例",slug:"jvm调优案例",normalizedTitle:"jvm调优案例",charIndex:6845},{level:2,title:"调优案例：metaspace导致频繁FGC问题",slug:"调优案例-metaspace导致频繁fgc问题",normalizedTitle:"调优案例：metaspace导致频繁fgc问题",charIndex:6857},{level:2,title:"调优案例：YGG和OLD GC频繁",slug:"调优案例-ygg和old-gc频繁",normalizedTitle:"调优案例：ygg和old gc频繁",charIndex:6887},{level:2,title:"调优案例：OLD GC耗时较长影响业务",slug:"调优案例-old-gc耗时较长影响业务",normalizedTitle:"调优案例：old gc耗时较长影响业务",charIndex:6911},{level:2,title:"调优案例：YGC耗时增加",slug:"调优案例-ygc耗时增加",normalizedTitle:"调优案例：ygc耗时增加",charIndex:6985},{level:2,title:"调优案例：YCG次数增加",slug:"调优案例-ycg次数增加",normalizedTitle:"调优案例：ycg次数增加",charIndex:7084}],headersStr:"调优原则 调优关键指标 吞吐量 延迟或响应时间 内存占用 JVM调优主要步骤 JVM调优实践 分析GC日志 初始参数设置 GC日志解读 GC日志可视化分析 1) JVM内存占用情况： 2) 关键性能指标： 3) GC 可视化交互聚合结果 4) GC 统计 5) GC原因： 堆内存与元空间优化 堆内存内部优化：新生代和老年代比例 垃圾回收器优化 G1垃圾收集器（重点） G1垃圾收集器的工作原理 G1收集器相关参数 JVM调优案例 调优案例：metaspace导致频繁FGC问题 调优案例：YGG和OLD GC频繁 调优案例：OLD GC耗时较长影响业务 调优案例：YGC耗时增加 调优案例：YCG次数增加",content:"为什么要进行JVM调优？\n\n调优的最终目的都是为了应用程序使用最小的硬件消耗来承载更大的吞吐量。\n\njvm调优主要是针对垃圾收集器的收集性能优化，减少GC的频率和Full GC的次数，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量和减少暂停时间。\n\n什么时候进行JVM调优?\n\n 1. 系统吞吐量与响应性能不高或下降；\n 2. Heap内存（老年代）持续上涨达到设置的最大内存值；\n 3. Full GC 次数频繁；\n 4. GC 停顿时间过长（超过 1 秒）；\n 5. 应用出现OutOfMemory 等内存异常；\n 6. 应用中有使用本地缓存且占用大量内存空间；\n\n调优调什么？\n\n内存分配+垃圾回收\n\n 1. 合理使用堆内存\n 2. GC高效回收占用的内存的垃圾对象\n 3. GC高效释放掉内存空间\n\n\n# 调优原则\n\n * 优先原则：优先架构调优和代码调优，JVM优化是不得已的手段\n   * 大多数的Java应用不需要进行JVM优化\n * 观测性原则：发现问题解决问题，没有问题不找问题\n\n\n# 调优关键指标\n\n\n# 吞吐量\n\n重要指标之一，吞吐量是衡量系统在单位时间里面完成的工作数量。吞吐量需求通常忽略延迟或者响应时间。通常情况下，提升吞吐量需要以系统响应变慢和更多内存消耗作为代价。\n\n * TPS：每秒事务数\n * Throughput：吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是99%。\n\n\n# 延迟或响应时间\n\n延迟或者响应时间是衡量应用从接收到一个任务到完成这个任务消耗的时间。一个延迟或者响应时间的需求需要忽略吞吐量。通常来讲，提升应用的响应时间需要以更低吞吐量或提高应用的内存消耗。\n\n\n# 内存占用\n\n内存占用是衡量应用消耗的内存，这个内存占用是指应用在运行在某一个吞吐量、延迟以及可用性和易管理性指标下的内存消耗，内存占用是通常描述为应用运行的时候Java堆的大小或者总共需要消耗内存。\n\n\n# JVM调优主要步骤\n\n * 第一步：监控分析GC日志\n\n * 第二步：判断JVM问题：\n   \n   * 如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化\n   \n   * 如果GC时间超过1-3秒，或者频繁GC，则必须优化。\n\n * 第三步：确定调优目标\n\n * 第四步：调整参数\n   \n   * 调优一般是从满足程序的内存使用需求开始，之后是时间延迟要求，最后才是吞吐量要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行之。\n\n * 第五步：对比调优前后差距\n\n * 第六步：重复： 1 、 2 、 3 、 4 、 5 步骤\n   \n   * 找到最佳JVM参数设置\n\n * 第七步：应用JVM到应用服务器：\n   \n   * 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。\n\n\n# JVM调优实践\n\n\n# 分析GC日志\n\n\n# 初始参数设置\n\nJvm调优典型参数设置;\n\n 1. -Xms堆内存的最小值：\n    \n    * 默认情况下，当堆中可用内存小于40%时，堆内存会开始增加，一直增加到-Xmx的大小。\n\n 2. -Xmx堆内存的最大值：\n    \n    默认值是总内存/64（且小于1G）\n    \n    * 默认情况下，当堆中可用内存大于70%时，堆内存会开始减少，一直减小到-Xms的大小；\n\n 3. -Xmn新生代内存的最大值：\n    \n    * 1.包括Eden区和两个Survivor区的总和\n    * 2.配置写法如：-Xmn1024k，-Xmn1024m，-Xmn1g\n\n 4. -Xss每个线程的栈内存：\n    \n    * 默认1M，一般来说是不需要改。线程栈越小意味着可以创建的线程数越多\n\n整个堆的大小 = 年轻代大小 + 年老代大小，堆的大小不包含元空间大小，如果增大了年轻代，年老代相应就会减小，官方默认的配置为年老代大小/年轻代大小=2/1左右；\n\n建议在开发测试环境可以用Xms和Xmx分别设置最小值最大值，但是在线上生产环境，Xms和Xmx设置的值必须一样，防止抖动\n\n默认的配置是否存在性能瓶颈。如果想要确定JVM性能问题瓶颈，需要进一步分析GC日志\n\n 1. -XX:+PrintGCDetails 开启GC日志创建更详细的GC日志 ，默认情况下，GC日志是关闭的\n\n 2. -XX:+PrintGCTimeStamps，-XX:+PrintGCDateStamps\n    \n    开启GC时间提示\n    \n    * 开启时间便于我们更精确地判断几次GC操作之间的时两个参数的区别\n    * 时间戳是相对于 0 （依据JVM启动的时间）的值，而日期戳（date stamp）是实际的日期字符串\n    * 由于日期戳需要进行格式化，所以它的效率可能会受轻微的影响，不过这种操作并不频繁，它造成的影响也很难被我们感知。\n\n 3. -XX:+PrintHeapAtGC 打印堆的GC日志\n\n 4. -Xloggc:./logs/gc.log 指定GC日志路径\n\n这里，我们是在window下面进行测试，idea配置如下：\n\n\n\n> -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -Xloggc:E:/logs/gc-default.log\n> \n> 这样就会在e盘下logs文件夹下面，生成gc-default.log日志\n\n\n\n\n# GC日志解读\n\nYoung GC 日志含义\n\n2022-08-05T13:45:23.336+0800: 4.866: [GC (Metadata GC Threshold) [PSYoungGen: 136353K->20975K(405504K)] 160049K->48437K(720384K), 0.0092260 secs] [Times: user=0.00 sys=0.02, real=0.02 secs] \n\n\n\n这里的内容，我们一个一个解析：\n\n2022-08-05T13:45:23.336+0800: 本次GC发生时间\n4.866: 举例启动应用的时间\n[GC【表示GC的类型，youngGC】 (Metadata GC Threshold) 元空间超阈值\n[PSYoungGen: 136353K->20975K(405504K年轻代总空间)] 160049K->48437K(720384K)整堆), 0.0092260 secs本次垃圾回收耗时]\n[Times: user=0.00本次GC消耗CPU的时间 sys=0.02系统暂停时间, real=0.02 secs实际应用暂停时间]\n\n\n\n\nFullGC 日志含义\n\n2022-08-05T20:24:47.815+0800: 6.955: [Full GC (Metadata GC Threshold) [PSYoungGen: 701K->0K(72704K)] [ParOldGen: 38678K->35960K(175104K)] 39380K->35960K(247808K), [Metaspace: 56706K->56706K(1099776K)], 0.1921975 secs] [Times: user=1.03 sys=0.00, real=0.19 secs] \n\n\n\n这里的内容，我们也是一个一个解析：\n\n2022-08-05T20:24:47.815+0800:\n6.955: 刚启动服务就Full GC【整堆回收！！】\n\n[Full GC (Metadata GC Threshold) Metaspace空间超限！\n[PSYoungGen: 701K->0K(72704K)] 年轻代没有回收空间\n[ParOldGen: 38678K->35960K(175104K)] 39380K->35960K(247808K), 老年代也没有到阈值，整堆更没有到阈值\n[Metaspace: 56706K->56706K(1099776K)], 0.1921975 secs]\n[Times: user=1.03本次GC消耗CPU的时间 sys=0.00系统暂停时间, real=0.19 secs实际应用暂停时间] \n\n\n\n\n\n# GC日志可视化分析\n\n分析GC日志，就必须让GC日志输出到一个文件中，然后使用GC日志分析工具（gceasy.io/) 进行分析\n\n\n\n> 这里分析完之后，可以下载分析报告\n\n\n\n# 1) JVM内存占用情况：\n\n\n\nGENERATION【区域】                 ALLOCATED【最大值】   PEAK【占用峰值】\nYoung Generation【年轻代】          74.5 mb          74.47 mb\nOld Generation【老年轻代】           171 mb           95.62 mb\nMeta Space【元空间】                1.05 gb          55.38 mb\nYoung + Old + Meta space【整体】   1.3 gb           212.64 mb\n\n# 2) 关键性能指标：\n\n\n\n1 、吞吐量： 百分比越高表明GC开销越低。这个指标反映了JVM的吞吐量。\n\n * Throughput：97.043%\n\n2 、GC 延迟：Latency\n\n * Avg Pause GC Time： 7.80 ms 平均GC暂停时间\n * Max Pause GC Time： 190 ms 最大GC暂停时间\n\n# 3) GC 可视化交互聚合结果\n\n\n\n由上图可以看到，发生了3次full gc\n\n存在问题：一开始就发生了 3 次full gc , 很明显不太正常；\n\n# 4) GC 统计\n\n\n\nGC Statistics：GC统计\n\n由上图可以得到，发生gc的总次数，young gc，full gc的统计，gc 暂停时间统计。\n\n# 5) GC原因：\n\n\n\n原因                      次数   平均时间      最大时间      总耗时\nMetadata GC Threshold   6    43.3 ms   190 ms    260 ms\nAllocation Failure      53   3.77 ms   10.0 ms   200 ms\n\n这里对这些原因解析一下：\n\n 1. Metadata GC Threshold： 元空间超阈值\n 2. Allocation Failure ：年轻代空间不足\n\n> 这里补充一个原因，本案例还没出现的\n\n 3. Ergonomics：译文是“人体工程学”，GC中的Ergonomics含义是负责自动调解gc暂停时间和吞吐量之间平衡从而产生的GC。目的是使得虚拟机性能更好的一种做法。\n\n----------------------------------------\n\n由此可见，通过可视化的工具，可以快速的帮我们分析GC的日志。我们得善于利用工具。\n\n因为gc的日志文件，内容太多，都是密密麻麻的数字，文本。看得实在是头疼。\n\n有了gc easy可视化工具，而且还是在线的，十分的方便。GC日志分析是免费的\n\n\n# 堆内存与元空间优化\n\n元空间默认初始大小为20.75MB，调整元空间大小需要Full GC。对于8G物理内存的机器来说，一般将这两个值都设置为256M（可根据时间情况进行调整）。\n\n元空间优化：Metaspace 太小，会频繁触发Full GC。增加Metaspace空间大小。参数-XX:MetaspaceSize=N，设置元空间大小为128MB。\n\n堆内存：参数-Xms和-Xmx。增大堆内存。增加年轻代和老年代的空间，减少GC\n\n\n# 堆内存内部优化：新生代和老年代比例\n\n年轻代和老年代大小默认比例： 1 : 2。默认比例大部分都是最合适的。\n\n使用-XX:NewRetio = 4 表示young和old所占比值为1:4。年轻代设置太小，young gc次数变多了，这也有点影响性能。\n\n> 避免新生代设置过小，当新生代设置过小时，会产生两种比较明显的现象，一是minor GC次数频繁，二是可能导致 minor GC对象直接进入老年代。当老年代内存不足时，会触发Full GC。\n> \n> 避免新生代设置过大，当新生代设置过大时，会带来两个问题：一是老年大变小，可能导致FullGC频繁执行；二是 minor GC 执行回收的时间大幅度增加。\n\n\n# 垃圾回收器优化\n\n吞吐量优化ps+po：\n\n * Perallel-Scavenge垃圾收集器：-XX:+UsePerallelGC\n\n * Perallel-Old垃圾收集器【po是ps的老年代并行收集版本】：-XX：+UsePerallelOldGC\n\n响应时间优先parnew+cms：\n\n * ParNew垃圾收集器【Serial的收集器的多线程版本】：-XX:UseParNewGC\n\n * CMS垃圾收集器： 并发 收集器(非独占式)-XX:ConcMarkSweepGC【并发的标记清楚算法的GC垃圾收集器】\n\n\n# G1垃圾收集器（重点）\n\nG1中提供了三种模式垃圾回收模式， Young GC、Mixed GC 和 Full GC ，在不同的条件下被触发。\n\nG1的使用步骤：\n\n * 配置开启G1\n * 设置堆的最大内存\n * 设置GC最大暂停时间：设置100-300之间是比较合理：\n   * 如果设置的GC的暂停时间比较小，系统吞吐量会降低\n   * 默认的值是200,\n   * G1设计的目标：控制用户线程执行时间90%，GC占比时间10%\n\n# G1垃圾收集器的工作原理\n\nG1垃圾收集器相对比其他收集器而言，最大的区别在于它取消了 年轻代、老年代的物理划分， 取而代之的是将堆划分为若干个区域（Region），这些区域中包含了有逻辑上的年轻代、老年代区域。\n\n这样做的好处就是，我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。\n\n在G1划分的区域中，年轻代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。\n\n这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。\n\nYoung GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。\n\nMixed GC：回收年轻代内存，同时也回收部分老年代的内存\n\nMixedGC什么时候触发？\n\n-XX:InitiatingHeapOccupancyPercent=n ，设置触发标记周期的 Java 堆占用率阈值。默认占用率是整个 Java 堆的 45%。\n\nMixedGC主要分为两步：\n\n 1. 全局并发标记\n 2. 拷贝存活对象\n\n# G1收集器相关参数\n\n# 使用 G1 垃圾收集器\n-XX:+UseG1GC\n\n# 设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到），默认值是 200 毫秒。\n-XX:MaxGCPauseMillis=\n\n# 设置的 G1 区域的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间。目标是根据最小的 Java 堆大小划分出约 2048 个区域。\n# 默认是堆内存的1/2000。\n-XX:G1HeapRegionSize=n\n\n# 设置 STW 工作线程数的值。将 n 的值设置为逻辑处理器的数量。n 的值与逻辑处理器的数量相同，最多为 8。\n-XX:ParallelGCThreads=n\n\n# 设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads)的 1/4 左右。\n-XX:ConcGCThreads=n\n\n# 设置触发标记周期的 Java 堆占用率阈值。默认占用率是整个 Java 堆的 45%。\n-XX:InitiatingHeapOccupancyPercent=n\n\n\n\n# JVM调优案例\n\n\n# 调优案例：metaspace导致频繁FGC问题\n\n\n\n\n# 调优案例：YGG和OLD GC频繁\n\n\n\n\n# 调优案例：OLD GC耗时较长影响业务\n\n原因：Remake阶段时间较长\n\n优化：-XX:+CMSScavengeBeforeRemark\n\n\n# 调优案例：YGC耗时增加\n\n原因：jackson进行反序列化时会将key进行String#intern，导致扫描时，GCRoot变大\n\n解决：禁用jackson的String#intern\n\n\n# 调优案例：YCG次数增加\n\n原因：-XX：MaxGCPauseMillis参数时间设置过小，导致JVM降低年轻代region\n\n解决：\n\n 1. 调大-XX：MaxGCPauseMillis值\n 2. 将年轻代region大小设置为固定值\n\n调优案例：",normalizedContent:"为什么要进行jvm调优？\n\n调优的最终目的都是为了应用程序使用最小的硬件消耗来承载更大的吞吐量。\n\njvm调优主要是针对垃圾收集器的收集性能优化，减少gc的频率和full gc的次数，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量和减少暂停时间。\n\n什么时候进行jvm调优?\n\n 1. 系统吞吐量与响应性能不高或下降；\n 2. heap内存（老年代）持续上涨达到设置的最大内存值；\n 3. full gc 次数频繁；\n 4. gc 停顿时间过长（超过 1 秒）；\n 5. 应用出现outofmemory 等内存异常；\n 6. 应用中有使用本地缓存且占用大量内存空间；\n\n调优调什么？\n\n内存分配+垃圾回收\n\n 1. 合理使用堆内存\n 2. gc高效回收占用的内存的垃圾对象\n 3. gc高效释放掉内存空间\n\n\n# 调优原则\n\n * 优先原则：优先架构调优和代码调优，jvm优化是不得已的手段\n   * 大多数的java应用不需要进行jvm优化\n * 观测性原则：发现问题解决问题，没有问题不找问题\n\n\n# 调优关键指标\n\n\n# 吞吐量\n\n重要指标之一，吞吐量是衡量系统在单位时间里面完成的工作数量。吞吐量需求通常忽略延迟或者响应时间。通常情况下，提升吞吐量需要以系统响应变慢和更多内存消耗作为代价。\n\n * tps：每秒事务数\n * throughput：吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是99%。\n\n\n# 延迟或响应时间\n\n延迟或者响应时间是衡量应用从接收到一个任务到完成这个任务消耗的时间。一个延迟或者响应时间的需求需要忽略吞吐量。通常来讲，提升应用的响应时间需要以更低吞吐量或提高应用的内存消耗。\n\n\n# 内存占用\n\n内存占用是衡量应用消耗的内存，这个内存占用是指应用在运行在某一个吞吐量、延迟以及可用性和易管理性指标下的内存消耗，内存占用是通常描述为应用运行的时候java堆的大小或者总共需要消耗内存。\n\n\n# jvm调优主要步骤\n\n * 第一步：监控分析gc日志\n\n * 第二步：判断jvm问题：\n   \n   * 如果各项参数设置合理，系统没有超时日志出现，gc频率不高，gc耗时不高，那么没有必要进行gc优化\n   \n   * 如果gc时间超过1-3秒，或者频繁gc，则必须优化。\n\n * 第三步：确定调优目标\n\n * 第四步：调整参数\n   \n   * 调优一般是从满足程序的内存使用需求开始，之后是时间延迟要求，最后才是吞吐量要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行之。\n\n * 第五步：对比调优前后差距\n\n * 第六步：重复： 1 、 2 、 3 、 4 、 5 步骤\n   \n   * 找到最佳jvm参数设置\n\n * 第七步：应用jvm到应用服务器：\n   \n   * 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。\n\n\n# jvm调优实践\n\n\n# 分析gc日志\n\n\n# 初始参数设置\n\njvm调优典型参数设置;\n\n 1. -xms堆内存的最小值：\n    \n    * 默认情况下，当堆中可用内存小于40%时，堆内存会开始增加，一直增加到-xmx的大小。\n\n 2. -xmx堆内存的最大值：\n    \n    默认值是总内存/64（且小于1g）\n    \n    * 默认情况下，当堆中可用内存大于70%时，堆内存会开始减少，一直减小到-xms的大小；\n\n 3. -xmn新生代内存的最大值：\n    \n    * 1.包括eden区和两个survivor区的总和\n    * 2.配置写法如：-xmn1024k，-xmn1024m，-xmn1g\n\n 4. -xss每个线程的栈内存：\n    \n    * 默认1m，一般来说是不需要改。线程栈越小意味着可以创建的线程数越多\n\n整个堆的大小 = 年轻代大小 + 年老代大小，堆的大小不包含元空间大小，如果增大了年轻代，年老代相应就会减小，官方默认的配置为年老代大小/年轻代大小=2/1左右；\n\n建议在开发测试环境可以用xms和xmx分别设置最小值最大值，但是在线上生产环境，xms和xmx设置的值必须一样，防止抖动\n\n默认的配置是否存在性能瓶颈。如果想要确定jvm性能问题瓶颈，需要进一步分析gc日志\n\n 1. -xx:+printgcdetails 开启gc日志创建更详细的gc日志 ，默认情况下，gc日志是关闭的\n\n 2. -xx:+printgctimestamps，-xx:+printgcdatestamps\n    \n    开启gc时间提示\n    \n    * 开启时间便于我们更精确地判断几次gc操作之间的时两个参数的区别\n    * 时间戳是相对于 0 （依据jvm启动的时间）的值，而日期戳（date stamp）是实际的日期字符串\n    * 由于日期戳需要进行格式化，所以它的效率可能会受轻微的影响，不过这种操作并不频繁，它造成的影响也很难被我们感知。\n\n 3. -xx:+printheapatgc 打印堆的gc日志\n\n 4. -xloggc:./logs/gc.log 指定gc日志路径\n\n这里，我们是在window下面进行测试，idea配置如下：\n\n\n\n> -xx:+printgcdetails -xx:+printgctimestamps -xx:+printgcdatestamps -xx:+printheapatgc -xloggc:e:/logs/gc-default.log\n> \n> 这样就会在e盘下logs文件夹下面，生成gc-default.log日志\n\n\n\n\n# gc日志解读\n\nyoung gc 日志含义\n\n2022-08-05t13:45:23.336+0800: 4.866: [gc (metadata gc threshold) [psyounggen: 136353k->20975k(405504k)] 160049k->48437k(720384k), 0.0092260 secs] [times: user=0.00 sys=0.02, real=0.02 secs] \n\n\n\n这里的内容，我们一个一个解析：\n\n2022-08-05t13:45:23.336+0800: 本次gc发生时间\n4.866: 举例启动应用的时间\n[gc【表示gc的类型，younggc】 (metadata gc threshold) 元空间超阈值\n[psyounggen: 136353k->20975k(405504k年轻代总空间)] 160049k->48437k(720384k)整堆), 0.0092260 secs本次垃圾回收耗时]\n[times: user=0.00本次gc消耗cpu的时间 sys=0.02系统暂停时间, real=0.02 secs实际应用暂停时间]\n\n\n\n\nfullgc 日志含义\n\n2022-08-05t20:24:47.815+0800: 6.955: [full gc (metadata gc threshold) [psyounggen: 701k->0k(72704k)] [paroldgen: 38678k->35960k(175104k)] 39380k->35960k(247808k), [metaspace: 56706k->56706k(1099776k)], 0.1921975 secs] [times: user=1.03 sys=0.00, real=0.19 secs] \n\n\n\n这里的内容，我们也是一个一个解析：\n\n2022-08-05t20:24:47.815+0800:\n6.955: 刚启动服务就full gc【整堆回收！！】\n\n[full gc (metadata gc threshold) metaspace空间超限！\n[psyounggen: 701k->0k(72704k)] 年轻代没有回收空间\n[paroldgen: 38678k->35960k(175104k)] 39380k->35960k(247808k), 老年代也没有到阈值，整堆更没有到阈值\n[metaspace: 56706k->56706k(1099776k)], 0.1921975 secs]\n[times: user=1.03本次gc消耗cpu的时间 sys=0.00系统暂停时间, real=0.19 secs实际应用暂停时间] \n\n\n\n\n\n# gc日志可视化分析\n\n分析gc日志，就必须让gc日志输出到一个文件中，然后使用gc日志分析工具（gceasy.io/) 进行分析\n\n\n\n> 这里分析完之后，可以下载分析报告\n\n\n\n# 1) jvm内存占用情况：\n\n\n\ngeneration【区域】                 allocated【最大值】   peak【占用峰值】\nyoung generation【年轻代】          74.5 mb          74.47 mb\nold generation【老年轻代】           171 mb           95.62 mb\nmeta space【元空间】                1.05 gb          55.38 mb\nyoung + old + meta space【整体】   1.3 gb           212.64 mb\n\n# 2) 关键性能指标：\n\n\n\n1 、吞吐量： 百分比越高表明gc开销越低。这个指标反映了jvm的吞吐量。\n\n * throughput：97.043%\n\n2 、gc 延迟：latency\n\n * avg pause gc time： 7.80 ms 平均gc暂停时间\n * max pause gc time： 190 ms 最大gc暂停时间\n\n# 3) gc 可视化交互聚合结果\n\n\n\n由上图可以看到，发生了3次full gc\n\n存在问题：一开始就发生了 3 次full gc , 很明显不太正常；\n\n# 4) gc 统计\n\n\n\ngc statistics：gc统计\n\n由上图可以得到，发生gc的总次数，young gc，full gc的统计，gc 暂停时间统计。\n\n# 5) gc原因：\n\n\n\n原因                      次数   平均时间      最大时间      总耗时\nmetadata gc threshold   6    43.3 ms   190 ms    260 ms\nallocation failure      53   3.77 ms   10.0 ms   200 ms\n\n这里对这些原因解析一下：\n\n 1. metadata gc threshold： 元空间超阈值\n 2. allocation failure ：年轻代空间不足\n\n> 这里补充一个原因，本案例还没出现的\n\n 3. ergonomics：译文是“人体工程学”，gc中的ergonomics含义是负责自动调解gc暂停时间和吞吐量之间平衡从而产生的gc。目的是使得虚拟机性能更好的一种做法。\n\n----------------------------------------\n\n由此可见，通过可视化的工具，可以快速的帮我们分析gc的日志。我们得善于利用工具。\n\n因为gc的日志文件，内容太多，都是密密麻麻的数字，文本。看得实在是头疼。\n\n有了gc easy可视化工具，而且还是在线的，十分的方便。gc日志分析是免费的\n\n\n# 堆内存与元空间优化\n\n元空间默认初始大小为20.75mb，调整元空间大小需要full gc。对于8g物理内存的机器来说，一般将这两个值都设置为256m（可根据时间情况进行调整）。\n\n元空间优化：metaspace 太小，会频繁触发full gc。增加metaspace空间大小。参数-xx:metaspacesize=n，设置元空间大小为128mb。\n\n堆内存：参数-xms和-xmx。增大堆内存。增加年轻代和老年代的空间，减少gc\n\n\n# 堆内存内部优化：新生代和老年代比例\n\n年轻代和老年代大小默认比例： 1 : 2。默认比例大部分都是最合适的。\n\n使用-xx:newretio = 4 表示young和old所占比值为1:4。年轻代设置太小，young gc次数变多了，这也有点影响性能。\n\n> 避免新生代设置过小，当新生代设置过小时，会产生两种比较明显的现象，一是minor gc次数频繁，二是可能导致 minor gc对象直接进入老年代。当老年代内存不足时，会触发full gc。\n> \n> 避免新生代设置过大，当新生代设置过大时，会带来两个问题：一是老年大变小，可能导致fullgc频繁执行；二是 minor gc 执行回收的时间大幅度增加。\n\n\n# 垃圾回收器优化\n\n吞吐量优化ps+po：\n\n * perallel-scavenge垃圾收集器：-xx:+useperallelgc\n\n * perallel-old垃圾收集器【po是ps的老年代并行收集版本】：-xx：+useperalleloldgc\n\n响应时间优先parnew+cms：\n\n * parnew垃圾收集器【serial的收集器的多线程版本】：-xx:useparnewgc\n\n * cms垃圾收集器： 并发 收集器(非独占式)-xx:concmarksweepgc【并发的标记清楚算法的gc垃圾收集器】\n\n\n# g1垃圾收集器（重点）\n\ng1中提供了三种模式垃圾回收模式， young gc、mixed gc 和 full gc ，在不同的条件下被触发。\n\ng1的使用步骤：\n\n * 配置开启g1\n * 设置堆的最大内存\n * 设置gc最大暂停时间：设置100-300之间是比较合理：\n   * 如果设置的gc的暂停时间比较小，系统吞吐量会降低\n   * 默认的值是200,\n   * g1设计的目标：控制用户线程执行时间90%，gc占比时间10%\n\n# g1垃圾收集器的工作原理\n\ng1垃圾收集器相对比其他收集器而言，最大的区别在于它取消了 年轻代、老年代的物理划分， 取而代之的是将堆划分为若干个区域（region），这些区域中包含了有逻辑上的年轻代、老年代区域。\n\n这样做的好处就是，我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。\n\n在g1划分的区域中，年轻代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者survivor空间，g1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。\n\n这就意味着，在正常的处理过程中，g1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。\n\nyoung gc主要是对eden区进行gc，它在eden空间耗尽时会被触发。\n\nmixed gc：回收年轻代内存，同时也回收部分老年代的内存\n\nmixedgc什么时候触发？\n\n-xx:initiatingheapoccupancypercent=n ，设置触发标记周期的 java 堆占用率阈值。默认占用率是整个 java 堆的 45%。\n\nmixedgc主要分为两步：\n\n 1. 全局并发标记\n 2. 拷贝存活对象\n\n# g1收集器相关参数\n\n# 使用 g1 垃圾收集器\n-xx:+useg1gc\n\n# 设置期望达到的最大gc停顿时间指标（jvm会尽力实现，但不保证达到），默认值是 200 毫秒。\n-xx:maxgcpausemillis=\n\n# 设置的 g1 区域的大小。值是 2 的幂，范围是 1 mb 到 32 mb 之间。目标是根据最小的 java 堆大小划分出约 2048 个区域。\n# 默认是堆内存的1/2000。\n-xx:g1heapregionsize=n\n\n# 设置 stw 工作线程数的值。将 n 的值设置为逻辑处理器的数量。n 的值与逻辑处理器的数量相同，最多为 8。\n-xx:parallelgcthreads=n\n\n# 设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (parallelgcthreads)的 1/4 左右。\n-xx:concgcthreads=n\n\n# 设置触发标记周期的 java 堆占用率阈值。默认占用率是整个 java 堆的 45%。\n-xx:initiatingheapoccupancypercent=n\n\n\n\n# jvm调优案例\n\n\n# 调优案例：metaspace导致频繁fgc问题\n\n\n\n\n# 调优案例：ygg和old gc频繁\n\n\n\n\n# 调优案例：old gc耗时较长影响业务\n\n原因：remake阶段时间较长\n\n优化：-xx:+cmsscavengebeforeremark\n\n\n# 调优案例：ygc耗时增加\n\n原因：jackson进行反序列化时会将key进行string#intern，导致扫描时，gcroot变大\n\n解决：禁用jackson的string#intern\n\n\n# 调优案例：ycg次数增加\n\n原因：-xx：maxgcpausemillis参数时间设置过小，导致jvm降低年轻代region\n\n解决：\n\n 1. 调大-xx：maxgcpausemillis值\n 2. 将年轻代region大小设置为固定值\n\n调优案例：",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"JVM 常用的调优工具",frontmatter:{title:"JVM 常用的调优工具",date:"2023-10-23T23:55:07.000Z",permalink:"/pages/2cdbc6/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/03.Java/05.JVM/04.JVM%20%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7.html",relativePath:"01.Java 知识体系/03.Java/05.JVM/04.JVM 常用的调优工具.md",key:"v-5c1cca71",path:"/pages/2cdbc6/",headers:[{level:1,title:"JDK工具包",slug:"jdk工具包",normalizedTitle:"jdk工具包",charIndex:2},{level:2,title:"jps",slug:"jps",normalizedTitle:"jps",charIndex:13},{level:2,title:"jstat",slug:"jstat",normalizedTitle:"jstat",charIndex:225},{level:2,title:"jinfo",slug:"jinfo",normalizedTitle:"jinfo",charIndex:1026},{level:2,title:"jmap",slug:"jmap",normalizedTitle:"jmap",charIndex:1251},{level:1,title:"VisualVM工具",slug:"visualvm工具",normalizedTitle:"visualvm工具",charIndex:1876},{level:1,title:"MemoryAnalyzer工具",slug:"memoryanalyzer工具",normalizedTitle:"memoryanalyzer工具",charIndex:2341},{level:1,title:"第三方 GCEasy",slug:"第三方-gceasy",normalizedTitle:"第三方 gceasy",charIndex:2552}],headersStr:"JDK工具包 jps jstat jinfo jmap VisualVM工具 MemoryAnalyzer工具 第三方 GCEasy",content:"# JDK工具包\n\n\n# jps\n\njps:Java Virtual Machine Process Status Tool\n\n查看Java进程 ，相当于Linux下的ps命令，只不过它只列出Java进程。\n\njps ：列出Java程序进程ID和Main函数名称\njps -q ：只输出进程ID\njps -m ：输出传递给Java进程（主函数）的参数\njps -l ：输出主函数的完整路径\njps -v ：显示传递给Java虚拟的参数\n\n\n\n\n\n# jstat\n\njstat:JVM Statistics Monitoring Tool\n\njstat可以查看Java程序运行时相关信息，可以通过它查看堆信息的相关情况\n\njstat -<options> [-t] [-h<lines>] <vmid> [<interval> [<count>]]\n\n\noptions：由以下值构成\n-class：显示ClassLoader的相关信息\n-compiler：显示JIT编译的相关信息\n-gc：显示与GC相关信息\n-gccapacity：显示各个代的容量和使用情况\n-gccause：显示垃圾收集相关信息（同-gcutil），同时显示最后一次或当前正在发生的垃圾收集的诱发原因\n-gcnew：显示新生代信息\n-gcnewcapacity：显示新生代大小和使用情况\n-gcold：显示老年代信息\n-gcoldcapacity：显示老年代大小\n-gcpermcapacity：显示永久代大小\n-gcutil：显示垃圾收集信息\n\n\n示例：\n\njstat -gcutil pid 5s 5\n# 5s每隔 5 秒采样一次\n# 5采样五次\n\n\n\n\nS0  年轻代中第一个survivor（幸存区）已使用的占当前容量百分比\nS1  年轻代中第二个survivor（幸存区）已使用的占当前容量百分比\nE   年轻代中Eden（伊甸园）已使用的占当前容量百分比\nO   old代已使用的占当前容量百分比\nM   metaspace已使用的占当前容量百分比\nCCS 压缩使用比例\nYGC 从应用程序启动到采样时年轻代中gc次数\nYGCT 从应用程序启动到采样时年轻代中gc所用时间(s)\nFGC 从应用程序启动到采样时old代(全gc)gc次数\nFGCT 从应用程序启动到采样时old代(全gc)gc所用时间(s)\nGCT 从应用程序启动到采样时gc用的总时间(s)\n\n\n\n# jinfo\n\njinfo：Java Configuration Info\n\njinfo可以用来查看正在运行的java程序的扩展参数，甚至支持运行时，修改部分参数\n\njinfo [option] <pid>\n\n\n-flags 打印虚拟机 VM 参数\n-flag <name> 打印指定虚拟机 VM 参数\n-flag [+|-]<name> 打开或关闭虚拟机参数\n-flag <name>=<value> 设置指定虚拟机参数的值\n\n\n示例：\n\n\n\n\n# jmap\n\njmap:Memory Map\n\njmap用来查看堆内存使用状况，一般结合jhat使用。\n\n参数：\n\noption： 选项参数。\npid： 需要打印配置信息的进程ID。\nexecutable： 产生核心dump的Java可执行文件。\ncore： 需要打印配置信息的核心文件。\nserver-id： 可选的唯一id，如果相同的远程主机上运行了多台调试服务器，用此选项参数标识服务器。\nremote server IP or hostname 远程调试服务器的IP地址或主机名。\n\noption\nno option： 查看进程的内存映像信息,类似 Solaris pmap 命令。\nheap： 显示Java堆详细信息\nhisto[:live]： 显示堆中对象的统计信息\nclstats：打印类加载器信息\nfinalizerinfo： 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象\n\ndump:<dump-options>：生成堆转储快照\nF： 当-dump没有响应时，使用-dump或者-histo参数. 在这个模式下,live子参数无效.\nhelp：打印帮助信息\nJ<flag>：指定传递给运行jmap的JVM的参数\n\n\n\n示例：heap\n\n命令：jmap -heap pid\n\n描述：显示Java堆详细信息\n\n打印一个堆的摘要信息，包括使用的GC算法、堆配置信息和各内存区域内存使用信息\n\n\n\n\n# VisualVM工具\n\n开发大型 Java 应用程序的过程中难免遇到内存泄露、性能瓶颈等问题，比如文件、网络、数据库的连接未释放，未优化的算法等。\n\n随着应用程序的持续运行，可能会造成整个系统运行效率下降，严重的则会造成系统崩溃。为了找出程序中隐藏的这些问题，在项目开发后期往往会使用性能分析工具来对应用程序的性能进行分析和优化。\n\nVisualVM 是一款免费的性能分析工具。同时，它能自动选择更快更轻量级的技术尽量减少性能分析对应用程序造成的影响，提高性能分析的精度。\n\n一般来说，jdk都会自带该工具，具体的路径，为安装的jdk路径下面。\n\n\n\n\n\n直接可以监控到java进程，双击打开需要监控的java进程即可。\n\n使用 visual gc插件分析GC\n\n安装 visual gc参考：https://www.cnblogs.com/seamy/p/15649609.html\n\nvisual gc 使用介绍参考：https://www.cnblogs.com/reycg-blog/p/7805075.html\n\n\n# MemoryAnalyzer工具\n\nMemory Analyzer (Eclipse MAT)是一个跨平台的开源工具，您不仅可以用它来分析内存问题，也可以用来监控整个 Java 应用程序的状态和行为。通过读取应用程序运行时由 Java 运行时环境生成的转储文件快照，Memory Analyzer 使您能够分析那些调试代码可能无法发现的复杂问题。\n\n可以分析我们的heap dump文件，快速找到内存泄漏的地方。\n\n\n# 第三方 GCEasy\n\n> gceasy.io/\n\n业界首先采用机器学习算法解决GC日志分析问题，GCeasy内置机器智能可以自动检测JVM和Android GC日志中的问题，并推荐解决方案。\n\nGC日志分析是免费的， Machine Learning 收费\n\n * 几秒内解决GC和内存问题\n * JVM堆优化建议\n * 机器学习算法",normalizedContent:"# jdk工具包\n\n\n# jps\n\njps:java virtual machine process status tool\n\n查看java进程 ，相当于linux下的ps命令，只不过它只列出java进程。\n\njps ：列出java程序进程id和main函数名称\njps -q ：只输出进程id\njps -m ：输出传递给java进程（主函数）的参数\njps -l ：输出主函数的完整路径\njps -v ：显示传递给java虚拟的参数\n\n\n\n\n\n# jstat\n\njstat:jvm statistics monitoring tool\n\njstat可以查看java程序运行时相关信息，可以通过它查看堆信息的相关情况\n\njstat -<options> [-t] [-h<lines>] <vmid> [<interval> [<count>]]\n\n\noptions：由以下值构成\n-class：显示classloader的相关信息\n-compiler：显示jit编译的相关信息\n-gc：显示与gc相关信息\n-gccapacity：显示各个代的容量和使用情况\n-gccause：显示垃圾收集相关信息（同-gcutil），同时显示最后一次或当前正在发生的垃圾收集的诱发原因\n-gcnew：显示新生代信息\n-gcnewcapacity：显示新生代大小和使用情况\n-gcold：显示老年代信息\n-gcoldcapacity：显示老年代大小\n-gcpermcapacity：显示永久代大小\n-gcutil：显示垃圾收集信息\n\n\n示例：\n\njstat -gcutil pid 5s 5\n# 5s每隔 5 秒采样一次\n# 5采样五次\n\n\n\n\ns0  年轻代中第一个survivor（幸存区）已使用的占当前容量百分比\ns1  年轻代中第二个survivor（幸存区）已使用的占当前容量百分比\ne   年轻代中eden（伊甸园）已使用的占当前容量百分比\no   old代已使用的占当前容量百分比\nm   metaspace已使用的占当前容量百分比\nccs 压缩使用比例\nygc 从应用程序启动到采样时年轻代中gc次数\nygct 从应用程序启动到采样时年轻代中gc所用时间(s)\nfgc 从应用程序启动到采样时old代(全gc)gc次数\nfgct 从应用程序启动到采样时old代(全gc)gc所用时间(s)\ngct 从应用程序启动到采样时gc用的总时间(s)\n\n\n\n# jinfo\n\njinfo：java configuration info\n\njinfo可以用来查看正在运行的java程序的扩展参数，甚至支持运行时，修改部分参数\n\njinfo [option] <pid>\n\n\n-flags 打印虚拟机 vm 参数\n-flag <name> 打印指定虚拟机 vm 参数\n-flag [+|-]<name> 打开或关闭虚拟机参数\n-flag <name>=<value> 设置指定虚拟机参数的值\n\n\n示例：\n\n\n\n\n# jmap\n\njmap:memory map\n\njmap用来查看堆内存使用状况，一般结合jhat使用。\n\n参数：\n\noption： 选项参数。\npid： 需要打印配置信息的进程id。\nexecutable： 产生核心dump的java可执行文件。\ncore： 需要打印配置信息的核心文件。\nserver-id： 可选的唯一id，如果相同的远程主机上运行了多台调试服务器，用此选项参数标识服务器。\nremote server ip or hostname 远程调试服务器的ip地址或主机名。\n\noption\nno option： 查看进程的内存映像信息,类似 solaris pmap 命令。\nheap： 显示java堆详细信息\nhisto[:live]： 显示堆中对象的统计信息\nclstats：打印类加载器信息\nfinalizerinfo： 显示在f-queue队列等待finalizer线程执行finalizer方法的对象\n\ndump:<dump-options>：生成堆转储快照\nf： 当-dump没有响应时，使用-dump或者-histo参数. 在这个模式下,live子参数无效.\nhelp：打印帮助信息\nj<flag>：指定传递给运行jmap的jvm的参数\n\n\n\n示例：heap\n\n命令：jmap -heap pid\n\n描述：显示java堆详细信息\n\n打印一个堆的摘要信息，包括使用的gc算法、堆配置信息和各内存区域内存使用信息\n\n\n\n\n# visualvm工具\n\n开发大型 java 应用程序的过程中难免遇到内存泄露、性能瓶颈等问题，比如文件、网络、数据库的连接未释放，未优化的算法等。\n\n随着应用程序的持续运行，可能会造成整个系统运行效率下降，严重的则会造成系统崩溃。为了找出程序中隐藏的这些问题，在项目开发后期往往会使用性能分析工具来对应用程序的性能进行分析和优化。\n\nvisualvm 是一款免费的性能分析工具。同时，它能自动选择更快更轻量级的技术尽量减少性能分析对应用程序造成的影响，提高性能分析的精度。\n\n一般来说，jdk都会自带该工具，具体的路径，为安装的jdk路径下面。\n\n\n\n\n\n直接可以监控到java进程，双击打开需要监控的java进程即可。\n\n使用 visual gc插件分析gc\n\n安装 visual gc参考：https://www.cnblogs.com/seamy/p/15649609.html\n\nvisual gc 使用介绍参考：https://www.cnblogs.com/reycg-blog/p/7805075.html\n\n\n# memoryanalyzer工具\n\nmemory analyzer (eclipse mat)是一个跨平台的开源工具，您不仅可以用它来分析内存问题，也可以用来监控整个 java 应用程序的状态和行为。通过读取应用程序运行时由 java 运行时环境生成的转储文件快照，memory analyzer 使您能够分析那些调试代码可能无法发现的复杂问题。\n\n可以分析我们的heap dump文件，快速找到内存泄漏的地方。\n\n\n# 第三方 gceasy\n\n> gceasy.io/\n\n业界首先采用机器学习算法解决gc日志分析问题，gceasy内置机器智能可以自动检测jvm和android gc日志中的问题，并推荐解决方案。\n\ngc日志分析是免费的， machine learning 收费\n\n * 几秒内解决gc和内存问题\n * jvm堆优化建议\n * 机器学习算法",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"Spring Bean",frontmatter:{title:"Spring Bean",date:"2023-10-24T03:39:10.000Z",permalink:"/pages/47235b/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/04.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/01.%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/01.Spring/01.Spring%20Bean.html",relativePath:"01.Java 知识体系/04.系统设计/01.常用框架/01.Spring/01.Spring Bean.md",key:"v-17d22485",path:"/pages/47235b/",headers:[{level:1,title:"Spring bean简介",slug:"spring-bean简介",normalizedTitle:"spring bean简介",charIndex:2},{level:1,title:"Spring Bean 常用注解",slug:"spring-bean-常用注解",normalizedTitle:"spring bean 常用注解",charIndex:783},{level:1,title:"bean生命周期",slug:"bean生命周期",normalizedTitle:"bean生命周期",charIndex:1664},{level:2,title:"实践：@PostConstruct和@PreDestroy替代方案",slug:"实践-postconstruct和-predestroy替代方案",normalizedTitle:"实践：@postconstruct和@predestroy替代方案",charIndex:2528},{level:1,title:"reference",slug:"reference",normalizedTitle:"reference",charIndex:3507}],headersStr:"Spring bean简介 Spring Bean 常用注解 bean生命周期 实践：@PostConstruct和@PreDestroy替代方案 reference",content:'# Spring bean简介\n\nbean 指的是那些被 IoC 容器所管理的对象。\n\nSpring 中 Bean 的作用域通常有下面几种：\n\n * singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。\n * prototype : 每次请求都会创建一个新的 bean 实例。每次getBean都会重新创建一个bean。\n * request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。\n * session : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。\n * global-session ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话\n\n多线程下单例bean线程问题如何解决？\n\n单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。\n\n常见的有两种解决办法：\n\n 1. 在 bean 中尽量避免定义可变的成员变量。\n 2. 在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。\n\n不过，大部分 bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， bean 是线程安全的。\n\n\n# Spring Bean 常用注解\n\n将一个类声明为 bean 的注解有哪些?\n\n我们一般使用 @Autowired 注解自动装配 bean，要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,采用以下注解可实现：\n\n * @Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。\n * @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。\n * @Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。\n * @Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。\n\n@Component 和 @Bean 的区别是什么？\n\n@Component 注解作用于类，而@Bean注解作用于方法。\n\n@Component通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。\n\n@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。\n\n@Bean注解使用示例：\n\n@Configuration\npublic class AppConfig {\n    @Bean\n    public TransferService transferService() {\n        return new TransferServiceImpl();\n    }\n}\n\n\n\n# bean生命周期\n\n * Bean 容器找到配置文件中 Spring Bean 的定义。\n * Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。\n * 如果涉及到一些属性值 利用 set()方法设置一些属性值。\n * 如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入 Bean 的名字。\n * 如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。\n * 如果 Bean 实现了 BeanFactoryAware 接口，调用 setBeanFactory()方法，传入 BeanFactory对象的实例。\n * 与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。\n * 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法\n * 如果 Bean 实现了InitializingBean接口，执行afterPropertiesSet()方法。\n * 如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。\n * 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法\n * 当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。\n * 当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。\n\n图示：\n\n\n\n与之比较类似的中文版本:\n\n\n\n@PostConstruct和@PreDestroy\n\n\n# 实践：@PostConstruct和@PreDestroy替代方案\n\n@PostConstruct和@PreDestroy 是两个作用于Servlet生命周期的注解。\n\n 1. @PostConstruct : 用来修饰方法，标记在项目启动的时候执行这个方法,一般用来执行某些初始化操作比如全局配置。PostConstruct 注解的方法会在构造函数之后执行,Servlet 的init()方法之前执行。\n 2. @PreDestroy : 当 bean 被 Web 容器的时候被调用，一般用来释放 bean 所持有的资源。。PostConstruct 注解的方法会在Servlet 的destroy()方法之前执行。\n\n使用Spring提供的InitializingBean和DisposableBean接口替代@PostConstruct和@PreDestroy。\n\npackage cn.javaguide.config;\n\nimport org.springframework.beans.factory.DisposableBean;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MyConfiguration2 implements InitializingBean, DisposableBean {\n    public MyConfiguration2() {\n        System.out.println("构造方法被调用");\n    }\n\n    @Override\n    public void afterPropertiesSet() {\n        System.out.println("afterPropertiesSet方法被调用");\n    }\n\n    @Override\n    public void destroy() {\n        System.out.println("destroy方法被调用");\n    }\n}\n\n\n\n\n\n# reference\n\n * Spring常见问题总结 | JavaGuide\n\n * Spring Bean的生命周期（非常详细） - Chandler Qian - 博客园\n\n * 你会用@PostConstruct和@PreDestroy不？Java9+中的替代方案知道不？-腾讯云开发者社区-腾讯云',normalizedContent:'# spring bean简介\n\nbean 指的是那些被 ioc 容器所管理的对象。\n\nspring 中 bean 的作用域通常有下面几种：\n\n * singleton : 唯一 bean 实例，spring 中的 bean 默认都是单例的，对单例设计模式的应用。\n * prototype : 每次请求都会创建一个新的 bean 实例。每次getbean都会重新创建一个bean。\n * request : 每一次 http 请求都会产生一个新的 bean，该 bean 仅在当前 http request 内有效。\n * session : 每一次来自新 session 的 http 请求都会产生一个新的 bean，该 bean 仅在当前 http session 内有效。\n * global-session ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，spring5 已经没有了。portlet 是能够生成语义代码(例如：html)片段的小型 java web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 http 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话\n\n多线程下单例bean线程问题如何解决？\n\n单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。\n\n常见的有两种解决办法：\n\n 1. 在 bean 中尽量避免定义可变的成员变量。\n 2. 在类中定义一个 threadlocal 成员变量，将需要的可变成员变量保存在 threadlocal 中（推荐的一种方式）。\n\n不过，大部分 bean 实际都是无状态（没有实例变量）的（比如 dao、service），这种情况下， bean 是线程安全的。\n\n\n# spring bean 常用注解\n\n将一个类声明为 bean 的注解有哪些?\n\n我们一般使用 @autowired 注解自动装配 bean，要想把类标识成可用于 @autowired 注解自动装配的 bean 的类,采用以下注解可实现：\n\n * @component ：通用的注解，可标注任意类为 spring 组件。如果一个 bean 不知道属于哪个层，可以使用@component 注解标注。\n * @repository : 对应持久层即 dao 层，主要用于数据库相关操作。\n * @service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 dao 层。\n * @controller : 对应 spring mvc 控制层，主要用户接受用户请求并调用 service 层返回数据给前端页面。\n\n@component 和 @bean 的区别是什么？\n\n@component 注解作用于类，而@bean注解作用于方法。\n\n@component通常是通过类路径扫描来自动侦测以及自动装配到 spring 容器中（我们可以使用 @componentscan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 spring 的 bean 容器中）。@bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@bean告诉了 spring 这是某个类的实例，当我需要用它的时候还给我。\n\n@bean 注解比 @component 注解的自定义性更强，而且很多地方我们只能通过 @bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 spring容器时，则只能通过 @bean来实现。\n\n@bean注解使用示例：\n\n@configuration\npublic class appconfig {\n    @bean\n    public transferservice transferservice() {\n        return new transferserviceimpl();\n    }\n}\n\n\n\n# bean生命周期\n\n * bean 容器找到配置文件中 spring bean 的定义。\n * bean 容器利用 java reflection api 创建一个 bean 的实例。\n * 如果涉及到一些属性值 利用 set()方法设置一些属性值。\n * 如果 bean 实现了 beannameaware 接口，调用 setbeanname()方法，传入 bean 的名字。\n * 如果 bean 实现了 beanclassloaderaware 接口，调用 setbeanclassloader()方法，传入 classloader对象的实例。\n * 如果 bean 实现了 beanfactoryaware 接口，调用 setbeanfactory()方法，传入 beanfactory对象的实例。\n * 与上面的类似，如果实现了其他 *.aware接口，就调用相应的方法。\n * 如果有和加载这个 bean 的 spring 容器相关的 beanpostprocessor 对象，执行postprocessbeforeinitialization() 方法\n * 如果 bean 实现了initializingbean接口，执行afterpropertiesset()方法。\n * 如果 bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。\n * 如果有和加载这个 bean 的 spring 容器相关的 beanpostprocessor 对象，执行postprocessafterinitialization() 方法\n * 当要销毁 bean 的时候，如果 bean 实现了 disposablebean 接口，执行 destroy() 方法。\n * 当要销毁 bean 的时候，如果 bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。\n\n图示：\n\n\n\n与之比较类似的中文版本:\n\n\n\n@postconstruct和@predestroy\n\n\n# 实践：@postconstruct和@predestroy替代方案\n\n@postconstruct和@predestroy 是两个作用于servlet生命周期的注解。\n\n 1. @postconstruct : 用来修饰方法，标记在项目启动的时候执行这个方法,一般用来执行某些初始化操作比如全局配置。postconstruct 注解的方法会在构造函数之后执行,servlet 的init()方法之前执行。\n 2. @predestroy : 当 bean 被 web 容器的时候被调用，一般用来释放 bean 所持有的资源。。postconstruct 注解的方法会在servlet 的destroy()方法之前执行。\n\n使用spring提供的initializingbean和disposablebean接口替代@postconstruct和@predestroy。\n\npackage cn.javaguide.config;\n\nimport org.springframework.beans.factory.disposablebean;\nimport org.springframework.beans.factory.initializingbean;\nimport org.springframework.context.annotation.configuration;\n\n@configuration\npublic class myconfiguration2 implements initializingbean, disposablebean {\n    public myconfiguration2() {\n        system.out.println("构造方法被调用");\n    }\n\n    @override\n    public void afterpropertiesset() {\n        system.out.println("afterpropertiesset方法被调用");\n    }\n\n    @override\n    public void destroy() {\n        system.out.println("destroy方法被调用");\n    }\n}\n\n\n\n\n\n# reference\n\n * spring常见问题总结 | javaguide\n\n * spring bean的生命周期（非常详细） - chandler qian - 博客园\n\n * 你会用@postconstruct和@predestroy不？java9+中的替代方案知道不？-腾讯云开发者社区-腾讯云',charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"Spring事务总结",frontmatter:{title:"Spring事务总结",date:"2023-10-24T03:39:10.000Z",permalink:"/pages/5fcbaa/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/04.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/01.%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/01.Spring/02.Spring%E4%BA%8B%E5%8A%A1%E6%80%BB%E7%BB%93.html",relativePath:"01.Java 知识体系/04.系统设计/01.常用框架/01.Spring/02.Spring事务总结.md",key:"v-1b7e4ff2",path:"/pages/5fcbaa/",headers:[{level:1,title:"Spring 支持两种方式的事务管理",slug:"spring-支持两种方式的事务管理",normalizedTitle:"spring 支持两种方式的事务管理",charIndex:2},{level:2,title:"编程式事务管理",slug:"编程式事务管理",normalizedTitle:"编程式事务管理",charIndex:25},{level:2,title:"声明式事务管理",slug:"声明式事务管理",normalizedTitle:"声明式事务管理",charIndex:1117},{level:1,title:"Spring 事务管理接口介绍",slug:"spring-事务管理接口介绍",normalizedTitle:"spring 事务管理接口介绍",charIndex:1391},{level:2,title:"PlatformTransactionManager:事务管理接口",slug:"platformtransactionmanager-事务管理接口",normalizedTitle:"platformtransactionmanager:事务管理接口",charIndex:1844},{level:2,title:"TransactionDefinition:事务属性",slug:"transactiondefinition-事务属性",normalizedTitle:"transactiondefinition:事务属性",charIndex:2572},{level:2,title:"TransactionStatus:事务状态",slug:"transactionstatus-事务状态",normalizedTitle:"transactionstatus:事务状态",charIndex:3765},{level:1,title:"@Transactional 注解使用详解",slug:"transactional-注解使用详解",normalizedTitle:"@transactional 注解使用详解",charIndex:4189},{level:2,title:"@Transactional 作用范围",slug:"transactional-作用范围",normalizedTitle:"@transactional 作用范围",charIndex:4215},{level:2,title:"@Transactional 常用配置参数",slug:"transactional-常用配置参数",normalizedTitle:"@transactional 常用配置参数",charIndex:4519},{level:3,title:"propagation属性",slug:"propagation属性",normalizedTitle:"propagation属性",charIndex:5272},{level:3,title:"isolation 属性",slug:"isolation-属性",normalizedTitle:"isolation 属性",charIndex:5814},{level:3,title:"timeout 属性",slug:"timeout-属性",normalizedTitle:"timeout 属性",charIndex:6445},{level:3,title:"readOnly 属性",slug:"readonly-属性",normalizedTitle:"readonly 属性",charIndex:6513},{level:3,title:"rollbackFor 属性",slug:"rollbackfor-属性",normalizedTitle:"rollbackfor 属性",charIndex:6608},{level:3,title:"noRollbackFor属性",slug:"norollbackfor属性",normalizedTitle:"norollbackfor属性",charIndex:6710},{level:2,title:"@Transactional 注解原理",slug:"transactional-注解原理",normalizedTitle:"@transactional 注解原理",charIndex:6774},{level:2,title:"@Transactional  失效的场景",slug:"transactional-失效的场景",normalizedTitle:"@transactional  失效的场景",charIndex:null},{level:3,title:"1.@Transactional 应用在非 public修饰的方法上",slug:"_1-transactional-应用在非-public修饰的方法上",normalizedTitle:"1.@transactional 应用在非 public修饰的方法上",charIndex:8067},{level:3,title:"2.@Transactional 注解属性 propagation 设置错误",slug:"_2-transactional-注解属性-propagation-设置错误",normalizedTitle:"2.@transactional 注解属性 propagation 设置错误",charIndex:8844},{level:3,title:"3.@Transactional  注解属性 rollbackFor 设置错误",slug:"_3-transactional-注解属性-rollbackfor-设置错误",normalizedTitle:"3.@transactional  注解属性 rollbackfor 设置错误",charIndex:null},{level:3,title:"4.同一个类中方法调用，导致 @Transactional 失效",slug:"_4-同一个类中方法调用-导致-transactional-失效",normalizedTitle:"4.同一个类中方法调用，导致 @transactional 失效",charIndex:9896},{level:3,title:"5.异常被catch处理导致 @Transactional 失效",slug:"_5-异常被catch处理导致-transactional-失效",normalizedTitle:"5.异常被catch处理导致 @transactional 失效",charIndex:10336},{level:3,title:"6.数据库引擎不支持事务",slug:"_6-数据库引擎不支持事务",normalizedTitle:"6.数据库引擎不支持事务",charIndex:11528}],headersStr:"Spring 支持两种方式的事务管理 编程式事务管理 声明式事务管理 Spring 事务管理接口介绍 PlatformTransactionManager:事务管理接口 TransactionDefinition:事务属性 TransactionStatus:事务状态 @Transactional 注解使用详解 @Transactional 作用范围 @Transactional 常用配置参数 propagation属性 isolation 属性 timeout 属性 readOnly 属性 rollbackFor 属性 noRollbackFor属性 @Transactional 注解原理 @Transactional  失效的场景 1.@Transactional 应用在非 public修饰的方法上 2.@Transactional 注解属性 propagation 设置错误 3.@Transactional  注解属性 rollbackFor 设置错误 4.同一个类中方法调用，导致 @Transactional 失效 5.异常被catch处理导致 @Transactional 失效 6.数据库引擎不支持事务",content:'# Spring 支持两种方式的事务管理\n\n\n# 编程式事务管理\n\n通过 TransactionTemplate或者TransactionManager手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。\n\n使用TransactionTemplate 进行编程式事务管理的示例代码如下：\n\n@Autowired\nprivate TransactionTemplate transactionTemplate;\npublic void testTransaction() {\n\n        transactionTemplate.execute(new TransactionCallbackWithoutResult() {\n            @Override\n            protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {\n\n                try {\n\n                    // ....  业务代码\n                } catch (Exception e){\n                    //回滚\n                    transactionStatus.setRollbackOnly();\n                }\n\n            }\n        });\n}\n\n\n\n使用 TransactionManager 进行编程式事务管理的示例代码如下：\n\n@Autowired\nprivate PlatformTransactionManager transactionManager;\n\npublic void testTransaction() {\n\n  TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());\n          try {\n               // ....  业务代码\n              transactionManager.commit(status);\n          } catch (Exception e) {\n              transactionManager.rollback(status);\n          }\n}\n\n\n\n\n# 声明式事务管理\n\n推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于@Transactional 的全注解方式使用最多）。\n\n使用 @Transactional注解进行事务管理的示例代码如下：\n\n@Transactional(propagation=propagation.PROPAGATION_REQUIRED)\npublic void aMethod {\n  //do something\n  B b = new B();\n  C c = new C();\n  b.bMethod();\n  c.cMethod();\n}\n\n\n\n\n# Spring 事务管理接口介绍\n\nSpring 框架中，事务管理相关最重要的 3 个接口如下：\n\n * PlatformTransactionManager： （平台）事务管理器，Spring 事务策略的核心。\n\n * TransactionDefinition： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。\n\n * TransactionStatus： 事务运行状态。\n\n可以把 PlatformTransactionManager 接口可以被看作是事务上层的管理者，而 TransactionDefinition 和 TransactionStatus 这两个接口可以看作是事务的描述。\n\nPlatformTransactionManager 会根据 TransactionDefinition 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 TransactionStatus 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。\n\n\n# PlatformTransactionManager:事务管理接口\n\nSpring 并不直接管理事务，而是提供了多种事务管理器 。Spring 事务管理器的接口是： PlatformTransactionManager 。\n\n通过这个接口，Spring 为各个平台如 JDBC(DataSourceTransactionManager)、Hibernate(HibernateTransactionManager)、JPA(JpaTransactionManager)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。\n\n\n\nPlatformTransactionManager 接口的具体实现如下:\n\npackage org.springframework.transaction;\n\nimport org.springframework.lang.Nullable;\n\npublic interface PlatformTransactionManager {\n    //获得事务\n    TransactionStatus getTransaction(@Nullable TransactionDefinition var1) throws TransactionException;\n    //提交事务\n    void commit(TransactionStatus var1) throws TransactionException;\n    //回滚事务\n    void rollback(TransactionStatus var1) throws TransactionException;\n}\n\n\n\n\n\n# TransactionDefinition:事务属性\n\n事务管理器接口 PlatformTransactionManager 通过 getTransaction(TransactionDefinition definition) 方法来得到一个事务，这个方法里面的参数是 TransactionDefinition 类 ，这个类就定义了一些基本的事务属性。\n\n那么什么是 事务属性 呢？\n\n事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。\n\n事务属性包含了 5 个方面:\n\n\n\nTransactionDefinition 接口中定义了 5 个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等。\n\npackage org.springframework.transaction;\n\nimport org.springframework.lang.Nullable;\n\npublic interface TransactionDefinition {\n    int PROPAGATION_REQUIRED = 0;\n    int PROPAGATION_SUPPORTS = 1;\n    int PROPAGATION_MANDATORY = 2;\n    int PROPAGATION_REQUIRES_NEW = 3;\n    int PROPAGATION_NOT_SUPPORTED = 4;\n    int PROPAGATION_NEVER = 5;\n    int PROPAGATION_NESTED = 6;\n    int ISOLATION_DEFAULT = -1;\n    int ISOLATION_READ_UNCOMMITTED = 1;\n    int ISOLATION_READ_COMMITTED = 2;\n    int ISOLATION_REPEATABLE_READ = 4;\n    int ISOLATION_SERIALIZABLE = 8;\n    int TIMEOUT_DEFAULT = -1;\n    // 返回事务的传播行为，默认值为 REQUIRED。\n    int getPropagationBehavior();\n    //返回事务的隔离级别，默认值是 DEFAULT\n    int getIsolationLevel();\n    // 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。\n    int getTimeout();\n    // 返回是否为只读事务，默认值为 false\n    boolean isReadOnly();\n\n    @Nullable\n    String getName();\n}\n\n\n\n\n# TransactionStatus:事务状态\n\nTransactionStatus接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息。\n\nPlatformTransactionManager.getTransaction(…)方法返回一个 TransactionStatus 对象。\n\nTransactionStatus 接口接口内容如下：\n\npublic interface TransactionStatus{\n    boolean isNewTransaction(); // 是否是新的事务\n    boolean hasSavepoint(); // 是否有恢复点\n    void setRollbackOnly();  // 设置为只回滚\n    boolean isRollbackOnly(); // 是否为只回滚\n    boolean isCompleted; // 是否已完成\n}\n\n\n\n\n# @Transactional 注解使用详解\n\n\n# @Transactional 作用范围\n\n@Transactional 可以作用在接口、类、类方法：\n\n * 作用于类：当把@Transactional 注解放在类上时，表示所有该类的public方法 都配置相同的事务属性信息。\n * 作用于方法：当类配置了@Transactional，方法也配置了@Transactional，方法的事务会覆盖类的事务配置信息。该注解只能应用到 public 方法上，否则方法事务不生效。\n * 作用于接口：不推荐这种使用方法，因为一旦标注在Interface上并且配置了Spring AOP 使用CGLib动态代理，将会导致@Transactional注解失效\n\n\n# @Transactional 常用配置参数\n\n@Transactional注解源码如下，里面包含了基本事务属性的配置：\n\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface Transactional {\n\n\t@AliasFor("transactionManager")\n\tString value() default "";\n\n\t@AliasFor("value")\n\tString transactionManager() default "";\n\n\tPropagation propagation() default Propagation.REQUIRED;\n\n\tIsolation isolation() default Isolation.DEFAULT;\n\n\tint timeout() default TransactionDefinition.TIMEOUT_DEFAULT;\n\n\tboolean readOnly() default false;\n\n\tClass<? extends Throwable>[] rollbackFor() default {};\n\n\tString[] rollbackForClassName() default {};\n\n\tClass<? extends Throwable>[] noRollbackFor() default {};\n\n\tString[] noRollbackForClassName() default {};\n\n}\n\n\n\n\n# propagation属性\n\npropagation 代表事务的传播行为，默认值为 Propagation.REQUIRED，其他的属性信息如下：\n\n事务传播行为类型                    说明\nPROPAGATION_REQUIRED        如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。\nPROPAGATION_SUPPORTS        支持当前事务，如果当前没有事务，就以非事务方式执行。\nPROPAGATION_MANDATORY       使用当前的事务，如果当前没有事务，就抛出异常。\nPROPAGATION_REQUIRES_NEW    新建事务，如果当前存在事务，把当前事务挂起。\nPROPAGATION_NOT_SUPPORTED   以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\nPROPAGATION_NEVER           以非事务方式执行，如果当前存在事务，则抛出异常。\nPROPAGATION_NESTED          如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。\n\n\n# isolation 属性\n\nisolation ：事务的隔离级别，默认值为 ISOLATION_DEFAULT。\n\n * TransactionDefinition.ISOLATION_DEFAULT： 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别， Oracle 默认采用的 READ_COMMITTED隔离级别.\n * TransactionDefinition.ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读\n * TransactionDefinition.ISOLATION_READ_COMMITTED：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生\n * TransactionDefinition.ISOLATION_REPEATABLE_READ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。\n * TransactionDefinition.ISOLATION_SERIALIZABLE： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。\n\n\n# timeout 属性\n\ntimeout ：事务的超时时间，默认值为 -1。如果超过该时间限制但事务还没有完成，则自动回滚事务。\n\n\n# readOnly 属性\n\nreadOnly ：指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。\n\n\n# rollbackFor 属性\n\nrollbackFor ：用于指定能够触发事务回滚的异常类型，可以指定多个异常类型。@Transactional 注解默认的 rollbackFor 是运行时异常\n\n\n# noRollbackFor属性\n\nnoRollbackFor：抛出指定的异常类型，不回滚事务，也可以指定多个异常类型。\n\n\n# @Transactional 注解原理\n\nSpring @Transactional 注解实现事务的原理是动态代理。调用顺序是开启事务，执行目标方法，提交或回滚事务。如果类实现了接口，通过JDK创建代理对象，如果类没有实现接口，那么通过cgLib创建代理对象。\n\ncreateAopProxy() 方法 决定了是使用 JDK 还是 Cglib 来做动态代理，源码如下：\n\npublic class DefaultAopProxyFactory implements AopProxyFactory, Serializable {\n\n\t@Override\n\tpublic AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {\n\t\tif (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {\n\t\t\tClass<?> targetClass = config.getTargetClass();\n\t\t\tif (targetClass == null) {\n\t\t\t\tthrow new AopConfigException("TargetSource cannot determine target class: " +\n\t\t\t\t\t\t"Either an interface or a target is required for proxy creation.");\n\t\t\t}\n\t\t\tif (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {\n\t\t\t\treturn new JdkDynamicAopProxy(config);\n\t\t\t}\n\t\t\treturn new ObjenesisCglibAopProxy(config);\n\t\t}\n\t\telse {\n\t\t\treturn new JdkDynamicAopProxy(config);\n\t\t}\n\t}\n  .......\n}\n\n\n\n如果一个类或者一个类中的 public 方法上被标注@Transactional 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被@Transactional 注解的 public 方法的时候，实际调用的是，TransactionInterceptor 类中的 invoke()方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。\n\n> TransactionInterceptor 类中的 invoke()方法内部实际调用的是 TransactionAspectSupport 类的 invokeWithinTransaction()方法。\n\n\n# @Transactional 失效的场景\n\n\n# 1.@Transactional 应用在非 public修饰的方法上\n\n如果Transactional注解应用在非public 修饰的方法上，Transactional将会失效。\n\n之所以会失效是因为在Spring AOP 代理时，如上图所示 TransactionInterceptor （事务拦截器）在目标方法执行前后进行拦截，DynamicAdvisedInterceptor（CglibAopProxy 的内部类）的 intercept 方法或 JdkDynamicAopProxy 的 invoke 方法会间接调用 AbstractFallbackTransactionAttributeSource的 computeTransactionAttribute 方法，获取Transactional 注解的事务配置信息。\n\nprotected TransactionAttribute computeTransactionAttribute(Method method,\n    Class<?> targetClass) {\n        // Don\'t allow no-public methods as required.\n        if (allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {\n        return null;\n}\n\n\n此方法会检查目标方法的修饰符是否为 public，不是 public则不会获取@Transactional 的属性配置信息。\n\n注意：protected、private 修饰的方法上使用 @Transactional 注解，虽然事务无效，但不会有任何报错，这是我们很容犯错的一点。\n\n\n# 2.@Transactional 注解属性 propagation 设置错误\n\n这种失效是由于配置错误，若是错误的配置以下三种 propagation，事务将不会发生回滚。\n\nTransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。\n\nTransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。\n\nTransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常\n\n\n# 3.@Transactional 注解属性 rollbackFor 设置错误\n\nrollbackFor 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查unchecked异常（继承自 RuntimeException 的异常）或者 Error才回滚事务；其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，但却期望 Spring 能够回滚事务，就需要指定 rollbackFor 属性，如果未指定 rollbackFor 属性则事务不会回滚。\n\n// 希望自定义的异常可以进行回滚\n@Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class)\n\n\n若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。Spring 源码如下：\n\nprivate int getDepth(Class<?> exceptionClass, int depth) {\n  if (exceptionClass.getName().contains(this.exceptionName)) {\n    // Found it!    return depth;\n}\n// If we\'ve gone as far as we can go and haven\'t found it...\nif (exceptionClass == Throwable.class) {\n    return -1;\n}\nreturn getDepth(exceptionClass.getSuperclass(), depth + 1);\n}\n\n\n\n# 4.同一个类中方法调用，导致 @Transactional 失效\n\n开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。则外部调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。\n\n那为啥会出现这种情况？其实这还是由于使用 Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。\n\n如果一定要在本类进行方法调用，并且要让@Transactional 生效的话，可以将本类对象注入自身的属性中。比如：\n\npublic class A() {\n\t@Resource\n\tprivate A a;\n\t\n\tpublic void a() {\n\t\ta.b();\n\t}\n\t\n\t@Transactional \n\tpublic void b() {\n\t\t\n\t}\n}\n\n\n\n# 5.异常被catch处理导致 @Transactional 失效\n\n这种情况是最常见的一种 @Transactional 注解失效场景\n\n@Transactional\nprivate Integer A() throws Exception {\n    int insert = 0;\n    try {\n        CityInfoDict cityInfoDict = new CityInfoDict();\n        cityInfoDict.setCityName("2");\n        cityInfoDict.setParentCityId(2);\n        /**\n         * A 插入字段为 2的数据\n         */\n        insert = cityInfoDictMapper.insert(cityInfoDict);\n        /**\n         * B 插入字段为 3的数据\n         */\n        b.insertB();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\n\n如果B方法内部抛了异常，而A方法此时try catch了B方法的异常，那这个事务还能正常回滚吗？\n\n答案：不能！\n\n会抛出异常：\n\norg.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only\n\n\n因为当ServiceB中抛出了一个异常以后，ServiceB标识当前事务需要rollback。但是ServiceA中由于你手动的捕获这个异常并进行处理，ServiceA认为当前事务应该正常commit。此时就出现了前后不一致，也就是因为这样，抛出了前面的UnexpectedRollbackException异常。\n\nspring的事务是在调用业务方法之前开始的，业务方法执行完毕之后才执行commit or rollback，事务是否执行取决于是否抛出runtime异常。如果抛出runtime exception 并在你的业务方法中没有catch到的话，事务会回滚。\n\n在业务方法中一般不需要catch异常，如果非要catch一定要抛出throw new RuntimeException()，或者注解中指定抛异常类型**@Transactional(rollbackFor=Exception.class)**，否则会导致事务失效，数据commit造成数据不一致，所以有些时候 try catch反倒会画蛇添足。\n\n\n# 6.数据库引擎不支持事务\n\n这种情况出现的概率并不高，事务能否生效数据库引擎是否支持事务是关键。常用的MySQL数据库默认使用支持事务的innodb引擎。一旦数据库引擎切换成不支持事务的myisam，那事务就从根本上失效了。',normalizedContent:'# spring 支持两种方式的事务管理\n\n\n# 编程式事务管理\n\n通过 transactiontemplate或者transactionmanager手动管理事务，实际应用中很少使用，但是对于你理解 spring 事务管理原理有帮助。\n\n使用transactiontemplate 进行编程式事务管理的示例代码如下：\n\n@autowired\nprivate transactiontemplate transactiontemplate;\npublic void testtransaction() {\n\n        transactiontemplate.execute(new transactioncallbackwithoutresult() {\n            @override\n            protected void dointransactionwithoutresult(transactionstatus transactionstatus) {\n\n                try {\n\n                    // ....  业务代码\n                } catch (exception e){\n                    //回滚\n                    transactionstatus.setrollbackonly();\n                }\n\n            }\n        });\n}\n\n\n\n使用 transactionmanager 进行编程式事务管理的示例代码如下：\n\n@autowired\nprivate platformtransactionmanager transactionmanager;\n\npublic void testtransaction() {\n\n  transactionstatus status = transactionmanager.gettransaction(new defaulttransactiondefinition());\n          try {\n               // ....  业务代码\n              transactionmanager.commit(status);\n          } catch (exception e) {\n              transactionmanager.rollback(status);\n          }\n}\n\n\n\n\n# 声明式事务管理\n\n推荐使用（代码侵入性最小），实际是通过 aop 实现（基于@transactional 的全注解方式使用最多）。\n\n使用 @transactional注解进行事务管理的示例代码如下：\n\n@transactional(propagation=propagation.propagation_required)\npublic void amethod {\n  //do something\n  b b = new b();\n  c c = new c();\n  b.bmethod();\n  c.cmethod();\n}\n\n\n\n\n# spring 事务管理接口介绍\n\nspring 框架中，事务管理相关最重要的 3 个接口如下：\n\n * platformtransactionmanager： （平台）事务管理器，spring 事务策略的核心。\n\n * transactiondefinition： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。\n\n * transactionstatus： 事务运行状态。\n\n可以把 platformtransactionmanager 接口可以被看作是事务上层的管理者，而 transactiondefinition 和 transactionstatus 这两个接口可以看作是事务的描述。\n\nplatformtransactionmanager 会根据 transactiondefinition 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 transactionstatus 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。\n\n\n# platformtransactionmanager:事务管理接口\n\nspring 并不直接管理事务，而是提供了多种事务管理器 。spring 事务管理器的接口是： platformtransactionmanager 。\n\n通过这个接口，spring 为各个平台如 jdbc(datasourcetransactionmanager)、hibernate(hibernatetransactionmanager)、jpa(jpatransactionmanager)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。\n\n\n\nplatformtransactionmanager 接口的具体实现如下:\n\npackage org.springframework.transaction;\n\nimport org.springframework.lang.nullable;\n\npublic interface platformtransactionmanager {\n    //获得事务\n    transactionstatus gettransaction(@nullable transactiondefinition var1) throws transactionexception;\n    //提交事务\n    void commit(transactionstatus var1) throws transactionexception;\n    //回滚事务\n    void rollback(transactionstatus var1) throws transactionexception;\n}\n\n\n\n\n\n# transactiondefinition:事务属性\n\n事务管理器接口 platformtransactionmanager 通过 gettransaction(transactiondefinition definition) 方法来得到一个事务，这个方法里面的参数是 transactiondefinition 类 ，这个类就定义了一些基本的事务属性。\n\n那么什么是 事务属性 呢？\n\n事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。\n\n事务属性包含了 5 个方面:\n\n\n\ntransactiondefinition 接口中定义了 5 个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等。\n\npackage org.springframework.transaction;\n\nimport org.springframework.lang.nullable;\n\npublic interface transactiondefinition {\n    int propagation_required = 0;\n    int propagation_supports = 1;\n    int propagation_mandatory = 2;\n    int propagation_requires_new = 3;\n    int propagation_not_supported = 4;\n    int propagation_never = 5;\n    int propagation_nested = 6;\n    int isolation_default = -1;\n    int isolation_read_uncommitted = 1;\n    int isolation_read_committed = 2;\n    int isolation_repeatable_read = 4;\n    int isolation_serializable = 8;\n    int timeout_default = -1;\n    // 返回事务的传播行为，默认值为 required。\n    int getpropagationbehavior();\n    //返回事务的隔离级别，默认值是 default\n    int getisolationlevel();\n    // 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。\n    int gettimeout();\n    // 返回是否为只读事务，默认值为 false\n    boolean isreadonly();\n\n    @nullable\n    string getname();\n}\n\n\n\n\n# transactionstatus:事务状态\n\ntransactionstatus接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息。\n\nplatformtransactionmanager.gettransaction(…)方法返回一个 transactionstatus 对象。\n\ntransactionstatus 接口接口内容如下：\n\npublic interface transactionstatus{\n    boolean isnewtransaction(); // 是否是新的事务\n    boolean hassavepoint(); // 是否有恢复点\n    void setrollbackonly();  // 设置为只回滚\n    boolean isrollbackonly(); // 是否为只回滚\n    boolean iscompleted; // 是否已完成\n}\n\n\n\n\n# @transactional 注解使用详解\n\n\n# @transactional 作用范围\n\n@transactional 可以作用在接口、类、类方法：\n\n * 作用于类：当把@transactional 注解放在类上时，表示所有该类的public方法 都配置相同的事务属性信息。\n * 作用于方法：当类配置了@transactional，方法也配置了@transactional，方法的事务会覆盖类的事务配置信息。该注解只能应用到 public 方法上，否则方法事务不生效。\n * 作用于接口：不推荐这种使用方法，因为一旦标注在interface上并且配置了spring aop 使用cglib动态代理，将会导致@transactional注解失效\n\n\n# @transactional 常用配置参数\n\n@transactional注解源码如下，里面包含了基本事务属性的配置：\n\n@target({elementtype.type, elementtype.method})\n@retention(retentionpolicy.runtime)\n@inherited\n@documented\npublic @interface transactional {\n\n\t@aliasfor("transactionmanager")\n\tstring value() default "";\n\n\t@aliasfor("value")\n\tstring transactionmanager() default "";\n\n\tpropagation propagation() default propagation.required;\n\n\tisolation isolation() default isolation.default;\n\n\tint timeout() default transactiondefinition.timeout_default;\n\n\tboolean readonly() default false;\n\n\tclass<? extends throwable>[] rollbackfor() default {};\n\n\tstring[] rollbackforclassname() default {};\n\n\tclass<? extends throwable>[] norollbackfor() default {};\n\n\tstring[] norollbackforclassname() default {};\n\n}\n\n\n\n\n# propagation属性\n\npropagation 代表事务的传播行为，默认值为 propagation.required，其他的属性信息如下：\n\n事务传播行为类型                    说明\npropagation_required        如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。\npropagation_supports        支持当前事务，如果当前没有事务，就以非事务方式执行。\npropagation_mandatory       使用当前的事务，如果当前没有事务，就抛出异常。\npropagation_requires_new    新建事务，如果当前存在事务，把当前事务挂起。\npropagation_not_supported   以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\npropagation_never           以非事务方式执行，如果当前存在事务，则抛出异常。\npropagation_nested          如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作。\n\n\n# isolation 属性\n\nisolation ：事务的隔离级别，默认值为 isolation_default。\n\n * transactiondefinition.isolation_default： 使用后端数据库默认的隔离级别，mysql 默认采用的 repeatable_read隔离级别， oracle 默认采用的 read_committed隔离级别.\n * transactiondefinition.isolation_read_uncommitted：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读\n * transactiondefinition.isolation_read_committed：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生\n * transactiondefinition.isolation_repeatable_read：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。\n * transactiondefinition.isolation_serializable： 最高的隔离级别，完全服从acid的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。\n\n\n# timeout 属性\n\ntimeout ：事务的超时时间，默认值为 -1。如果超过该时间限制但事务还没有完成，则自动回滚事务。\n\n\n# readonly 属性\n\nreadonly ：指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。\n\n\n# rollbackfor 属性\n\nrollbackfor ：用于指定能够触发事务回滚的异常类型，可以指定多个异常类型。@transactional 注解默认的 rollbackfor 是运行时异常\n\n\n# norollbackfor属性\n\nnorollbackfor：抛出指定的异常类型，不回滚事务，也可以指定多个异常类型。\n\n\n# @transactional 注解原理\n\nspring @transactional 注解实现事务的原理是动态代理。调用顺序是开启事务，执行目标方法，提交或回滚事务。如果类实现了接口，通过jdk创建代理对象，如果类没有实现接口，那么通过cglib创建代理对象。\n\ncreateaopproxy() 方法 决定了是使用 jdk 还是 cglib 来做动态代理，源码如下：\n\npublic class defaultaopproxyfactory implements aopproxyfactory, serializable {\n\n\t@override\n\tpublic aopproxy createaopproxy(advisedsupport config) throws aopconfigexception {\n\t\tif (config.isoptimize() || config.isproxytargetclass() || hasnousersuppliedproxyinterfaces(config)) {\n\t\t\tclass<?> targetclass = config.gettargetclass();\n\t\t\tif (targetclass == null) {\n\t\t\t\tthrow new aopconfigexception("targetsource cannot determine target class: " +\n\t\t\t\t\t\t"either an interface or a target is required for proxy creation.");\n\t\t\t}\n\t\t\tif (targetclass.isinterface() || proxy.isproxyclass(targetclass)) {\n\t\t\t\treturn new jdkdynamicaopproxy(config);\n\t\t\t}\n\t\t\treturn new objenesiscglibaopproxy(config);\n\t\t}\n\t\telse {\n\t\t\treturn new jdkdynamicaopproxy(config);\n\t\t}\n\t}\n  .......\n}\n\n\n\n如果一个类或者一个类中的 public 方法上被标注@transactional 注解的话，spring 容器就会在启动的时候为其创建一个代理类，在调用被@transactional 注解的 public 方法的时候，实际调用的是，transactioninterceptor 类中的 invoke()方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。\n\n> transactioninterceptor 类中的 invoke()方法内部实际调用的是 transactionaspectsupport 类的 invokewithintransaction()方法。\n\n\n# @transactional 失效的场景\n\n\n# 1.@transactional 应用在非 public修饰的方法上\n\n如果transactional注解应用在非public 修饰的方法上，transactional将会失效。\n\n之所以会失效是因为在spring aop 代理时，如上图所示 transactioninterceptor （事务拦截器）在目标方法执行前后进行拦截，dynamicadvisedinterceptor（cglibaopproxy 的内部类）的 intercept 方法或 jdkdynamicaopproxy 的 invoke 方法会间接调用 abstractfallbacktransactionattributesource的 computetransactionattribute 方法，获取transactional 注解的事务配置信息。\n\nprotected transactionattribute computetransactionattribute(method method,\n    class<?> targetclass) {\n        // don\'t allow no-public methods as required.\n        if (allowpublicmethodsonly() && !modifier.ispublic(method.getmodifiers())) {\n        return null;\n}\n\n\n此方法会检查目标方法的修饰符是否为 public，不是 public则不会获取@transactional 的属性配置信息。\n\n注意：protected、private 修饰的方法上使用 @transactional 注解，虽然事务无效，但不会有任何报错，这是我们很容犯错的一点。\n\n\n# 2.@transactional 注解属性 propagation 设置错误\n\n这种失效是由于配置错误，若是错误的配置以下三种 propagation，事务将不会发生回滚。\n\ntransactiondefinition.propagation_supports：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。\n\ntransactiondefinition.propagation_not_supported：以非事务方式运行，如果当前存在事务，则把当前事务挂起。\n\ntransactiondefinition.propagation_never：以非事务方式运行，如果当前存在事务，则抛出异常\n\n\n# 3.@transactional 注解属性 rollbackfor 设置错误\n\nrollbackfor 可以指定能够触发事务回滚的异常类型。spring默认抛出了未检查unchecked异常（继承自 runtimeexception 的异常）或者 error才回滚事务；其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，但却期望 spring 能够回滚事务，就需要指定 rollbackfor 属性，如果未指定 rollbackfor 属性则事务不会回滚。\n\n// 希望自定义的异常可以进行回滚\n@transactional(propagation= propagation.required,rollbackfor= myexception.class)\n\n\n若在目标方法中抛出的异常是 rollbackfor 指定的异常的子类，事务同样会回滚。spring 源码如下：\n\nprivate int getdepth(class<?> exceptionclass, int depth) {\n  if (exceptionclass.getname().contains(this.exceptionname)) {\n    // found it!    return depth;\n}\n// if we\'ve gone as far as we can go and haven\'t found it...\nif (exceptionclass == throwable.class) {\n    return -1;\n}\nreturn getdepth(exceptionclass.getsuperclass(), depth + 1);\n}\n\n\n\n# 4.同一个类中方法调用，导致 @transactional 失效\n\n开发中避免不了会对同一个类里面的方法调用，比如有一个类test，它的一个方法a，a再调用本类的方法b（不论方法b是用public还是private修饰），但方法a没有声明注解事务，而b方法有。则外部调用方法a之后，方法b的事务是不会起作用的。这也是经常犯错误的一个地方。\n\n那为啥会出现这种情况？其实这还是由于使用 spring aop代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由spring生成的代理对象来管理。\n\n如果一定要在本类进行方法调用，并且要让@transactional 生效的话，可以将本类对象注入自身的属性中。比如：\n\npublic class a() {\n\t@resource\n\tprivate a a;\n\t\n\tpublic void a() {\n\t\ta.b();\n\t}\n\t\n\t@transactional \n\tpublic void b() {\n\t\t\n\t}\n}\n\n\n\n# 5.异常被catch处理导致 @transactional 失效\n\n这种情况是最常见的一种 @transactional 注解失效场景\n\n@transactional\nprivate integer a() throws exception {\n    int insert = 0;\n    try {\n        cityinfodict cityinfodict = new cityinfodict();\n        cityinfodict.setcityname("2");\n        cityinfodict.setparentcityid(2);\n        /**\n         * a 插入字段为 2的数据\n         */\n        insert = cityinfodictmapper.insert(cityinfodict);\n        /**\n         * b 插入字段为 3的数据\n         */\n        b.insertb();\n    } catch (exception e) {\n        e.printstacktrace();\n    }\n}\n\n\n如果b方法内部抛了异常，而a方法此时try catch了b方法的异常，那这个事务还能正常回滚吗？\n\n答案：不能！\n\n会抛出异常：\n\norg.springframework.transaction.unexpectedrollbackexception: transaction rolled back because it has been marked as rollback-only\n\n\n因为当serviceb中抛出了一个异常以后，serviceb标识当前事务需要rollback。但是servicea中由于你手动的捕获这个异常并进行处理，servicea认为当前事务应该正常commit。此时就出现了前后不一致，也就是因为这样，抛出了前面的unexpectedrollbackexception异常。\n\nspring的事务是在调用业务方法之前开始的，业务方法执行完毕之后才执行commit or rollback，事务是否执行取决于是否抛出runtime异常。如果抛出runtime exception 并在你的业务方法中没有catch到的话，事务会回滚。\n\n在业务方法中一般不需要catch异常，如果非要catch一定要抛出throw new runtimeexception()，或者注解中指定抛异常类型**@transactional(rollbackfor=exception.class)**，否则会导致事务失效，数据commit造成数据不一致，所以有些时候 try catch反倒会画蛇添足。\n\n\n# 6.数据库引擎不支持事务\n\n这种情况出现的概率并不高，事务能否生效数据库引擎是否支持事务是关键。常用的mysql数据库默认使用支持事务的innodb引擎。一旦数据库引擎切换成不支持事务的myisam，那事务就从根本上失效了。',charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"分布式锁介绍",frontmatter:{title:"分布式锁介绍",date:"2023-10-24T03:41:14.000Z",permalink:"/pages/4418d1/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/04.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F/01.%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/01.%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BB%8B%E7%BB%8D.html",relativePath:"01.Java 知识体系/04.系统设计/02.分布式/01.分布式锁/01.分布式锁介绍.md",key:"v-4bab47ca",path:"/pages/4418d1/",headers:[{level:1,title:"为什么需要分布式锁？",slug:"为什么需要分布式锁",normalizedTitle:"为什么需要分布式锁？",charIndex:2},{level:1,title:"分布式锁应该具备的哪些条件？",slug:"分布式锁应该具备的哪些条件",normalizedTitle:"分布式锁应该具备的哪些条件？",charIndex:745},{level:1,title:"分布式锁常见实现方式有哪些？",slug:"分布式锁常见实现方式有哪些",normalizedTitle:"分布式锁常见实现方式有哪些？",charIndex:1062},{level:1,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1300},{level:1,title:"reference",slug:"reference",normalizedTitle:"reference",charIndex:1518}],headersStr:"为什么需要分布式锁？ 分布式锁应该具备的哪些条件？ 分布式锁常见实现方式有哪些？ 总结 reference",content:"# 为什么需要分布式锁？\n\n在多线程环境中，如果多个线程同时访问共享资源（例如商品库存、外卖订单），会发生数据竞争，可能会导致出现脏数据或者系统问题，威胁到程序的正常运行。\n\n为了保证共享资源被安全地访问，我们需要使用互斥操作对共享资源进行保护，即同一时刻只允许一个线程访问共享资源，其他线程需要等待当前线程释放后才能访问。这样可以避免数据竞争和脏数据问题，保证程序的正确性和稳定性。\n\n如何才能实现共享资源的互斥访问呢？ 锁是一个比较通用的解决方案，更准确点来说是悲观锁。\n\n悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。\n\n对于单机多线程来说，在 Java 中，我们通常使用 ReetrantLock 类、synchronized 关键字这类 JDK 自带的 本地锁 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。\n\n分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，分布式锁 就诞生了。\n\n举个例子：系统的订单服务一共部署了 3 份，都对外提供服务。用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。由于订单服务位于不同的 JVM 进程中，本地锁在这种情况下就没办法正常工作了。我们需要用到分布式锁，这样的话，即使多个线程不在同一个 JVM 进程中也能获取到同一把锁，进而实现共享资源的互斥访问。\n\n\n# 分布式锁应该具备的哪些条件？\n\n一个最基本的分布式锁需要满足：\n\n * 互斥：任意一个时刻，锁只能被一个线程持有。\n * 高可用：锁服务是高可用的，当一个锁服务出现问题，能够自动切换到另外一个锁服务。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。这一般是通过超时机制实现的。\n * 可重入：一个节点获取了锁之后，还可以再次获取锁。\n\n除了上面这三个基本条件之外，一个好的分布式锁还需要满足下面这些条件：\n\n * 高性能：获取和释放锁的操作应该快速完成，并且不应该对整个系统的性能造成过大影响。\n * 非阻塞：如果获取不到锁，不能无限期等待，避免对系统正常运行造成影响。\n\n\n# 分布式锁常见实现方式有哪些？\n\n常见分布式锁实现方案如下：\n\n * 基于关系型数据库比如 MySQL 实现分布式锁。\n * 基于分布式协调服务 ZooKeeper 实现分布式锁。\n * 基于分布式键值存储系统比如 Redis 、Etcd 实现分布式锁。\n\n关系型数据库的方式一般是通过唯一索引或者排他锁实现。不过，一般不会使用这种方式，问题太多比如性能太差、不具备锁失效机制。\n\n基于 ZooKeeper 或者 Redis 实现分布式锁这两种实现方式要用的更多一些。\n\n\n# 总结\n\n这篇文章我们主要介绍了：\n\n * 分布式锁的用途：分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。\n * 分布式锁的应该具备的条件：互斥、高可用、可重入、高性能、非阻塞。\n * 分布式锁的常见实现方式：关系型数据库比如 MySQL、分布式协调服务 ZooKeeper、分布式键值存储系统比如 Redis 、Etcd 。\n\n\n# reference\n\n * 分布式锁介绍",normalizedContent:"# 为什么需要分布式锁？\n\n在多线程环境中，如果多个线程同时访问共享资源（例如商品库存、外卖订单），会发生数据竞争，可能会导致出现脏数据或者系统问题，威胁到程序的正常运行。\n\n为了保证共享资源被安全地访问，我们需要使用互斥操作对共享资源进行保护，即同一时刻只允许一个线程访问共享资源，其他线程需要等待当前线程释放后才能访问。这样可以避免数据竞争和脏数据问题，保证程序的正确性和稳定性。\n\n如何才能实现共享资源的互斥访问呢？ 锁是一个比较通用的解决方案，更准确点来说是悲观锁。\n\n悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。\n\n对于单机多线程来说，在 java 中，我们通常使用 reetrantlock 类、synchronized 关键字这类 jdk 自带的 本地锁 来控制一个 jvm 进程内的多个线程对本地共享资源的访问。\n\n分布式系统下，不同的服务/客户端通常运行在独立的 jvm 进程上。如果多个 jvm 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，分布式锁 就诞生了。\n\n举个例子：系统的订单服务一共部署了 3 份，都对外提供服务。用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。由于订单服务位于不同的 jvm 进程中，本地锁在这种情况下就没办法正常工作了。我们需要用到分布式锁，这样的话，即使多个线程不在同一个 jvm 进程中也能获取到同一把锁，进而实现共享资源的互斥访问。\n\n\n# 分布式锁应该具备的哪些条件？\n\n一个最基本的分布式锁需要满足：\n\n * 互斥：任意一个时刻，锁只能被一个线程持有。\n * 高可用：锁服务是高可用的，当一个锁服务出现问题，能够自动切换到另外一个锁服务。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。这一般是通过超时机制实现的。\n * 可重入：一个节点获取了锁之后，还可以再次获取锁。\n\n除了上面这三个基本条件之外，一个好的分布式锁还需要满足下面这些条件：\n\n * 高性能：获取和释放锁的操作应该快速完成，并且不应该对整个系统的性能造成过大影响。\n * 非阻塞：如果获取不到锁，不能无限期等待，避免对系统正常运行造成影响。\n\n\n# 分布式锁常见实现方式有哪些？\n\n常见分布式锁实现方案如下：\n\n * 基于关系型数据库比如 mysql 实现分布式锁。\n * 基于分布式协调服务 zookeeper 实现分布式锁。\n * 基于分布式键值存储系统比如 redis 、etcd 实现分布式锁。\n\n关系型数据库的方式一般是通过唯一索引或者排他锁实现。不过，一般不会使用这种方式，问题太多比如性能太差、不具备锁失效机制。\n\n基于 zookeeper 或者 redis 实现分布式锁这两种实现方式要用的更多一些。\n\n\n# 总结\n\n这篇文章我们主要介绍了：\n\n * 分布式锁的用途：分布式系统下，不同的服务/客户端通常运行在独立的 jvm 进程上。如果多个 jvm 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。\n * 分布式锁的应该具备的条件：互斥、高可用、可重入、高性能、非阻塞。\n * 分布式锁的常见实现方式：关系型数据库比如 mysql、分布式协调服务 zookeeper、分布式键值存储系统比如 redis 、etcd 。\n\n\n# reference\n\n * 分布式锁介绍",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"分布式锁常见实现方案总结",frontmatter:{title:"分布式锁常见实现方案总结",date:"2023-10-24T03:41:14.000Z",permalink:"/pages/d51c58/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/04.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F/01.%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/02.%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93.html",relativePath:"01.Java 知识体系/04.系统设计/02.分布式/01.分布式锁/02.分布式锁常见实现方案总结.md",key:"v-d97f40f6",path:"/pages/d51c58/",headers:[{level:1,title:"基于 Redis 实现分布式锁",slug:"基于-redis-实现分布式锁",normalizedTitle:"基于 redis 实现分布式锁",charIndex:82},{level:2,title:"如何基于 Redis 实现一个最简易的分布式锁？",slug:"如何基于-redis-实现一个最简易的分布式锁",normalizedTitle:"如何基于 redis 实现一个最简易的分布式锁？",charIndex:102},{level:2,title:"为什么要给锁设置一个过期时间？",slug:"为什么要给锁设置一个过期时间",normalizedTitle:"为什么要给锁设置一个过期时间？",charIndex:823},{level:2,title:"如何实现锁的优雅续期？",slug:"如何实现锁的优雅续期",normalizedTitle:"如何实现锁的优雅续期？",charIndex:1307},{level:2,title:"如何实现可重入锁",slug:"如何实现可重入锁",normalizedTitle:"如何实现可重入锁",charIndex:2576},{level:2,title:"Redis 如何解决集群情况下分布式锁的可靠性？",slug:"redis-如何解决集群情况下分布式锁的可靠性",normalizedTitle:"redis 如何解决集群情况下分布式锁的可靠性？",charIndex:3064},{level:1,title:"基于 ZooKeeper 实现分布式锁",slug:"基于-zookeeper-实现分布式锁",normalizedTitle:"基于 zookeeper 实现分布式锁",charIndex:3624},{level:2,title:"如何基于 ZooKeeper 实现分布式锁？",slug:"如何基于-zookeeper-实现分布式锁",normalizedTitle:"如何基于 zookeeper 实现分布式锁？",charIndex:3712},{level:2,title:"为什么要用临时顺序节点？",slug:"为什么要用临时顺序节点",normalizedTitle:"为什么要用临时顺序节点？",charIndex:5431},{level:2,title:"为什么要设置对前一个节点的监听？",slug:"为什么要设置对前一个节点的监听",normalizedTitle:"为什么要设置对前一个节点的监听？",charIndex:6143},{level:2,title:"如何实现可重入锁？",slug:"如何实现可重入锁-2",normalizedTitle:"如何实现可重入锁？",charIndex:6537},{level:1,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:8453},{level:1,title:"reference",slug:"reference",normalizedTitle:"reference",charIndex:8598}],headersStr:"基于 Redis 实现分布式锁 如何基于 Redis 实现一个最简易的分布式锁？ 为什么要给锁设置一个过期时间？ 如何实现锁的优雅续期？ 如何实现可重入锁 Redis 如何解决集群情况下分布式锁的可靠性？ 基于 ZooKeeper 实现分布式锁 如何基于 ZooKeeper 实现分布式锁？ 为什么要用临时顺序节点？ 为什么要设置对前一个节点的监听？ 如何实现可重入锁？ 总结 reference",content:'通常情况下，一般会选择基于Redis或者ZooKeeper实现分布式锁，Redis 实现 AP架构的分布式锁，ZooKeeper 实现CP架构的分布式锁。\n\n\n# 基于 Redis 实现分布式锁\n\n\n# 如何基于 Redis 实现一个最简易的分布式锁？\n\n不论是本地锁还是分布式锁，核心都在于“互斥”。\n\n在 Redis 中， SETNX 命令是可以帮助我们实现互斥。SETNX 即 SET if Not eXists (对应 Java 中的 setIfAbsent 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， SETNX 啥也不做。\n\n> SETNX lockKey uniqueValue\n(integer) 1\n> SETNX lockKey uniqueValue\n(integer) 0\n\n\n释放锁的话，直接通过 DEL 命令删除对应的 key 即可。\n\n> DEL lockKey\n(integer) 1\n\n\n为了防止误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。\n\n选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。\n\n// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放\nif redis.call("get",KEYS[1]) == ARGV[1] then\n    return redis.call("del",KEYS[1])\nelse\n    return 0\nend\n\n\n这是一种最简易的 Redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。就比如应用程序遇到一些问题比如释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程/进程访问。\n\n\n# 为什么要给锁设置一个过期时间？\n\n为了避免锁无法被释放，我们可以想到的一个解决办法就是：给这个 key（也就是锁） 设置一个过期时间 。\n\n127.0.0.1:6379> SET lockKey uniqueValue EX 3 NX\nOK\n\n\n * lockKey：加锁的锁名；\n * uniqueValue：能够唯一标示锁的随机字符串；\n * NX：只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功；\n * EX：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。\n\n一定要保证设置指定 key 的值和过期时间是一个原子操作！！！ 不然的话，依然可能会出现锁无法被释放的问题。\n\n这样确实可以解决问题，不过，这种解决办法同样存在漏洞：如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。\n\n你或许在想：如果操作共享资源的操作还未完成，锁过期时间能够自己续期就好了！\n\n\n# 如何实现锁的优雅续期？\n\n对于 Java 开发的小伙伴来说，已经有了现成的解决方案：Redisson 。其他语言的解决方案，可以在 Redis 官方文档中找到，地址：https://redis.io/topics/distlock 。\n\nRedisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。并且，Redisson 还支持 Redis 单机、Redis Sentinel、Redis Cluster 等多种部署架构。\n\nRedisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 Watch Dog（ 看门狗），如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。\n\n看门狗名字的由来于 getLockWatchdogTimeout() 方法，这个方法返回的是看门狗给锁续期的过期时间，默认为 30 秒（redisson-3.17.6）。\n\n默认情况下，每过 10 秒，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。\n\n> 默认情况下，看门狗的续期时间是30s，也可以通过修改Config.lockWatchdogTimeout来另行指定。另外Redisson 还提供了可以指定leaseTime参数的加锁方法来指定加锁的时间。超过这个时间后锁便自动解开了，不会延长锁的有效期。\n> \n> watchDog 只有在未显示指定加锁时间（leaseTime）时才会生效。\n\n这里以 Redisson 的分布式可重入锁 RLock 为例来说明如何使用 Redisson 实现分布式锁：\n\n// 1.获取指定的分布式锁对象\nRLock lock = redisson.getLock("lock");\n// 2.拿锁且不设置锁超时时间，具备 Watch Dog 自动续期机制\nlock.lock();\n// 3.执行业务\n...\n// 4.释放锁\nlock.unlock();\n\n\n只有未指定锁超时时间，才会使用到 Watch Dog 自动续期机制。\n\n// 手动给锁设置过期时间，不具备 Watch Dog 自动续期机制\nlock.lock(10, TimeUnit.SECONDS);\n\n\n程序释放锁操作时因为异常没有被执行，那么锁无法被释放，所以释放锁操作一定要放到 finally {} 中。\n\n如果释放锁操作本身异常了，watch dog 还会不停的续期吗？不会，因为无论释放锁操作是否成功，EXPIRATION_RENEWAL_MAP中的目标 ExpirationEntry 对象已经被移除了，watch dog 通过判断后就不会继续给锁续期了。\n\n如果使用 Redis 来实现分布式锁的话，还是比较推荐直接基于 Redisson 来做的。\n\n\n# 如何实现可重入锁\n\n所谓可重入锁指的是在一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。像 Java 中的 synchronized 和 ReentrantLock 都属于可重入锁。\n\n不可重入的分布式锁基本可以满足绝大部分业务场景了，一些特殊的场景可能会需要使用可重入的分布式锁。\n\n可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。为此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。\n\n实际项目中，我们不需要自己手动实现，推荐使用我们上面提到的 Redisson ，其内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。\n\n\n# Redis 如何解决集群情况下分布式锁的可靠性？\n\n为了避免单点故障，生产环境下的 Redis 服务通常是集群化部署的。\n\nRedis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。\n\n针对这个问题，Redis 之父 antirez 设计了 Redlock 算法 来解决。\n\nRedlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。\n\n即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。\n\n实际项目中不建议使用 Redlock 算法，成本和收益不成正比。\n\n如果不是非要实现绝对可靠的分布式锁的话，其实单机版 Redis 就完全够了，实现简单，性能也非常高。如果你必须要实现一个绝对可靠的分布式锁的话，可以基于 ZooKeeper 来做，只是性能会差一些。\n\n\n# 基于 ZooKeeper 实现分布式锁\n\nRedis 实现分布式锁性能较高，ZooKeeper 实现分布式锁可靠性更高。实际项目中，我们应该根据业务的具体需求来选择。\n\n\n# 如何基于 ZooKeeper 实现分布式锁？\n\nZooKeeper 分布式锁是基于 临时顺序节点 和 Watcher（事件监听器） 实现的。\n\n获取锁：\n\n 1. 首先我们要有一个持久节点/locks，客户端获取锁就是在locks下创建临时顺序节点。\n 2. 假设客户端 1 创建了/locks/lock1节点，创建成功之后，会判断 lock1是否是 /locks 下最小的子节点。\n 3. 如果 lock1是最小的子节点，则获取锁成功。否则，获取锁失败。\n 4. 如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 并不会不停地循环去尝试加锁，而是在前一个节点比如/locks/lock0上注册一个事件监听器。这个监听器的作用是当前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。\n\n释放锁：\n\n 1. 成功获取锁的客户端在执行完业务流程之后，会将对应的子节点删除。\n 2. 成功获取锁的客户端在出现故障之后，对应的子节点由于是临时顺序节点，也会被自动删除，避免了锁无法被释放。\n 3. 我们前面说的事件监听器其实监听的就是这个子节点删除事件，子节点删除就意味着锁被释放。\n\n实际项目中，推荐使用 Curator 来实现 ZooKeeper 分布式锁。Curator 是 Netflix 公司开源的一套 ZooKeeper Java 客户端框架，相比于 ZooKeeper 自带的客户端 zookeeper 来说，Curator 的封装更加完善，各种 API 都可以比较方便地使用。\n\nCurator主要实现了下面四种锁：\n\n * InterProcessMutex：分布式可重入排它锁\n * InterProcessSemaphoreMutex：分布式不可重入排它锁\n * InterProcessReadWriteLock：分布式读写锁\n * InterProcessMultiLock：将多个锁作为单个实体管理的容器，获取锁的时候获取所有锁，释放锁也会释放所有锁资源（忽略释放失败的锁）。\n\nCuratorFramework client = ZKUtils.getClient();\nclient.start();\n// 分布式可重入排它锁\nInterProcessLock lock1 = new InterProcessMutex(client, lockPath1);\n// 分布式不可重入排它锁\nInterProcessLock lock2 = new InterProcessSemaphoreMutex(client, lockPath2);\n// 将多个锁作为一个整体\nInterProcessMultiLock lock = new InterProcessMultiLock(Arrays.asList(lock1, lock2));\n\nif (!lock.acquire(10, TimeUnit.SECONDS)) {\n   throw new IllegalStateException("不能获取多锁");\n}\nSystem.out.println("已获取多锁");\nSystem.out.println("是否有第一个锁: " + lock1.isAcquiredInThisProcess());\nSystem.out.println("是否有第二个锁: " + lock2.isAcquiredInThisProcess());\ntry {\n    // 资源操作\n    resource.use();\n} finally {\n    System.out.println("释放多个锁");\n    lock.release();\n}\nSystem.out.println("是否有第一个锁: " + lock1.isAcquiredInThisProcess());\nSystem.out.println("是否有第二个锁: " + lock2.isAcquiredInThisProcess());\nclient.close();\n\n\n\n# 为什么要用临时顺序节点？\n\n每个数据节点在 ZooKeeper 中被称为 znode，它是 ZooKeeper 中数据的最小单元。\n\n我们通常是将 znode 分为 4 大类：\n\n * 持久（PERSISTENT）节点：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。\n * 临时（EPHEMERAL）节点：临时节点的生命周期是与 客户端会话（session） 绑定的，会话消失则节点消失 。并且，临时节点只能做叶子节点 ，不能创建子节点。\n * 持久顺序（PERSISTENT_SEQUENTIAL）节点：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 /node1/app0000000001、/node1/app0000000002 。\n * 临时顺序（EPHEMERAL_SEQUENTIAL）节点：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。\n\n可以看出，临时节点相比持久节点，最主要的是对会话失效的情况处理不一样，临时节点会话消失则对应的节点消失。这样的话，如果客户端发生异常导致没来得及释放锁也没关系，会话失效节点自动被删除，不会发生死锁的问题。\n\n使用 Redis 实现分布式锁的时候，我们是通过过期时间来避免锁无法被释放导致死锁问题的，而 ZooKeeper 直接利用临时节点的特性即可。\n\n假设不使用顺序节点的话，所有尝试获取锁的客户端都会对持有锁的子节点加监听器。当该锁被释放之后，势必会造成所有尝试获取锁的客户端来争夺锁，这样对性能不友好。使用顺序节点之后，只需要监听前一个节点就好了，对性能更友好。\n\n\n# 为什么要设置对前一个节点的监听？\n\n> Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。\n\n同一时间段内，可能会有很多客户端同时获取锁，但只有一个可以获取成功。如果获取锁失败，则说明有其他的客户端已经成功获取锁。获取锁失败的客户端并不会不停地循环去尝试加锁，而是在前一个节点注册一个事件监听器。\n\n这个事件监听器的作用是：当前一个节点对应的客户端释放锁之后（也就是前一个节点被删除之后，监听的是删除事件），通知获取锁失败的客户端（唤醒等待的线程，Java 中的 wait/notifyAll ），让它尝试去获取锁，然后就成功获取锁了。\n\n\n# 如何实现可重入锁？\n\n这里以 Curator 的 InterProcessMutex 对可重入锁的实现来介绍（源码地址：InterProcessMutex.java）。\n\n当我们调用 InterProcessMutex#acquire方法获取锁的时候，会调用InterProcessMutex#internalLock方法。\n\n// 获取可重入互斥锁，直到获取成功为止\n@Override\npublic void acquire() throws Exception {\n  if (!internalLock(-1, null)) {\n    throw new IOException("Lost connection while trying to acquire lock: " + basePath);\n  }\n}\n\n\ninternalLock 方法会先获取当前请求锁的线程，然后从 threadData( ConcurrentMap<Thread, LockData> 类型)中获取当前线程对应的 lockData 。 lockData 包含锁的信息和加锁的次数，是实现可重入锁的关键。\n\n第一次获取锁的时候，lockData为 null。获取锁成功之后，会将当前线程和对应的 lockData 放到 threadData 中\n\nprivate boolean internalLock(long time, TimeUnit unit) throws Exception {\n  // 获取当前请求锁的线程\n  Thread currentThread = Thread.currentThread();\n  // 拿对应的 lockData\n  LockData lockData = threadData.get(currentThread);\n  // 第一次获取锁的话，lockData 为 null\n  if (lockData != null) {\n    // 当前线程获取过一次锁之后\n    // 因为当前线程的锁存在， lockCount 自增后返回，实现锁重入.\n    lockData.lockCount.incrementAndGet();\n    return true;\n  }\n  // 尝试获取锁\n  String lockPath = internals.attemptLock(time, unit, getLockNodeBytes());\n  if (lockPath != null) {\n    LockData newLockData = new LockData(currentThread, lockPath);\n     // 获取锁成功之后，将当前线程和对应的 lockData 放到 threadData 中\n    threadData.put(currentThread, newLockData);\n    return true;\n  }\n\n  return false;\n}\n\n\nLockData是 InterProcessMutex中的一个静态内部类。\n\nprivate final ConcurrentMap<Thread, LockData> threadData = Maps.newConcurrentMap();\n\nprivate static class LockData\n{\n    // 当前持有锁的线程\n    final Thread owningThread;\n    // 锁对应的子节点\n    final String lockPath;\n    // 加锁的次数\n    final AtomicInteger lockCount = new AtomicInteger(1);\n\n    private LockData(Thread owningThread, String lockPath)\n    {\n      this.owningThread = owningThread;\n      this.lockPath = lockPath;\n    }\n}\n\n\n如果已经获取过一次锁，后面再来获取锁的话，直接就会在 if (lockData != null) 这里被拦下了，然后就会执行lockData.lockCount.incrementAndGet(); 将加锁次数加 1。\n\n整个可重入锁的实现逻辑非常简单，直接在客户端判断当前线程有没有获取锁，有的话直接将加锁次数加 1 就可以了。\n\n\n# 总结\n\n这篇文章我们介绍了实现分布式锁的两种常见方式。至于具体选择 Redis 还是 ZooKeeper 来实现分布式锁，还是要看业务的具体需求。如果对性能要求比较高的话，建议使用 Redis 实现分布式锁。如果对可靠性要求比较高的话，建议使用 ZooKeeper 实现分布式锁。\n\n\n# reference\n\n * redisson中的看门狗机制总结 - 郭慕荣 - 博客园\n * Redis 使用Redisson+Rlock实现分布式锁 - 学无止境，贵在当下 - 博客园\n * 分布式锁常见实现方案总结\n * Redisson 分布式锁实战与 watch dog 机制解读 - 上帝爱吃苹果-Soochow - 博客园',normalizedContent:'通常情况下，一般会选择基于redis或者zookeeper实现分布式锁，redis 实现 ap架构的分布式锁，zookeeper 实现cp架构的分布式锁。\n\n\n# 基于 redis 实现分布式锁\n\n\n# 如何基于 redis 实现一个最简易的分布式锁？\n\n不论是本地锁还是分布式锁，核心都在于“互斥”。\n\n在 redis 中， setnx 命令是可以帮助我们实现互斥。setnx 即 set if not exists (对应 java 中的 setifabsent 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， setnx 啥也不做。\n\n> setnx lockkey uniquevalue\n(integer) 1\n> setnx lockkey uniquevalue\n(integer) 0\n\n\n释放锁的话，直接通过 del 命令删除对应的 key 即可。\n\n> del lockkey\n(integer) 1\n\n\n为了防止误删到其他的锁，这里我们建议使用 lua 脚本通过 key 对应的 value（唯一值）来判断。\n\n选用 lua 脚本是为了保证解锁操作的原子性。因为 redis 在执行 lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。\n\n// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放\nif redis.call("get",keys[1]) == argv[1] then\n    return redis.call("del",keys[1])\nelse\n    return 0\nend\n\n\n这是一种最简易的 redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。就比如应用程序遇到一些问题比如释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程/进程访问。\n\n\n# 为什么要给锁设置一个过期时间？\n\n为了避免锁无法被释放，我们可以想到的一个解决办法就是：给这个 key（也就是锁） 设置一个过期时间 。\n\n127.0.0.1:6379> set lockkey uniquevalue ex 3 nx\nok\n\n\n * lockkey：加锁的锁名；\n * uniquevalue：能够唯一标示锁的随机字符串；\n * nx：只有当 lockkey 对应的 key 值不存在的时候才能 set 成功；\n * ex：过期时间设置（秒为单位）ex 3 标示这个锁有一个 3 秒的自动过期时间。与 ex 对应的是 px（毫秒为单位），这两个都是过期时间设置。\n\n一定要保证设置指定 key 的值和过期时间是一个原子操作！！！ 不然的话，依然可能会出现锁无法被释放的问题。\n\n这样确实可以解决问题，不过，这种解决办法同样存在漏洞：如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。\n\n你或许在想：如果操作共享资源的操作还未完成，锁过期时间能够自己续期就好了！\n\n\n# 如何实现锁的优雅续期？\n\n对于 java 开发的小伙伴来说，已经有了现成的解决方案：redisson 。其他语言的解决方案，可以在 redis 官方文档中找到，地址：https://redis.io/topics/distlock 。\n\nredisson 是一个开源的 java 语言 redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。并且，redisson 还支持 redis 单机、redis sentinel、redis cluster 等多种部署架构。\n\nredisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 watch dog（ 看门狗），如果操作共享资源的线程还未执行完成的话，watch dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。\n\n看门狗名字的由来于 getlockwatchdogtimeout() 方法，这个方法返回的是看门狗给锁续期的过期时间，默认为 30 秒（redisson-3.17.6）。\n\n默认情况下，每过 10 秒，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。\n\n> 默认情况下，看门狗的续期时间是30s，也可以通过修改config.lockwatchdogtimeout来另行指定。另外redisson 还提供了可以指定leasetime参数的加锁方法来指定加锁的时间。超过这个时间后锁便自动解开了，不会延长锁的有效期。\n> \n> watchdog 只有在未显示指定加锁时间（leasetime）时才会生效。\n\n这里以 redisson 的分布式可重入锁 rlock 为例来说明如何使用 redisson 实现分布式锁：\n\n// 1.获取指定的分布式锁对象\nrlock lock = redisson.getlock("lock");\n// 2.拿锁且不设置锁超时时间，具备 watch dog 自动续期机制\nlock.lock();\n// 3.执行业务\n...\n// 4.释放锁\nlock.unlock();\n\n\n只有未指定锁超时时间，才会使用到 watch dog 自动续期机制。\n\n// 手动给锁设置过期时间，不具备 watch dog 自动续期机制\nlock.lock(10, timeunit.seconds);\n\n\n程序释放锁操作时因为异常没有被执行，那么锁无法被释放，所以释放锁操作一定要放到 finally {} 中。\n\n如果释放锁操作本身异常了，watch dog 还会不停的续期吗？不会，因为无论释放锁操作是否成功，expiration_renewal_map中的目标 expirationentry 对象已经被移除了，watch dog 通过判断后就不会继续给锁续期了。\n\n如果使用 redis 来实现分布式锁的话，还是比较推荐直接基于 redisson 来做的。\n\n\n# 如何实现可重入锁\n\n所谓可重入锁指的是在一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。像 java 中的 synchronized 和 reentrantlock 都属于可重入锁。\n\n不可重入的分布式锁基本可以满足绝大部分业务场景了，一些特殊的场景可能会需要使用可重入的分布式锁。\n\n可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。为此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。\n\n实际项目中，我们不需要自己手动实现，推荐使用我们上面提到的 redisson ，其内置了多种类型的锁比如可重入锁（reentrant lock）、自旋锁（spin lock）、公平锁（fair lock）、多重锁（multilock）、 红锁（redlock）、 读写锁（readwritelock）。\n\n\n# redis 如何解决集群情况下分布式锁的可靠性？\n\n为了避免单点故障，生产环境下的 redis 服务通常是集群化部署的。\n\nredis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 redis 集群数据同步到各个节点时是异步的，如果在 redis 主节点获取到锁后，在没有同步到其他节点时，redis 主节点宕机了，此时新的 redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。\n\n针对这个问题，redis 之父 antirez 设计了 redlock 算法 来解决。\n\nredlock 算法的思想是让客户端向 redis 集群中的多个独立的 redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。\n\n即使部分 redis 节点出现问题，只要保证 redis 集群中有半数以上的 redis 节点可用，分布式锁服务就是正常的。\n\n实际项目中不建议使用 redlock 算法，成本和收益不成正比。\n\n如果不是非要实现绝对可靠的分布式锁的话，其实单机版 redis 就完全够了，实现简单，性能也非常高。如果你必须要实现一个绝对可靠的分布式锁的话，可以基于 zookeeper 来做，只是性能会差一些。\n\n\n# 基于 zookeeper 实现分布式锁\n\nredis 实现分布式锁性能较高，zookeeper 实现分布式锁可靠性更高。实际项目中，我们应该根据业务的具体需求来选择。\n\n\n# 如何基于 zookeeper 实现分布式锁？\n\nzookeeper 分布式锁是基于 临时顺序节点 和 watcher（事件监听器） 实现的。\n\n获取锁：\n\n 1. 首先我们要有一个持久节点/locks，客户端获取锁就是在locks下创建临时顺序节点。\n 2. 假设客户端 1 创建了/locks/lock1节点，创建成功之后，会判断 lock1是否是 /locks 下最小的子节点。\n 3. 如果 lock1是最小的子节点，则获取锁成功。否则，获取锁失败。\n 4. 如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 并不会不停地循环去尝试加锁，而是在前一个节点比如/locks/lock0上注册一个事件监听器。这个监听器的作用是当前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。\n\n释放锁：\n\n 1. 成功获取锁的客户端在执行完业务流程之后，会将对应的子节点删除。\n 2. 成功获取锁的客户端在出现故障之后，对应的子节点由于是临时顺序节点，也会被自动删除，避免了锁无法被释放。\n 3. 我们前面说的事件监听器其实监听的就是这个子节点删除事件，子节点删除就意味着锁被释放。\n\n实际项目中，推荐使用 curator 来实现 zookeeper 分布式锁。curator 是 netflix 公司开源的一套 zookeeper java 客户端框架，相比于 zookeeper 自带的客户端 zookeeper 来说，curator 的封装更加完善，各种 api 都可以比较方便地使用。\n\ncurator主要实现了下面四种锁：\n\n * interprocessmutex：分布式可重入排它锁\n * interprocesssemaphoremutex：分布式不可重入排它锁\n * interprocessreadwritelock：分布式读写锁\n * interprocessmultilock：将多个锁作为单个实体管理的容器，获取锁的时候获取所有锁，释放锁也会释放所有锁资源（忽略释放失败的锁）。\n\ncuratorframework client = zkutils.getclient();\nclient.start();\n// 分布式可重入排它锁\ninterprocesslock lock1 = new interprocessmutex(client, lockpath1);\n// 分布式不可重入排它锁\ninterprocesslock lock2 = new interprocesssemaphoremutex(client, lockpath2);\n// 将多个锁作为一个整体\ninterprocessmultilock lock = new interprocessmultilock(arrays.aslist(lock1, lock2));\n\nif (!lock.acquire(10, timeunit.seconds)) {\n   throw new illegalstateexception("不能获取多锁");\n}\nsystem.out.println("已获取多锁");\nsystem.out.println("是否有第一个锁: " + lock1.isacquiredinthisprocess());\nsystem.out.println("是否有第二个锁: " + lock2.isacquiredinthisprocess());\ntry {\n    // 资源操作\n    resource.use();\n} finally {\n    system.out.println("释放多个锁");\n    lock.release();\n}\nsystem.out.println("是否有第一个锁: " + lock1.isacquiredinthisprocess());\nsystem.out.println("是否有第二个锁: " + lock2.isacquiredinthisprocess());\nclient.close();\n\n\n\n# 为什么要用临时顺序节点？\n\n每个数据节点在 zookeeper 中被称为 znode，它是 zookeeper 中数据的最小单元。\n\n我们通常是将 znode 分为 4 大类：\n\n * 持久（persistent）节点：一旦创建就一直存在即使 zookeeper 集群宕机，直到将其删除。\n * 临时（ephemeral）节点：临时节点的生命周期是与 客户端会话（session） 绑定的，会话消失则节点消失 。并且，临时节点只能做叶子节点 ，不能创建子节点。\n * 持久顺序（persistent_sequential）节点：除了具有持久（persistent）节点的特性之外， 子节点的名称还具有顺序性。比如 /node1/app0000000001、/node1/app0000000002 。\n * 临时顺序（ephemeral_sequential）节点：除了具备临时（ephemeral）节点的特性之外，子节点的名称还具有顺序性。\n\n可以看出，临时节点相比持久节点，最主要的是对会话失效的情况处理不一样，临时节点会话消失则对应的节点消失。这样的话，如果客户端发生异常导致没来得及释放锁也没关系，会话失效节点自动被删除，不会发生死锁的问题。\n\n使用 redis 实现分布式锁的时候，我们是通过过期时间来避免锁无法被释放导致死锁问题的，而 zookeeper 直接利用临时节点的特性即可。\n\n假设不使用顺序节点的话，所有尝试获取锁的客户端都会对持有锁的子节点加监听器。当该锁被释放之后，势必会造成所有尝试获取锁的客户端来争夺锁，这样对性能不友好。使用顺序节点之后，只需要监听前一个节点就好了，对性能更友好。\n\n\n# 为什么要设置对前一个节点的监听？\n\n> watcher（事件监听器），是 zookeeper 中的一个很重要的特性。zookeeper 允许用户在指定节点上注册一些 watcher，并且在一些特定事件触发的时候，zookeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 zookeeper 实现分布式协调服务的重要特性。\n\n同一时间段内，可能会有很多客户端同时获取锁，但只有一个可以获取成功。如果获取锁失败，则说明有其他的客户端已经成功获取锁。获取锁失败的客户端并不会不停地循环去尝试加锁，而是在前一个节点注册一个事件监听器。\n\n这个事件监听器的作用是：当前一个节点对应的客户端释放锁之后（也就是前一个节点被删除之后，监听的是删除事件），通知获取锁失败的客户端（唤醒等待的线程，java 中的 wait/notifyall ），让它尝试去获取锁，然后就成功获取锁了。\n\n\n# 如何实现可重入锁？\n\n这里以 curator 的 interprocessmutex 对可重入锁的实现来介绍（源码地址：interprocessmutex.java）。\n\n当我们调用 interprocessmutex#acquire方法获取锁的时候，会调用interprocessmutex#internallock方法。\n\n// 获取可重入互斥锁，直到获取成功为止\n@override\npublic void acquire() throws exception {\n  if (!internallock(-1, null)) {\n    throw new ioexception("lost connection while trying to acquire lock: " + basepath);\n  }\n}\n\n\ninternallock 方法会先获取当前请求锁的线程，然后从 threaddata( concurrentmap<thread, lockdata> 类型)中获取当前线程对应的 lockdata 。 lockdata 包含锁的信息和加锁的次数，是实现可重入锁的关键。\n\n第一次获取锁的时候，lockdata为 null。获取锁成功之后，会将当前线程和对应的 lockdata 放到 threaddata 中\n\nprivate boolean internallock(long time, timeunit unit) throws exception {\n  // 获取当前请求锁的线程\n  thread currentthread = thread.currentthread();\n  // 拿对应的 lockdata\n  lockdata lockdata = threaddata.get(currentthread);\n  // 第一次获取锁的话，lockdata 为 null\n  if (lockdata != null) {\n    // 当前线程获取过一次锁之后\n    // 因为当前线程的锁存在， lockcount 自增后返回，实现锁重入.\n    lockdata.lockcount.incrementandget();\n    return true;\n  }\n  // 尝试获取锁\n  string lockpath = internals.attemptlock(time, unit, getlocknodebytes());\n  if (lockpath != null) {\n    lockdata newlockdata = new lockdata(currentthread, lockpath);\n     // 获取锁成功之后，将当前线程和对应的 lockdata 放到 threaddata 中\n    threaddata.put(currentthread, newlockdata);\n    return true;\n  }\n\n  return false;\n}\n\n\nlockdata是 interprocessmutex中的一个静态内部类。\n\nprivate final concurrentmap<thread, lockdata> threaddata = maps.newconcurrentmap();\n\nprivate static class lockdata\n{\n    // 当前持有锁的线程\n    final thread owningthread;\n    // 锁对应的子节点\n    final string lockpath;\n    // 加锁的次数\n    final atomicinteger lockcount = new atomicinteger(1);\n\n    private lockdata(thread owningthread, string lockpath)\n    {\n      this.owningthread = owningthread;\n      this.lockpath = lockpath;\n    }\n}\n\n\n如果已经获取过一次锁，后面再来获取锁的话，直接就会在 if (lockdata != null) 这里被拦下了，然后就会执行lockdata.lockcount.incrementandget(); 将加锁次数加 1。\n\n整个可重入锁的实现逻辑非常简单，直接在客户端判断当前线程有没有获取锁，有的话直接将加锁次数加 1 就可以了。\n\n\n# 总结\n\n这篇文章我们介绍了实现分布式锁的两种常见方式。至于具体选择 redis 还是 zookeeper 来实现分布式锁，还是要看业务的具体需求。如果对性能要求比较高的话，建议使用 redis 实现分布式锁。如果对可靠性要求比较高的话，建议使用 zookeeper 实现分布式锁。\n\n\n# reference\n\n * redisson中的看门狗机制总结 - 郭慕荣 - 博客园\n * redis 使用redisson+rlock实现分布式锁 - 学无止境，贵在当下 - 博客园\n * 分布式锁常见实现方案总结\n * redisson 分布式锁实战与 watch dog 机制解读 - 上帝爱吃苹果-soochow - 博客园',charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"幂等性介绍",frontmatter:{title:"幂等性介绍",date:"2023-10-24T03:41:21.000Z",permalink:"/pages/8c09c7/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/04.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F/02.%E5%B9%82%E7%AD%89%E6%80%A7/01.%E5%B9%82%E7%AD%89%E6%80%A7%E4%BB%8B%E7%BB%8D.html",relativePath:"01.Java 知识体系/04.系统设计/02.分布式/02.幂等性/01.幂等性介绍.md",key:"v-3bafe364",path:"/pages/8c09c7/",headers:[{level:1,title:"reference",slug:"reference",normalizedTitle:"reference",charIndex:465}],headersStr:"reference",content:"**什么是幂等？**在分布式系统中，幂等是对请求操作结果的一个描述，这个描述就是不论执行多少次相同的请求，产生的效果和返回的结果都和发出单个请求是一样的。\n\n举个例子：假如前后端没有保证接口幂等性，用户在秒杀商品是，同时点击了多次秒杀商品按钮，后端处理了多次相同的订单请求，结果导致一个人秒杀了多个商品。这个是肯定不能出现的，属于非常严重的bug。\n\n保证分布式接口的幂等性对于数据的一致性至关重要，特别是像支付这种涉及到钱的接口。保证幂等性这个操作并不是说前端做了就可以，后端同样要做。\n\n前端保证幂等性的话比较简单，一般通过当用户提交请求后将按钮置灰来做到。后端保证幂等性就稍微麻烦一点，方法也是有很多种，比如：\n\n 1. 分布式锁\n 2. 唯一索引：业务字段的唯一索引约束，防止重复数据产生。\n 3. 乐观锁：先查出版本号，再通过版本号更新数据，版本号一致才更新数据\n 4. 状态机：状态机可能看起来和乐观锁有点一样，但是有一个关键的区别，乐观锁的版本号是无界的，而状态机一般都是有边界的。\n 5. 获取token\n\n\n# reference\n\n * 幂等性常用的解决方案 - 掘金",normalizedContent:"**什么是幂等？**在分布式系统中，幂等是对请求操作结果的一个描述，这个描述就是不论执行多少次相同的请求，产生的效果和返回的结果都和发出单个请求是一样的。\n\n举个例子：假如前后端没有保证接口幂等性，用户在秒杀商品是，同时点击了多次秒杀商品按钮，后端处理了多次相同的订单请求，结果导致一个人秒杀了多个商品。这个是肯定不能出现的，属于非常严重的bug。\n\n保证分布式接口的幂等性对于数据的一致性至关重要，特别是像支付这种涉及到钱的接口。保证幂等性这个操作并不是说前端做了就可以，后端同样要做。\n\n前端保证幂等性的话比较简单，一般通过当用户提交请求后将按钮置灰来做到。后端保证幂等性就稍微麻烦一点，方法也是有很多种，比如：\n\n 1. 分布式锁\n 2. 唯一索引：业务字段的唯一索引约束，防止重复数据产生。\n 3. 乐观锁：先查出版本号，再通过版本号更新数据，版本号一致才更新数据\n 4. 状态机：状态机可能看起来和乐观锁有点一样，但是有一个关键的区别，乐观锁的版本号是无界的，而状态机一般都是有边界的。\n 5. 获取token\n\n\n# reference\n\n * 幂等性常用的解决方案 - 掘金",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"RPC介绍",frontmatter:{title:"RPC介绍",date:"2023-10-24T03:40:33.000Z",permalink:"/pages/126fc8/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/04.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F/03.RPC%E4%BB%8B%E7%BB%8D.html",relativePath:"01.Java 知识体系/04.系统设计/02.分布式/03.RPC介绍.md",key:"v-af103070",path:"/pages/126fc8/",headers:[{level:1,title:"RPC是什么",slug:"rpc是什么",normalizedTitle:"rpc是什么",charIndex:2},{level:1,title:"RPC原理",slug:"rpc原理",normalizedTitle:"rpc原理",charIndex:309}],headersStr:"RPC是什么 RPC原理",content:"# RPC是什么\n\nRPC（Remote Procedure Call）：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。\n\n比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。\n\nRPC主要解决了：让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。\n\n举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。\n\n\n# RPC原理\n\n\n\n 1. 服务消费端（client）以本地调用的方式调用远程服务；\n\n 2. 客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：RpcRequest；\n\n 3. 客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；\n\n 4. 服务端 Stub（桩）收到消息将消息反序列化为Java对象: RpcRequest；\n\n 5. 服务端 Stub（桩）根据RpcRequest中的类、方法、方法参数等信息调用本地的方法；\n\n 6. 服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：RpcResponse（序列化）发送至消费方；\n\n 7. 客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:RpcResponse ，这样也就得到了最终结果。\n\n再贴一个网上的时序图，辅助理解：\n\n",normalizedContent:"# rpc是什么\n\nrpc（remote procedure call）：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。\n\n比如两个不同的服务 a、b 部署在两台不同的机器上，那么服务 a 如果想要调用服务 b 中的某个方法该怎么办呢？使用 http请求 当然可以，但是可能会比较慢而且一些优化做的并不好。 rpc 的出现就是为了解决这个问题。\n\nrpc主要解决了：让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。\n\n举个例子：两个不同的服务 a、b 部署在两台不同的机器上，服务 a 如果想要调用服务 b 中的某个方法的话就可以通过 rpc 来做。\n\n\n# rpc原理\n\n\n\n 1. 服务消费端（client）以本地调用的方式调用远程服务；\n\n 2. 客户端 stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：rpcrequest；\n\n 3. 客户端 stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；\n\n 4. 服务端 stub（桩）收到消息将消息反序列化为java对象: rpcrequest；\n\n 5. 服务端 stub（桩）根据rpcrequest中的类、方法、方法参数等信息调用本地的方法；\n\n 6. 服务端 stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：rpcresponse（序列化）发送至消费方；\n\n 7. 客户端 stub（client stub）接收到消息并将消息反序列化为java对象:rpcresponse ，这样也就得到了最终结果。\n\n再贴一个网上的时序图，辅助理解：\n\n",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"SpringCloud",frontmatter:{title:"SpringCloud",date:"2023-10-24T07:34:59.000Z",permalink:"/pages/d2a1d0/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/04.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/03.%E5%BE%AE%E6%9C%8D%E5%8A%A1/01.SpringCloud/01.SpringCloud.html",relativePath:"01.Java 知识体系/04.系统设计/03.微服务/01.SpringCloud/01.SpringCloud.md",key:"v-0b8ed9f8",path:"/pages/d2a1d0/",headers:[{level:2,title:"Ribbon",slug:"ribbon",normalizedTitle:"ribbon",charIndex:2},{level:2,title:"OpenFeign",slug:"openfeign",normalizedTitle:"openfeign",charIndex:40},{level:2,title:"Gateway",slug:"gateway",normalizedTitle:"gateway",charIndex:206}],headersStr:"Ribbon OpenFeign Gateway",content:"# Ribbon\n\nRibbon支持的负载均衡策略。默认的负载均衡策略\n\n\n# OpenFeign\n\nFeign 是Netfix开发的声明式、模版化的HTTP客户端。\n\nOpenFeign：Fegin增强，支持SpringMVC注解。\n\n@FeginClient（动态代理）\n\n日志配置：\n\n * 全局配置\n * 局部配置\n\n超时时间配置：\n\n * 连接超时时间\n * 请求处理超时时间\n\n自定义拦截器\n\n\n# Gateway\n\nAPI网关。\n\nGateway网关组件。特性：\n\n * 动态路由\n * 路径重写\n * 集成流控降级\n * 断言和过滤器\n\n核心概念：\n\n * 路由\n * 断言\n * 过滤器\n\n断言工厂：\n\n * 内置断言工厂\n * 自定义路由断言工厂\n\n过滤器工厂（局部过滤器）：\n\n * 内置过滤器工厂\n * 自定义过滤器工厂\n\n全局过滤器：\n\n * 内置全局过滤器\n * 自定义全局过滤器\n\nGateway整合Nacos。\n\nGateway请求日志记录\n\nGateway跨域处理\n\nGateway整合Sentinel进行限流降级。\n\nGateway高可用部署：Nginx负载均衡",normalizedContent:"# ribbon\n\nribbon支持的负载均衡策略。默认的负载均衡策略\n\n\n# openfeign\n\nfeign 是netfix开发的声明式、模版化的http客户端。\n\nopenfeign：fegin增强，支持springmvc注解。\n\n@feginclient（动态代理）\n\n日志配置：\n\n * 全局配置\n * 局部配置\n\n超时时间配置：\n\n * 连接超时时间\n * 请求处理超时时间\n\n自定义拦截器\n\n\n# gateway\n\napi网关。\n\ngateway网关组件。特性：\n\n * 动态路由\n * 路径重写\n * 集成流控降级\n * 断言和过滤器\n\n核心概念：\n\n * 路由\n * 断言\n * 过滤器\n\n断言工厂：\n\n * 内置断言工厂\n * 自定义路由断言工厂\n\n过滤器工厂（局部过滤器）：\n\n * 内置过滤器工厂\n * 自定义过滤器工厂\n\n全局过滤器：\n\n * 内置全局过滤器\n * 自定义全局过滤器\n\ngateway整合nacos。\n\ngateway请求日志记录\n\ngateway跨域处理\n\ngateway整合sentinel进行限流降级。\n\ngateway高可用部署：nginx负载均衡",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"SpringCloudAlibaba",frontmatter:{title:"SpringCloudAlibaba",date:"2023-10-24T07:35:15.000Z",permalink:"/pages/a8e8ff/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/04.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/03.%E5%BE%AE%E6%9C%8D%E5%8A%A1/02.SpringCloudAlibaba/01.SpringCloudAlibaba.html",relativePath:"01.Java 知识体系/04.系统设计/03.微服务/02.SpringCloudAlibaba/01.SpringCloudAlibaba.md",key:"v-31eab8d8",path:"/pages/a8e8ff/",headers:[{level:2,title:"Nacos",slug:"nacos",normalizedTitle:"nacos",charIndex:45},{level:3,title:"注册中心",slug:"注册中心",normalizedTitle:"注册中心",charIndex:117},{level:3,title:"配置中心",slug:"配置中心",normalizedTitle:"配置中心",charIndex:277},{level:3,title:"集群",slug:"集群",normalizedTitle:"集群",charIndex:562},{level:2,title:"Sentinel",slug:"sentinel",normalizedTitle:"sentinel",charIndex:633},{level:2,title:"Seata",slug:"seata",normalizedTitle:"seata",charIndex:999}],headersStr:"Nacos 注册中心 配置中心 集群 Sentinel Seata",content:"Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。\n\n\n# Nacos\n\nNacos 一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\n\nNacos 支持CP和AP，默认使用AP\n\n\n# 注册中心\n\n心跳机制：解决服务多负载服务宕机的问题。\n\nNacos Discover：服务注册与发现，定时拉取服务列表。\n\n客户端负载均衡：Nacos默认使用Ribbon做负载均衡。\n\n修改Ribbon的负载均衡策略。自定义Ribbon负载均衡策略。\n\n使用LoadBalancer替换Ribbon做负载均衡。\n\n\n# 配置中心\n\n特性：\n\n * 维护性：集中式配置管理\n * 时效性：更新配置信息\n * 安全性：权限管理\n\n概念：\n\n * 命名空间\n * 组\n * Data Id\n\n服务读取Nacos配置中心配置信息：\n\n * 默认配置文件（支持多profile配置）\n * 自定义配置文件（extension-configs、shared-configs）\n\n配置文件优先级：profile>默认配置文件>extension-configs（下标越大优先级越大）>shared-configs（下标越大优先级越大）\n\n@Value需加@RefreshScope才能自动刷新。\n\n\n# 集群\n\nNacos集群搭建：\n\n 1. Nacos修改数据源为MySQL，配置为集群模式\n 2. 修改Nginx配置文件做负载均衡。\n\n\n# Sentinel\n\n服务雪崩：服务提供者不可用导致服务调用者不可用，并将不可用逐渐放大的过程。\n\n解决方法——添加容错机制：\n\n * 超时机制\n * 服务限流\n * 服务降级\n * 服务熔断\n\nSentinel 是面向分布式、多语言异构化服务架构的流量治理组件。\n\nSentinel 分为核心库和控制台两个部分。\n\n核心概念：\n\n * 资源：可以是任何东西，服务，服务里的方法，甚至是一段代码。\n * 规则：流量控制规则、熔断降级规则、系统保护规则、来源访问控制规则 和 热点参数规则。默认保存到内存中，可以配置持久化（比如整合Nacos配置中心）\n\n使用 Sentinel 来进行资源保护，主要分为几个步骤:\n\n 1. 定义资源\n 2. 定义规则\n 3. 检验规则是否生效\n\nSentinel 整合 OpenFeign。\n\n\n# Seata\n\n分布式事务理论基础：\n\n * 2PC\n * 3PC\n\n2PC 事务实现：\n\n * AT模式（无侵入性）：\n   * 解析SQL、BeforeImage、执行SQL、AfterImage、行锁\n   * 成功（删除行锁）\n * TCC\n * SAGA\n * XA\n\nSeata是一款开源的分布式事务解决方案。\n\n支持AT、TCC、SAGA、XA事务模式。推荐使用AT模式。\n\nSeata 角色：\n\n * 事务协调者\n * 事务管理器\n * 资源管理器\n\nSeata环境搭建：\n\n * Seata 服务端高可用部署：使用DB数据源+Nacos（注册中心+配置中心）\n * Seata 客户端搭建\n\n@GlobalTransacational注解使用。\n\nSeata AT模式的原理。",normalizedContent:"spring cloud alibaba 致力于提供微服务开发的一站式解决方案。\n\n\n# nacos\n\nnacos 一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\n\nnacos 支持cp和ap，默认使用ap\n\n\n# 注册中心\n\n心跳机制：解决服务多负载服务宕机的问题。\n\nnacos discover：服务注册与发现，定时拉取服务列表。\n\n客户端负载均衡：nacos默认使用ribbon做负载均衡。\n\n修改ribbon的负载均衡策略。自定义ribbon负载均衡策略。\n\n使用loadbalancer替换ribbon做负载均衡。\n\n\n# 配置中心\n\n特性：\n\n * 维护性：集中式配置管理\n * 时效性：更新配置信息\n * 安全性：权限管理\n\n概念：\n\n * 命名空间\n * 组\n * data id\n\n服务读取nacos配置中心配置信息：\n\n * 默认配置文件（支持多profile配置）\n * 自定义配置文件（extension-configs、shared-configs）\n\n配置文件优先级：profile>默认配置文件>extension-configs（下标越大优先级越大）>shared-configs（下标越大优先级越大）\n\n@value需加@refreshscope才能自动刷新。\n\n\n# 集群\n\nnacos集群搭建：\n\n 1. nacos修改数据源为mysql，配置为集群模式\n 2. 修改nginx配置文件做负载均衡。\n\n\n# sentinel\n\n服务雪崩：服务提供者不可用导致服务调用者不可用，并将不可用逐渐放大的过程。\n\n解决方法——添加容错机制：\n\n * 超时机制\n * 服务限流\n * 服务降级\n * 服务熔断\n\nsentinel 是面向分布式、多语言异构化服务架构的流量治理组件。\n\nsentinel 分为核心库和控制台两个部分。\n\n核心概念：\n\n * 资源：可以是任何东西，服务，服务里的方法，甚至是一段代码。\n * 规则：流量控制规则、熔断降级规则、系统保护规则、来源访问控制规则 和 热点参数规则。默认保存到内存中，可以配置持久化（比如整合nacos配置中心）\n\n使用 sentinel 来进行资源保护，主要分为几个步骤:\n\n 1. 定义资源\n 2. 定义规则\n 3. 检验规则是否生效\n\nsentinel 整合 openfeign。\n\n\n# seata\n\n分布式事务理论基础：\n\n * 2pc\n * 3pc\n\n2pc 事务实现：\n\n * at模式（无侵入性）：\n   * 解析sql、beforeimage、执行sql、afterimage、行锁\n   * 成功（删除行锁）\n * tcc\n * saga\n * xa\n\nseata是一款开源的分布式事务解决方案。\n\n支持at、tcc、saga、xa事务模式。推荐使用at模式。\n\nseata 角色：\n\n * 事务协调者\n * 事务管理器\n * 资源管理器\n\nseata环境搭建：\n\n * seata 服务端高可用部署：使用db数据源+nacos（注册中心+配置中心）\n * seata 客户端搭建\n\n@globaltransacational注解使用。\n\nseata at模式的原理。",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"Dubbo",frontmatter:{title:"Dubbo",date:"2023-10-24T03:38:56.000Z",permalink:"/pages/80c6b1/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/04.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F/04.Dubbo.html",relativePath:"01.Java 知识体系/04.系统设计/02.分布式/04.Dubbo.md",key:"v-d2430cca",path:"/pages/80c6b1/",headers:[{level:1,title:"Dubbo简介",slug:"dubbo简介",normalizedTitle:"dubbo简介",charIndex:2},{level:2,title:"Dubbo是什么",slug:"dubbo是什么",normalizedTitle:"dubbo是什么",charIndex:14},{level:2,title:"Dubbo架构",slug:"dubbo架构",normalizedTitle:"dubbo架构",charIndex:454},{level:1,title:"Dubbo应用实例",slug:"dubbo应用实例",normalizedTitle:"dubbo应用实例",charIndex:878},{level:2,title:"多注册中心",slug:"多注册中心",normalizedTitle:"多注册中心",charIndex:892}],headersStr:"Dubbo简介 Dubbo是什么 Dubbo架构 Dubbo应用实例 多注册中心",content:'# Dubbo简介\n\n\n# Dubbo是什么\n\nApache Dubbo 是一款高性能、轻量级的开源 Java RPC 框架。\n\n提供了六大核心能力\n\n 1. 面向接口代理的高性能RPC调用。\n\n 2. 智能容错和负载均衡。\n\n 3. 服务自动注册和发现。\n\n 4. 高度可扩展能力。\n\n 5. 运行期流量调度。\n\n 6. 可视化的服务治理与运维。\n\n简单来说就是： Dubbo 不光可以帮助我们调用远程服务，还提供了一些其他开箱即用的功能比如智能负载均衡。\n\n\n\nDubbo能帮助我们解决什么问题？\n\n * 负载均衡 ： 同一个服务部署在不同的机器时该调用那一台机器上的服务。\n\n * 服务调用链路生成 ： 随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。\n\n * 服务访问压力以及时长统计、资源调度和治理 ：基于访问压力实时管理集群容量，提高集群利用率。\n\n\n# Dubbo架构\n\n\n\n节点角色说明：\n\n节点          角色说明\nProvider    暴露服务的服务提供方\nConsumer    调用远程服务的服务消费方\nRegistry    服务注册与发现的注册中心\nMonitor     统计服务的调用次数和调用时间的监控中心\nContainer   服务运行容器\n\n调用关系说明：\n\n 1. 服务容器负责启动，加载，运行服务提供者。\n\n 2. 服务提供者在启动时，向注册中心注册自己提供的服务。\n\n 3. 服务消费者在启动时，向注册中心订阅自己所需的服务。\n\n 4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。\n\n 5. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n\n 6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n\n\n# Dubbo应用实例\n\n\n# 多注册中心\n\nDubbo支持同一服务向多注册中心同时注册。或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。\n\n用法\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n    xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd">\n    <dubbo:application name="world"  />\n    \x3c!-- 多注册中心配置 --\x3e\n    <dubbo:registry id="hangzhouRegistry" address="10.20.141.150:9090" />\n    <dubbo:registry id="qingdaoRegistry" address="10.20.141.151:9010" default="false" />\n    \x3c!-- 向多个注册中心注册 --\x3e\n    <dubbo:service interface="com.alibaba.hello.api.HelloService" version="1.0.0" ref="helloService" registry="hangzhouRegistry,qingdaoRegistry" />\n</beans>\n\n\ndubbo:reference 配置的registry属性默认从所有注册中心获服务列表后合并结果。这样当一个注册中心没有某个服务时，其他注册中心有这个服务，也能获取到这个服务进行使用。',normalizedContent:'# dubbo简介\n\n\n# dubbo是什么\n\napache dubbo 是一款高性能、轻量级的开源 java rpc 框架。\n\n提供了六大核心能力\n\n 1. 面向接口代理的高性能rpc调用。\n\n 2. 智能容错和负载均衡。\n\n 3. 服务自动注册和发现。\n\n 4. 高度可扩展能力。\n\n 5. 运行期流量调度。\n\n 6. 可视化的服务治理与运维。\n\n简单来说就是： dubbo 不光可以帮助我们调用远程服务，还提供了一些其他开箱即用的功能比如智能负载均衡。\n\n\n\ndubbo能帮助我们解决什么问题？\n\n * 负载均衡 ： 同一个服务部署在不同的机器时该调用那一台机器上的服务。\n\n * 服务调用链路生成 ： 随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。dubbo 可以为我们解决服务之间互相是如何调用的。\n\n * 服务访问压力以及时长统计、资源调度和治理 ：基于访问压力实时管理集群容量，提高集群利用率。\n\n\n# dubbo架构\n\n\n\n节点角色说明：\n\n节点          角色说明\nprovider    暴露服务的服务提供方\nconsumer    调用远程服务的服务消费方\nregistry    服务注册与发现的注册中心\nmonitor     统计服务的调用次数和调用时间的监控中心\ncontainer   服务运行容器\n\n调用关系说明：\n\n 1. 服务容器负责启动，加载，运行服务提供者。\n\n 2. 服务提供者在启动时，向注册中心注册自己提供的服务。\n\n 3. 服务消费者在启动时，向注册中心订阅自己所需的服务。\n\n 4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。\n\n 5. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n\n 6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n\n\n# dubbo应用实例\n\n\n# 多注册中心\n\ndubbo支持同一服务向多注册中心同时注册。或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。\n\n用法\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n    xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"\n    xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd">\n    <dubbo:application name="world"  />\n    \x3c!-- 多注册中心配置 --\x3e\n    <dubbo:registry id="hangzhouregistry" address="10.20.141.150:9090" />\n    <dubbo:registry id="qingdaoregistry" address="10.20.141.151:9010" default="false" />\n    \x3c!-- 向多个注册中心注册 --\x3e\n    <dubbo:service interface="com.alibaba.hello.api.helloservice" version="1.0.0" ref="helloservice" registry="hangzhouregistry,qingdaoregistry" />\n</beans>\n\n\ndubbo:reference 配置的registry属性默认从所有注册中心获服务列表后合并结果。这样当一个注册中心没有某个服务时，其他注册中心有这个服务，也能获取到这个服务进行使用。',charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"链路追踪SkyWalking",frontmatter:{title:"链路追踪SkyWalking",date:"2023-10-24T07:34:41.000Z",permalink:"/pages/01d62e/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/04.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/03.%E5%BE%AE%E6%9C%8D%E5%8A%A1/03.%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AASkyWalking.html",relativePath:"01.Java 知识体系/04.系统设计/03.微服务/03.链路追踪SkyWalking.md",key:"v-2bf7dba4",path:"/pages/01d62e/",headers:[{level:1,title:"链路追踪SkyWalking",slug:"链路追踪skywalking",normalizedTitle:"链路追踪skywalking",charIndex:2}],headersStr:"链路追踪SkyWalking",content:"# 链路追踪SkyWalking\n\n无侵入式（使用Java指针）\n\nSkyWalking 环境搭建：\n\n * 服务端和UI搭建\n * SkyWalking接入微服务（设置微服务JVM参数）\n\nSkyWalking 数据持久化，默认H2数据库存储，可修改成MySQL、es等。\n\nSkyWalking自定义链路追踪：\n\n * @Trace注解\n * @Tags、@Tag\n\nSkyWalking 性能剖析\n\nSkyWalking告警功能：\n\n * 告警规则\n * 网络钩子\n\nSkyWaking高可用集群配置",normalizedContent:"# 链路追踪skywalking\n\n无侵入式（使用java指针）\n\nskywalking 环境搭建：\n\n * 服务端和ui搭建\n * skywalking接入微服务（设置微服务jvm参数）\n\nskywalking 数据持久化，默认h2数据库存储，可修改成mysql、es等。\n\nskywalking自定义链路追踪：\n\n * @trace注解\n * @tags、@tag\n\nskywalking 性能剖析\n\nskywalking告警功能：\n\n * 告警规则\n * 网络钩子\n\nskywaking高可用集群配置",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"分布式定时任务——Quartz",frontmatter:{title:"分布式定时任务——Quartz",date:"2023-10-24T07:41:08.000Z",permalink:"/pages/ada754/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/04.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/04.%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/02.%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E2%80%94%E2%80%94Quartz.html",relativePath:"01.Java 知识体系/04.系统设计/04.定时任务/02.分布式定时任务——Quartz.md",key:"v-2da3c232",path:"/pages/ada754/",headers:[{level:1,title:"Quartz 介绍",slug:"quartz-介绍",normalizedTitle:"quartz 介绍",charIndex:2},{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:16},{level:2,title:"特点",slug:"特点",normalizedTitle:"特点",charIndex:72},{level:2,title:"组成",slug:"组成",normalizedTitle:"组成",charIndex:261},{level:1,title:"reference",slug:"reference",normalizedTitle:"reference",charIndex:495}],headersStr:"Quartz 介绍 概述 特点 组成 reference",content:"# Quartz 介绍\n\n\n# 概述\n\nQuartz是OpenSymphony开源的一个项目，是一个由Java编写的开源作业调度框架。\n\n\n# 特点\n\n * 支持分布式高可用，我们需要某个定时任务在多个节点中只有某个节点可以执行时，就需要Quartz来实现，否则使用@Scheduled等方式会造成所有节点都执行一遍。\n\n * 支持持久化，Quartz有专门的数据表来实现定时任务的持久化。\n\n * 支持多任务调度和管理，Quartz可以在数据库中存储多个定时任务进行作业调度，可以实现定时任务的增删改查等管理。\n\n\n# 组成\n\nQuartz由三部分组成：\n\n 1. 任务：JobDetail\n 2. 触发器：Trigger规定触发执行Job实现类，主要有SimpleTrigger和CronTrigger两个实现类。\n 3. 调度器：Scheduler就是为了读取触发器Trigger从而触发定时任务JobDetail。可以通过SchedulerFactory进行创建调度器，分为StdSchedulerFactory（常用）和DirectSchedulerFactory两种。\n\n\n# reference\n\n * SpringBoot——Quartz定时框架的使用详解和总结 - 掘金\n * quartz基本介绍和使用 - KyleInJava - 博客园",normalizedContent:"# quartz 介绍\n\n\n# 概述\n\nquartz是opensymphony开源的一个项目，是一个由java编写的开源作业调度框架。\n\n\n# 特点\n\n * 支持分布式高可用，我们需要某个定时任务在多个节点中只有某个节点可以执行时，就需要quartz来实现，否则使用@scheduled等方式会造成所有节点都执行一遍。\n\n * 支持持久化，quartz有专门的数据表来实现定时任务的持久化。\n\n * 支持多任务调度和管理，quartz可以在数据库中存储多个定时任务进行作业调度，可以实现定时任务的增删改查等管理。\n\n\n# 组成\n\nquartz由三部分组成：\n\n 1. 任务：jobdetail\n 2. 触发器：trigger规定触发执行job实现类，主要有simpletrigger和crontrigger两个实现类。\n 3. 调度器：scheduler就是为了读取触发器trigger从而触发定时任务jobdetail。可以通过schedulerfactory进行创建调度器，分为stdschedulerfactory（常用）和directschedulerfactory两种。\n\n\n# reference\n\n * springboot——quartz定时框架的使用详解和总结 - 掘金\n * quartz基本介绍和使用 - kyleinjava - 博客园",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"Java 定时任务大全",frontmatter:{title:"Java 定时任务大全",date:"2023-10-24T07:41:08.000Z",permalink:"/pages/ae063e/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/04.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/04.%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/01.Java%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%A4%A7%E5%85%A8.html",relativePath:"01.Java 知识体系/04.系统设计/04.定时任务/01.Java 定时任务大全.md",key:"v-27a25f92",path:"/pages/ae063e/",headers:[{level:1,title:"为什么需要定时任务？",slug:"为什么需要定时任务",normalizedTitle:"为什么需要定时任务？",charIndex:2},{level:1,title:"单机定时任务技术选型",slug:"单机定时任务技术选型",normalizedTitle:"单机定时任务技术选型",charIndex:224},{level:2,title:"Timer",slug:"timer",normalizedTitle:"timer",charIndex:239},{level:2,title:"ScheduledExecutorService",slug:"scheduledexecutorservice",normalizedTitle:"scheduledexecutorservice",charIndex:1082},{level:2,title:"Spring Task",slug:"spring-task",normalizedTitle:"spring task",charIndex:2239},{level:2,title:"时间轮",slug:"时间轮",normalizedTitle:"时间轮",charIndex:2813},{level:1,title:"分布式定时任务技术选型",slug:"分布式定时任务技术选型",normalizedTitle:"分布式定时任务技术选型",charIndex:3683},{level:2,title:"Quartz",slug:"quartz",normalizedTitle:"quartz",charIndex:3957},{level:2,title:"Elastic-Job",slug:"elastic-job",normalizedTitle:"elastic-job",charIndex:4214},{level:2,title:"XXL-JOB",slug:"xxl-job",normalizedTitle:"xxl-job",charIndex:5309},{level:2,title:"PowerJob",slug:"powerjob",normalizedTitle:"powerjob",charIndex:6432},{level:1,title:"reference",slug:"reference",normalizedTitle:"reference",charIndex:6727}],headersStr:"为什么需要定时任务？ 单机定时任务技术选型 Timer ScheduledExecutorService Spring Task 时间轮 分布式定时任务技术选型 Quartz Elastic-Job XXL-JOB PowerJob reference",content:'# 为什么需要定时任务？\n\n我们来看一下几个非常常见的业务场景：\n\n 1. 某系统凌晨要进行数据备份。\n 2. 某电商平台，用户下单半个小时未支付的情况下需要自动取消订单。\n 3. 某媒体聚合平台，每 10 分钟动态抓取某某网站的数据为自己所用。\n 4. 某博客平台，支持定时发送文章。\n 5. 某基金平台，每晚定时计算用户当日收益情况并推送给用户最新的数据。\n 6. ......\n\n这些场景往往都要求我们在某个特定的时间去做某个事情。\n\n\n# 单机定时任务技术选型\n\n\n# Timer\n\njava.util.Timer是 JDK 1.3 开始就已经支持的一种定时任务的实现方式。\n\nTimer 内部使用一个叫做 TaskQueue 的类存放定时任务，它是一个基于最小堆实现的优先级队列。TaskQueue 会按照任务距离下一次执行时间的大小将任务排序，保证在堆顶的任务最先执行。这样在需要执行任务时，每次只需要取出堆顶的任务运行即可！\n\nTimer 使用起来比较简单，通过下面的方式我们就能创建一个 1s 之后执行的定时任务。\n\n// 示例代码：\nTimerTask task = new TimerTask() {\n    public void run() {\n        System.out.println("当前时间: " + new Date() + "n" +\n                "线程名称: " + Thread.currentThread().getName());\n    }\n};\nSystem.out.println("当前时间: " + new Date() + "n" +\n        "线程名称: " + Thread.currentThread().getName());\nTimer timer = new Timer("Timer");\nlong delay = 1000L;\ntimer.schedule(task, delay);\n\n\n//输出：\n当前时间: Fri May 28 15:18:47 CST 2021n线程名称: main\n当前时间: Fri May 28 15:18:48 CST 2021n线程名称: Timer\n\n\n\n不过其缺陷较多，比如一个 Timer 一个线程，这就导致 Timer 的任务的执行只能串行执行，一个任务执行时间过长的话会影响其他任务（性能非常差），再比如发生异常时任务直接停止（Timer 只捕获了 InterruptedException ）。\n\n\n# ScheduledExecutorService\n\nScheduledExecutorService 是一个接口，有多个实现类，比较常用的是 ScheduledThreadPoolExecutor 。\n\n\n\nScheduledThreadPoolExecutor 本身就是一个线程池，支持任务并发执行。并且，其内部使用 DelayQueue 作为任务队列。\n\n// 示例代码：\nTimerTask repeatedTask = new TimerTask() {\n    @SneakyThrows\n    public void run() {\n        System.out.println("当前时间: " + new Date() + "n" +\n                "线程名称: " + Thread.currentThread().getName());\n    }\n};\nSystem.out.println("当前时间: " + new Date() + "n" +\n        "线程名称: " + Thread.currentThread().getName());\nScheduledExecutorService executor = Executors.newScheduledThreadPool(3);\nlong delay  = 1000L;\nlong period = 1000L;\nexecutor.scheduleAtFixedRate(repeatedTask, delay, period, TimeUnit.MILLISECONDS);\nThread.sleep(delay + period * 5);\nexecutor.shutdown();\n//输出：\n当前时间: Fri May 28 15:40:46 CST 2021n线程名称: main\n当前时间: Fri May 28 15:40:47 CST 2021n线程名称: pool-1-thread-1\n当前时间: Fri May 28 15:40:48 CST 2021n线程名称: pool-1-thread-1\n当前时间: Fri May 28 15:40:49 CST 2021n线程名称: pool-1-thread-2\n当前时间: Fri May 28 15:40:50 CST 2021n线程名称: pool-1-thread-2\n当前时间: Fri May 28 15:40:51 CST 2021n线程名称: pool-1-thread-2\n当前时间: Fri May 28 15:40:52 CST 2021n线程名称: pool-1-thread-2\n\n\n\n\n# Spring Task\n\n我们直接通过 Spring 提供的 @Scheduled 注解即可定义定时任务，非常方便！\n\n/**\n * cron：使用Cron表达式。　每分钟的1，2秒运行\n */\n@Scheduled(cron = "1-2 * * * * ? ")\npublic void reportCurrentTimeWithCronExpression() {\n  log.info("Cron Expression: The time is now {}", dateFormat.format(new Date()));\n}\n\n\n\n\n并且，Spring Task 还是支持 Cron 表达式 的。Cron 表达式主要用于定时作业(定时任务)系统定义执行时间或执行频率的表达式，非常厉害，你可以通过 Cron 表达式进行设置定时任务每天或者每个月什么时候执行等等操作。咱们要学习定时任务的话，Cron 表达式是一定是要重点关注的。推荐一个在线 Cron 表达式生成器：http://cron.qqe2.com/\n\nSpring Task 底层是基于 JDK 的 ScheduledThreadPoolExecutor 线程池来实现的。\n\n优缺点总结：\n\n * 优点： 简单，轻量，支持 Cron 表达式\n * 缺点 ：功能单一\n\n\n# 时间轮\n\nKafka、Dubbo、ZooKeeper、Netty 、Caffeine 、Akka 中都有对时间轮的实现。\n\n时间轮简单来说就是一个环形的队列（底层一般基于数组实现），队列中的每一个元素（时间格）都可以存放一个定时任务列表。\n\n时间轮中的每个时间格代表了时间轮的基本时间跨度或者说时间精度，加入时间一秒走一个时间格的话，那么这个时间轮的最高精度就是 1 秒（也就是说 3 s 和 3.9s 会在同一个时间格中）。\n\n下图是一个有 12 个时间格的时间轮，转完一圈需要 12 s。当我们需要新建一个 3s 后执行的定时任务，只需要将定时任务放在下标为 3 的时间格中即可。当我们需要新建一个 9s 后执行的定时任务，只需要将定时任务放在下标为 9 的时间格中即可。\n\n\n\n那当我们需要创建一个 13s 后执行的定时任务怎么办呢？这个时候可以引入一叫做 圈数/轮数 的概念，也就是说这个任务还是放在下标为 3 的时间格中， 不过它的圈数为 2 。\n\n除了增加圈数这种方法之外，还有一种 多层次时间轮 （类似手表），Kafka 采用的就是这种方案。\n\n针对下图的时间轮，我来举一个例子便于大家理解。\n\n\n\n上图的时间轮，第 1 层的时间精度为 1 ，第 2 层的时间精度为 20 ，第 3 层的时间精度为 400。假如我们需要添加一个 350s 后执行的任务 A 的话（当前时间是 0s），这个任务会被放在第 2 层（因为第二层的时间跨度为 20*20=400>350）的第 350/20=17 个时间格子。\n\n当第一层转了 17 圈之后，时间过去了 340s ，第 2 层的指针此时来到第 17 个时间格子。此时，第 2 层第 17 个格子的任务会被移动到第 1 层。\n\n任务 A 当前是 10s 之后执行，因此它会被移动到第 1 层的第 10 个时间格子。\n\n这里在层与层之间的移动也叫做时间轮的升降级。参考手表来理解就好！\n\n时间轮比较适合任务数量比较多的定时任务场景，它的任务写入和执行的时间复杂度都是 0（1）。\n\n\n# 分布式定时任务技术选型\n\n上面提到的一些定时任务的解决方案都是在单机下执行的，适用于比较简单的定时任务场景比如每天凌晨备份一次数据。\n\n如果我们需要一些高级特性比如支持任务在分布式场景下的分片和高可用的话，我们就需要用到分布式任务调度框架了。\n\n通常情况下，一个定时任务的执行往往涉及到下面这些角色：\n\n * 任务 ： 首先肯定是要执行的任务，这个任务就是具体的业务逻辑比如定时发送文章。\n * 调度器 ：其次是调度中心，调度中心主要负责任务管理，会分配任务给执行器。\n * 执行器 ： 最后就是执行器，执行器接收调度器分派的任务并执行。\n\n\n# Quartz\n\n一个很火的开源任务调度框架，完全由Java写成。Quartz 可以说是 Java 定时任务领域的老大哥或者说参考标准，其他的任务调度框架基本都是基于 Quartz 开发的，比如当当网的elastic-job就是基于quartz二次开发之后的分布式调度解决方案。\n\n使用 Quartz 可以很方便地与 Spring 集成，并且支持动态添加任务和集群。但是，Quartz 使用起来也比较麻烦，API 繁琐。\n\n并且，Quzrtz 并没有内置 UI 管理控制台，不过你可以使用 quartzui\n\n\n# Elastic-Job\n\nElastic-Job 是当当网开源的一个基于Quartz和ZooKeeper的分布式调度解决方案，由两个相互独立的子项目 Elastic-Job-Lite 和 Elastic-Job-Cloud 组成，一般我们只要使用 Elastic-Job-Lite 就好。\n\nElasticJob 支持任务在分布式场景下的分片和高可用、任务可视化管理等功能。\n\n\n\nElasticJob-Lite 的架构设计如下图所示：\n\n\n\n从上图可以看出，Elastic-Job 没有调度中心这一概念，而是使用 ZooKeeper 作为注册中心，注册中心负责协调分配任务到不同的节点上。\n\nElastic-Job 中的定时调度都是由执行器自行触发，这种设计也被称为去中心化设计（调度和处理都是执行器单独完成）。\n\n@Component\n@ElasticJobConf(name = "dayJob", cron = "0/10 * * * * ?", shardingTotalCount = 2,\n        shardingItemParameters = "0=AAAA,1=BBBB", description = "简单任务", failover = true)\npublic class TestJob implements SimpleJob {\n    @Override\n    public void execute(ShardingContext shardingContext) {\n        log.info("TestJob任务名：【{}】, 片数：【{}】, param=【{}】", shardingContext.getJobName(), shardingContext.getShardingTotalCount(),\n                shardingContext.getShardingParameter());\n    }\n}\n\n\n\n相关地址：\n\n * Github 地址：https://github.com/apache/shardingsphere-elasticjob。\n * 官方网站：https://shardingsphere.apache.org/elasticjob/index_zh.html 。\n\n优缺点总结：\n\n * 优点 ：可以与 Spring 集成、支持分布式、支持集群、性能不错\n * 缺点 ：依赖了额外的中间件比如 Zookeeper（复杂度增加，可靠性降低、维护成本变高）\n\n\n# XXL-JOB\n\nXXL-JOB 于 2015 年开源，是一款优秀的轻量级分布式任务调度框架，支持任务可视化管理、弹性扩容缩容、任务失败重试和告警、任务分片等功能，\n\n\n\n根据 XXL-JOB 官网介绍，其解决了很多 Quartz 的不足。\n\n\n\nXXL-JOB 的架构设计如下图所示：\n\n\n\n从上图可以看出，XXL-JOB 由 调度中心 和 执行器 两大部分组成。调度中心主要负责任务管理、执行器管理以及日志管理。执行器主要是接收调度信号并处理。另外，调度中心进行任务调度时，是通过自研 RPC 来实现的。\n\n不同于 Elastic-Job 的去中心化设计， XXL-JOB 的这种设计也被称为中心化设计（调度中心调度多个执行器执行任务）。\n\n和 Quzrtz 类似 XXL-JOB 也是基于数据库锁调度任务，存在性能瓶颈。不过，一般在任务量不是特别大的情况下，没有什么影响的，可以满足绝大部分公司的要求。\n\n不要被 XXL-JOB 的架构图给吓着了，实际上，我们要用 XXL-JOB 的话，只需要重写 IJobHandler 自定义任务执行逻辑就可以了，非常易用！\n\n@JobHandler(value="myApiJobHandler")\n@Component\npublic class MyApiJobHandler extends IJobHandler {\n\n    @Override\n    public ReturnT<String> execute(String param) throws Exception {\n        //......\n        return ReturnT.SUCCESS;\n    }\n}\n\n\n\n还可以直接基于注解定义任务。\n\n@XxlJob("myAnnotationJobHandler")\npublic ReturnT<String> myAnnotationJobHandler(String param) throws Exception {\n  //......\n  return ReturnT.SUCCESS;\n}\n\n\n\n相关地址：\n\n * Github 地址：https://github.com/xuxueli/xxl-job/。\n * 官方介绍：https://www.xuxueli.com/xxl-job/ 。\n\n优缺点总结：\n\n * 优点：开箱即用（学习成本比较低）、与 Spring 集成、支持分布式、支持集群、内置了 UI 管理控制台。\n * 缺点：不支持动态添加任务（如果一定想要动态创建任务也是支持的，参见：xxl-job issue277\n\n\n# PowerJob\n\n非常值得关注的一个分布式任务调度框架，分布式任务调度领域的新星。目前，已经有很多公司接入比如 OPPO、京东、中通、思科。\n\n这个框架的诞生也挺有意思的，PowerJob 的作者当时在阿里巴巴实习过，阿里巴巴那会使用的是内部自研的 SchedulerX（阿里云付费产品）。实习期满之后，PowerJob 的作者离开了阿里巴巴。想着说自研一个 SchedulerX，防止哪天 SchedulerX 满足不了需求，于是 PowerJob 就诞生了。\n\n更多关于 PowerJob 的故事，小伙伴们可以去看看 PowerJob 作者的视频 《我和我的任务调度中间件》\n\n\n# reference\n\n * Java定时任务大揭秘 | JavaGuide',normalizedContent:'# 为什么需要定时任务？\n\n我们来看一下几个非常常见的业务场景：\n\n 1. 某系统凌晨要进行数据备份。\n 2. 某电商平台，用户下单半个小时未支付的情况下需要自动取消订单。\n 3. 某媒体聚合平台，每 10 分钟动态抓取某某网站的数据为自己所用。\n 4. 某博客平台，支持定时发送文章。\n 5. 某基金平台，每晚定时计算用户当日收益情况并推送给用户最新的数据。\n 6. ......\n\n这些场景往往都要求我们在某个特定的时间去做某个事情。\n\n\n# 单机定时任务技术选型\n\n\n# timer\n\njava.util.timer是 jdk 1.3 开始就已经支持的一种定时任务的实现方式。\n\ntimer 内部使用一个叫做 taskqueue 的类存放定时任务，它是一个基于最小堆实现的优先级队列。taskqueue 会按照任务距离下一次执行时间的大小将任务排序，保证在堆顶的任务最先执行。这样在需要执行任务时，每次只需要取出堆顶的任务运行即可！\n\ntimer 使用起来比较简单，通过下面的方式我们就能创建一个 1s 之后执行的定时任务。\n\n// 示例代码：\ntimertask task = new timertask() {\n    public void run() {\n        system.out.println("当前时间: " + new date() + "n" +\n                "线程名称: " + thread.currentthread().getname());\n    }\n};\nsystem.out.println("当前时间: " + new date() + "n" +\n        "线程名称: " + thread.currentthread().getname());\ntimer timer = new timer("timer");\nlong delay = 1000l;\ntimer.schedule(task, delay);\n\n\n//输出：\n当前时间: fri may 28 15:18:47 cst 2021n线程名称: main\n当前时间: fri may 28 15:18:48 cst 2021n线程名称: timer\n\n\n\n不过其缺陷较多，比如一个 timer 一个线程，这就导致 timer 的任务的执行只能串行执行，一个任务执行时间过长的话会影响其他任务（性能非常差），再比如发生异常时任务直接停止（timer 只捕获了 interruptedexception ）。\n\n\n# scheduledexecutorservice\n\nscheduledexecutorservice 是一个接口，有多个实现类，比较常用的是 scheduledthreadpoolexecutor 。\n\n\n\nscheduledthreadpoolexecutor 本身就是一个线程池，支持任务并发执行。并且，其内部使用 delayqueue 作为任务队列。\n\n// 示例代码：\ntimertask repeatedtask = new timertask() {\n    @sneakythrows\n    public void run() {\n        system.out.println("当前时间: " + new date() + "n" +\n                "线程名称: " + thread.currentthread().getname());\n    }\n};\nsystem.out.println("当前时间: " + new date() + "n" +\n        "线程名称: " + thread.currentthread().getname());\nscheduledexecutorservice executor = executors.newscheduledthreadpool(3);\nlong delay  = 1000l;\nlong period = 1000l;\nexecutor.scheduleatfixedrate(repeatedtask, delay, period, timeunit.milliseconds);\nthread.sleep(delay + period * 5);\nexecutor.shutdown();\n//输出：\n当前时间: fri may 28 15:40:46 cst 2021n线程名称: main\n当前时间: fri may 28 15:40:47 cst 2021n线程名称: pool-1-thread-1\n当前时间: fri may 28 15:40:48 cst 2021n线程名称: pool-1-thread-1\n当前时间: fri may 28 15:40:49 cst 2021n线程名称: pool-1-thread-2\n当前时间: fri may 28 15:40:50 cst 2021n线程名称: pool-1-thread-2\n当前时间: fri may 28 15:40:51 cst 2021n线程名称: pool-1-thread-2\n当前时间: fri may 28 15:40:52 cst 2021n线程名称: pool-1-thread-2\n\n\n\n\n# spring task\n\n我们直接通过 spring 提供的 @scheduled 注解即可定义定时任务，非常方便！\n\n/**\n * cron：使用cron表达式。　每分钟的1，2秒运行\n */\n@scheduled(cron = "1-2 * * * * ? ")\npublic void reportcurrenttimewithcronexpression() {\n  log.info("cron expression: the time is now {}", dateformat.format(new date()));\n}\n\n\n\n\n并且，spring task 还是支持 cron 表达式 的。cron 表达式主要用于定时作业(定时任务)系统定义执行时间或执行频率的表达式，非常厉害，你可以通过 cron 表达式进行设置定时任务每天或者每个月什么时候执行等等操作。咱们要学习定时任务的话，cron 表达式是一定是要重点关注的。推荐一个在线 cron 表达式生成器：http://cron.qqe2.com/\n\nspring task 底层是基于 jdk 的 scheduledthreadpoolexecutor 线程池来实现的。\n\n优缺点总结：\n\n * 优点： 简单，轻量，支持 cron 表达式\n * 缺点 ：功能单一\n\n\n# 时间轮\n\nkafka、dubbo、zookeeper、netty 、caffeine 、akka 中都有对时间轮的实现。\n\n时间轮简单来说就是一个环形的队列（底层一般基于数组实现），队列中的每一个元素（时间格）都可以存放一个定时任务列表。\n\n时间轮中的每个时间格代表了时间轮的基本时间跨度或者说时间精度，加入时间一秒走一个时间格的话，那么这个时间轮的最高精度就是 1 秒（也就是说 3 s 和 3.9s 会在同一个时间格中）。\n\n下图是一个有 12 个时间格的时间轮，转完一圈需要 12 s。当我们需要新建一个 3s 后执行的定时任务，只需要将定时任务放在下标为 3 的时间格中即可。当我们需要新建一个 9s 后执行的定时任务，只需要将定时任务放在下标为 9 的时间格中即可。\n\n\n\n那当我们需要创建一个 13s 后执行的定时任务怎么办呢？这个时候可以引入一叫做 圈数/轮数 的概念，也就是说这个任务还是放在下标为 3 的时间格中， 不过它的圈数为 2 。\n\n除了增加圈数这种方法之外，还有一种 多层次时间轮 （类似手表），kafka 采用的就是这种方案。\n\n针对下图的时间轮，我来举一个例子便于大家理解。\n\n\n\n上图的时间轮，第 1 层的时间精度为 1 ，第 2 层的时间精度为 20 ，第 3 层的时间精度为 400。假如我们需要添加一个 350s 后执行的任务 a 的话（当前时间是 0s），这个任务会被放在第 2 层（因为第二层的时间跨度为 20*20=400>350）的第 350/20=17 个时间格子。\n\n当第一层转了 17 圈之后，时间过去了 340s ，第 2 层的指针此时来到第 17 个时间格子。此时，第 2 层第 17 个格子的任务会被移动到第 1 层。\n\n任务 a 当前是 10s 之后执行，因此它会被移动到第 1 层的第 10 个时间格子。\n\n这里在层与层之间的移动也叫做时间轮的升降级。参考手表来理解就好！\n\n时间轮比较适合任务数量比较多的定时任务场景，它的任务写入和执行的时间复杂度都是 0（1）。\n\n\n# 分布式定时任务技术选型\n\n上面提到的一些定时任务的解决方案都是在单机下执行的，适用于比较简单的定时任务场景比如每天凌晨备份一次数据。\n\n如果我们需要一些高级特性比如支持任务在分布式场景下的分片和高可用的话，我们就需要用到分布式任务调度框架了。\n\n通常情况下，一个定时任务的执行往往涉及到下面这些角色：\n\n * 任务 ： 首先肯定是要执行的任务，这个任务就是具体的业务逻辑比如定时发送文章。\n * 调度器 ：其次是调度中心，调度中心主要负责任务管理，会分配任务给执行器。\n * 执行器 ： 最后就是执行器，执行器接收调度器分派的任务并执行。\n\n\n# quartz\n\n一个很火的开源任务调度框架，完全由java写成。quartz 可以说是 java 定时任务领域的老大哥或者说参考标准，其他的任务调度框架基本都是基于 quartz 开发的，比如当当网的elastic-job就是基于quartz二次开发之后的分布式调度解决方案。\n\n使用 quartz 可以很方便地与 spring 集成，并且支持动态添加任务和集群。但是，quartz 使用起来也比较麻烦，api 繁琐。\n\n并且，quzrtz 并没有内置 ui 管理控制台，不过你可以使用 quartzui\n\n\n# elastic-job\n\nelastic-job 是当当网开源的一个基于quartz和zookeeper的分布式调度解决方案，由两个相互独立的子项目 elastic-job-lite 和 elastic-job-cloud 组成，一般我们只要使用 elastic-job-lite 就好。\n\nelasticjob 支持任务在分布式场景下的分片和高可用、任务可视化管理等功能。\n\n\n\nelasticjob-lite 的架构设计如下图所示：\n\n\n\n从上图可以看出，elastic-job 没有调度中心这一概念，而是使用 zookeeper 作为注册中心，注册中心负责协调分配任务到不同的节点上。\n\nelastic-job 中的定时调度都是由执行器自行触发，这种设计也被称为去中心化设计（调度和处理都是执行器单独完成）。\n\n@component\n@elasticjobconf(name = "dayjob", cron = "0/10 * * * * ?", shardingtotalcount = 2,\n        shardingitemparameters = "0=aaaa,1=bbbb", description = "简单任务", failover = true)\npublic class testjob implements simplejob {\n    @override\n    public void execute(shardingcontext shardingcontext) {\n        log.info("testjob任务名：【{}】, 片数：【{}】, param=【{}】", shardingcontext.getjobname(), shardingcontext.getshardingtotalcount(),\n                shardingcontext.getshardingparameter());\n    }\n}\n\n\n\n相关地址：\n\n * github 地址：https://github.com/apache/shardingsphere-elasticjob。\n * 官方网站：https://shardingsphere.apache.org/elasticjob/index_zh.html 。\n\n优缺点总结：\n\n * 优点 ：可以与 spring 集成、支持分布式、支持集群、性能不错\n * 缺点 ：依赖了额外的中间件比如 zookeeper（复杂度增加，可靠性降低、维护成本变高）\n\n\n# xxl-job\n\nxxl-job 于 2015 年开源，是一款优秀的轻量级分布式任务调度框架，支持任务可视化管理、弹性扩容缩容、任务失败重试和告警、任务分片等功能，\n\n\n\n根据 xxl-job 官网介绍，其解决了很多 quartz 的不足。\n\n\n\nxxl-job 的架构设计如下图所示：\n\n\n\n从上图可以看出，xxl-job 由 调度中心 和 执行器 两大部分组成。调度中心主要负责任务管理、执行器管理以及日志管理。执行器主要是接收调度信号并处理。另外，调度中心进行任务调度时，是通过自研 rpc 来实现的。\n\n不同于 elastic-job 的去中心化设计， xxl-job 的这种设计也被称为中心化设计（调度中心调度多个执行器执行任务）。\n\n和 quzrtz 类似 xxl-job 也是基于数据库锁调度任务，存在性能瓶颈。不过，一般在任务量不是特别大的情况下，没有什么影响的，可以满足绝大部分公司的要求。\n\n不要被 xxl-job 的架构图给吓着了，实际上，我们要用 xxl-job 的话，只需要重写 ijobhandler 自定义任务执行逻辑就可以了，非常易用！\n\n@jobhandler(value="myapijobhandler")\n@component\npublic class myapijobhandler extends ijobhandler {\n\n    @override\n    public returnt<string> execute(string param) throws exception {\n        //......\n        return returnt.success;\n    }\n}\n\n\n\n还可以直接基于注解定义任务。\n\n@xxljob("myannotationjobhandler")\npublic returnt<string> myannotationjobhandler(string param) throws exception {\n  //......\n  return returnt.success;\n}\n\n\n\n相关地址：\n\n * github 地址：https://github.com/xuxueli/xxl-job/。\n * 官方介绍：https://www.xuxueli.com/xxl-job/ 。\n\n优缺点总结：\n\n * 优点：开箱即用（学习成本比较低）、与 spring 集成、支持分布式、支持集群、内置了 ui 管理控制台。\n * 缺点：不支持动态添加任务（如果一定想要动态创建任务也是支持的，参见：xxl-job issue277\n\n\n# powerjob\n\n非常值得关注的一个分布式任务调度框架，分布式任务调度领域的新星。目前，已经有很多公司接入比如 oppo、京东、中通、思科。\n\n这个框架的诞生也挺有意思的，powerjob 的作者当时在阿里巴巴实习过，阿里巴巴那会使用的是内部自研的 schedulerx（阿里云付费产品）。实习期满之后，powerjob 的作者离开了阿里巴巴。想着说自研一个 schedulerx，防止哪天 schedulerx 满足不了需求，于是 powerjob 就诞生了。\n\n更多关于 powerjob 的故事，小伙伴们可以去看看 powerjob 作者的视频 《我和我的任务调度中间件》\n\n\n# reference\n\n * java定时任务大揭秘 | javaguide',charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"设计模式简介",frontmatter:{title:"设计模式简介",date:"2023-10-24T07:40:36.000Z",permalink:"/pages/56a50e/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/05.%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B.html",relativePath:"01.Java 知识体系/05.代码质量/01.设计模式/01.设计模式简介.md",key:"v-d015cfc2",path:"/pages/56a50e/",headers:[{level:1,title:"七大设计原则",slug:"七大设计原则",normalizedTitle:"七大设计原则",charIndex:50},{level:1,title:"设计模式分类",slug:"设计模式分类",normalizedTitle:"设计模式分类",charIndex:334}],headersStr:"七大设计原则 设计模式分类",content:"设计模式是程序员在面对同类软件工程设计问题所总结出来的有用经验，是某类问题的通用解决方案。\n\n\n# 七大设计原则\n\n设计模式常用的七大原则有：\n\n单一职责原则       一个类应该只负责一项职责\n接口隔离原则       一个类对另一个类的依赖应该建立在最小接口上\n依赖倒转（倒置）原则   高层模块不应该依赖底层模块，二者都应该依赖抽象。\n里氏替换原则       所有引用基类的地方必须能透明地使用其子类的对象\n开闭原则         一个软件实体如类、模块和函数应该对扩展（提供方）开放，对修改（使用方）关闭\n迪米特原则        一个类对自己依赖的类知道的越少越好\n合成复用原则       尽量使用合成/聚合，而不是通过继承达到复用的目的。\n\n\n# 设计模式分类\n\n设计模式分为三大类，总共有23种模式。具体分类：\n\n * 创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂方法模式。\n * 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。\n * 行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式（责任链模式）",normalizedContent:"设计模式是程序员在面对同类软件工程设计问题所总结出来的有用经验，是某类问题的通用解决方案。\n\n\n# 七大设计原则\n\n设计模式常用的七大原则有：\n\n单一职责原则       一个类应该只负责一项职责\n接口隔离原则       一个类对另一个类的依赖应该建立在最小接口上\n依赖倒转（倒置）原则   高层模块不应该依赖底层模块，二者都应该依赖抽象。\n里氏替换原则       所有引用基类的地方必须能透明地使用其子类的对象\n开闭原则         一个软件实体如类、模块和函数应该对扩展（提供方）开放，对修改（使用方）关闭\n迪米特原则        一个类对自己依赖的类知道的越少越好\n合成复用原则       尽量使用合成/聚合，而不是通过继承达到复用的目的。\n\n\n# 设计模式分类\n\n设计模式分为三大类，总共有23种模式。具体分类：\n\n * 创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂方法模式。\n * 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。\n * 行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式（责任链模式）",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"Nginx",frontmatter:{title:"Nginx",date:"2023-10-24T07:42:18.000Z",permalink:"/pages/dd97c6/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/04.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/05.Web%E6%9C%8D%E5%8A%A1%E5%99%A8/01.Nginx.html",relativePath:"01.Java 知识体系/04.系统设计/05.Web服务器/01.Nginx.md",key:"v-0173ec44",path:"/pages/dd97c6/",headers:[{level:1,title:"Nginx 简介",slug:"nginx-简介",normalizedTitle:"nginx 简介",charIndex:2},{level:2,title:"相关概念",slug:"相关概念",normalizedTitle:"相关概念",charIndex:95},{level:1,title:"Nginx 常用命令",slug:"nginx-常用命令",normalizedTitle:"nginx 常用命令",charIndex:393},{level:1,title:"Nginx 配置文件",slug:"nginx-配置文件",normalizedTitle:"nginx 配置文件",charIndex:730},{level:3,title:"全局块",slug:"全局块",normalizedTitle:"全局块",charIndex:803},{level:3,title:"event块",slug:"event块",normalizedTitle:"event块",charIndex:812},{level:3,title:"http块",slug:"http块",normalizedTitle:"http块",charIndex:824},{level:1,title:"Nginx应用场景",slug:"nginx应用场景",normalizedTitle:"nginx应用场景",charIndex:1454}],headersStr:"Nginx 简介 相关概念 Nginx 常用命令 Nginx 配置文件 全局块 event块 http块 Nginx应用场景",content:"# Nginx 简介\n\nNginx (engine x) 是一款轻量级的 Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。特点是占用内存少，并发能力强。\n\n\n# 相关概念\n\n * 正向代理：通过客户端（浏览器）配置代理服务器，通过代理服务器进行互联网访问。\n\n * 反向代理：客户端只需将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器P地址。\n\n * 负载均衡： 单个服务器解决不了，增加服务器数量，将原先集中请求到单个服务器改为将请求分发到各个服务器，将负载分发到各个服务器，这就是负载均衡。\n\n * 动静分离：为了加快解析速度，可以将动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。\n\n\n# Nginx 常用命令\n\nnginx -s stop 快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。 nginx -s quit 平稳关闭Nginx，保存相关信息，有安排的结束web服务。 nginx -s reload 因改变了Nginx相关配置，需要重新加载配置而重载。 nginx -s reopen 重新打开日志文件。 nginx -c filename 为 Nginx 指定一个配置文件，来代替缺省的。 nginx -t 不运行，仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。 nginx -v 显示 nginx 的版本。 nginx -V 显示 nginx 的版本，编译器版本和配置参数。\n\n\n# Nginx 配置文件\n\n默认位置：vim /usr/local/nginx/conf/nginx.conf\n\n配置文件组件包含三部分：\n\n 1. 全局块\n\n 2. event块\n\n 3. http块\n\n\n# 全局块\n\n全局块：配置服务器整体运行的配置指令。\n\n从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配 置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以 及配置文件的引入等。\n\n比如上面第一行配置的：这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是 会受到硬件、软件等设备的制约\n\n\n\n\n# event块\n\nevent块：影响 Nginx 服务器与用户的网络连接。\n\nevents 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 wordprocess 可以同时支持的最大连接数等。\n\n上述例子就表示每个 work process 支持的最大连接数为 1024.\n\n这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。\n\n\n\n\n# http块\n\n这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。\n\n需要注意的是：http 块也可以包括 http 全局块、server 块。\n\n\n\n\n# Nginx应用场景\n\n * Http反向代理\n\n * Https反向代理\n\n * 负载均衡\n\n * 网站多个webapp配置\n\n * 静态站点\n\n * 搭建文件服务器\n\n * 解决跨域",normalizedContent:"# nginx 简介\n\nnginx (engine x) 是一款轻量级的 web 服务器 、反向代理服务器及电子邮件（imap/pop3）代理服务器。特点是占用内存少，并发能力强。\n\n\n# 相关概念\n\n * 正向代理：通过客户端（浏览器）配置代理服务器，通过代理服务器进行互联网访问。\n\n * 反向代理：客户端只需将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器p地址。\n\n * 负载均衡： 单个服务器解决不了，增加服务器数量，将原先集中请求到单个服务器改为将请求分发到各个服务器，将负载分发到各个服务器，这就是负载均衡。\n\n * 动静分离：为了加快解析速度，可以将动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。\n\n\n# nginx 常用命令\n\nnginx -s stop 快速关闭nginx，可能不保存相关信息，并迅速终止web服务。 nginx -s quit 平稳关闭nginx，保存相关信息，有安排的结束web服务。 nginx -s reload 因改变了nginx相关配置，需要重新加载配置而重载。 nginx -s reopen 重新打开日志文件。 nginx -c filename 为 nginx 指定一个配置文件，来代替缺省的。 nginx -t 不运行，仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。 nginx -v 显示 nginx 的版本。 nginx -v 显示 nginx 的版本，编译器版本和配置参数。\n\n\n# nginx 配置文件\n\n默认位置：vim /usr/local/nginx/conf/nginx.conf\n\n配置文件组件包含三部分：\n\n 1. 全局块\n\n 2. event块\n\n 3. http块\n\n\n# 全局块\n\n全局块：配置服务器整体运行的配置指令。\n\n从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配 置运行 nginx 服务器的用户（组）、允许生成的 worker process 数，进程 pid 存放路径、日志存放路径和类型以 及配置文件的引入等。\n\n比如上面第一行配置的：这是 nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是 会受到硬件、软件等设备的制约\n\n\n\n\n# event块\n\nevent块：影响 nginx 服务器与用户的网络连接。\n\nevents 块涉及的指令主要影响 nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 wordprocess 可以同时支持的最大连接数等。\n\n上述例子就表示每个 work process 支持的最大连接数为 1024.\n\n这部分的配置对 nginx 的性能影响较大，在实际中应该灵活配置。\n\n\n\n\n# http块\n\n这算是 nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。\n\n需要注意的是：http 块也可以包括 http 全局块、server 块。\n\n\n\n\n# nginx应用场景\n\n * http反向代理\n\n * https反向代理\n\n * 负载均衡\n\n * 网站多个webapp配置\n\n * 静态站点\n\n * 搭建文件服务器\n\n * 解决跨域",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"责任链模式",frontmatter:{title:"责任链模式",date:"2023-10-24T07:40:36.000Z",permalink:"/pages/62b3c2/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/05.%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.html",relativePath:"01.Java 知识体系/05.代码质量/01.设计模式/02.责任链模式.md",key:"v-64b968d7",path:"/pages/62b3c2/",headers:[{level:1,title:"实际应用场景",slug:"实际应用场景",normalizedTitle:"实际应用场景",charIndex:238},{level:2,title:"1.定义处理器父类",slug:"_1-定义处理器父类",normalizedTitle:"1.定义处理器父类",charIndex:291},{level:2,title:"2.定义处理器子类",slug:"_2-定义处理器子类",normalizedTitle:"2.定义处理器子类",charIndex:421},{level:2,title:"3.定义退票流程引擎",slug:"_3-定义退票流程引擎",normalizedTitle:"3.定义退票流程引擎",charIndex:863},{level:2,title:"4.外部方法调用",slug:"_4-外部方法调用",normalizedTitle:"4.外部方法调用",charIndex:1486},{level:1,title:"reference",slug:"reference",normalizedTitle:"reference",charIndex:1829}],headersStr:"实际应用场景 1.定义处理器父类 2.定义处理器子类 3.定义退票流程引擎 4.外部方法调用 reference",content:"责任链模式是一种行为设计模式，允许你将请求沿着处理链发送，然后处理者都可对其进行处理，完成后可以再将其传递给下一个处理者。\n\n责任链模式特点：\n\n * 可以控制请求的处理的顺序\n * 单一职责原则，可以对发起操作和执行操作的类进行解耦\n * 开闭原则，可不用修改原有的业务代码，新增其他的处理类\n * 不能保证每个处理者者可以执行\n * 效率不是很好，调用时如果不注意会出现各种各样的问题\n\n责任链模式适用的场景：当必须按顺序执行多个处理者时，可以考虑使用责任链模式\n\n\n# 实际应用场景\n\n购买机票，退票需要一系列操作（获取数据、多种校验、数据入库、外部系统数据同步）。\n\n\n# 1.定义处理器父类\n\npublic abstract class RefundHandle {\n\t//context 退票上下文对象\n    public abstract void handle(RefundContext context);\n}\n\n\n\n# 2.定义处理器子类\n\nRefundSubOneHandle第一个子类处理器\n\n//@Component 将子类处理器交由Spirng容器管理\n@Component\npublic class RefundSubOneHandle extends RefundHandle {\n    \n    @Override\n    public void handle(RefundContext context) {\n        //第一个子类处理器 do someing\n    }\n}\n\n\nRefundSubTWOHandle第二个子类处理器\n\n@Component\npublic class RefundSubTWOHandle extends RefundHandle {\n    \n    @Override\n    public void handle(RefundContext context) {\n\t\t//第二个子类处理器 do someing\n    }\n}\n\n\n\n# 3.定义退票流程引擎\n\n@Component\npublic class RefundEngine {\n\n    @Resource\n    private RefundSubOneHandle refundSubOneHandle;\n    \n    @Resource\n    private RefundSubTWOHandle refundSubTwoHandle;\n    \n    public void invokeAll(RefundContext context) {\n         //顺序加载处理器\n        List<RefundHandle> refundHandleList = new ArrayList<>();\n        //添加第一个子类处理器\n        refundHandleList.add(refundSubOneHandle);\n        //添加第二个子类处理器\n        refundHandleList.add(refundSubTwoHandle);\n        \n         //执行退票处理器\n        for (RefundHandle refundHandle : refundHandleList) {\n            refundHandle.handle(context);\n        }\n    }\n}\n\n\n\n# 4.外部方法调用\n\npublic class RefundService {\n\t@Resource\n    private RefundEngine refundEngine; \n    \n    public void refund() {\n         //创建上下文对象并初始化数据\n        RefundContext context = new RefundContext();\n\n        //退票引擎执行流程\n        this.refundEngine.invokeAll(context);\n    }\n}\n\n\n\n后续扩展：如果要新增一个处理节点，只要新增一个子处理器类，在执行引擎invokeAll方法加载这个处理器，就可以完成扩展。\n\n\n# reference\n\n * 责任链模式 - Aj小菜 - 博客园\n\n * 设计模式在外卖营销业务中的实践- 美团技术团队",normalizedContent:"责任链模式是一种行为设计模式，允许你将请求沿着处理链发送，然后处理者都可对其进行处理，完成后可以再将其传递给下一个处理者。\n\n责任链模式特点：\n\n * 可以控制请求的处理的顺序\n * 单一职责原则，可以对发起操作和执行操作的类进行解耦\n * 开闭原则，可不用修改原有的业务代码，新增其他的处理类\n * 不能保证每个处理者者可以执行\n * 效率不是很好，调用时如果不注意会出现各种各样的问题\n\n责任链模式适用的场景：当必须按顺序执行多个处理者时，可以考虑使用责任链模式\n\n\n# 实际应用场景\n\n购买机票，退票需要一系列操作（获取数据、多种校验、数据入库、外部系统数据同步）。\n\n\n# 1.定义处理器父类\n\npublic abstract class refundhandle {\n\t//context 退票上下文对象\n    public abstract void handle(refundcontext context);\n}\n\n\n\n# 2.定义处理器子类\n\nrefundsubonehandle第一个子类处理器\n\n//@component 将子类处理器交由spirng容器管理\n@component\npublic class refundsubonehandle extends refundhandle {\n    \n    @override\n    public void handle(refundcontext context) {\n        //第一个子类处理器 do someing\n    }\n}\n\n\nrefundsubtwohandle第二个子类处理器\n\n@component\npublic class refundsubtwohandle extends refundhandle {\n    \n    @override\n    public void handle(refundcontext context) {\n\t\t//第二个子类处理器 do someing\n    }\n}\n\n\n\n# 3.定义退票流程引擎\n\n@component\npublic class refundengine {\n\n    @resource\n    private refundsubonehandle refundsubonehandle;\n    \n    @resource\n    private refundsubtwohandle refundsubtwohandle;\n    \n    public void invokeall(refundcontext context) {\n         //顺序加载处理器\n        list<refundhandle> refundhandlelist = new arraylist<>();\n        //添加第一个子类处理器\n        refundhandlelist.add(refundsubonehandle);\n        //添加第二个子类处理器\n        refundhandlelist.add(refundsubtwohandle);\n        \n         //执行退票处理器\n        for (refundhandle refundhandle : refundhandlelist) {\n            refundhandle.handle(context);\n        }\n    }\n}\n\n\n\n# 4.外部方法调用\n\npublic class refundservice {\n\t@resource\n    private refundengine refundengine; \n    \n    public void refund() {\n         //创建上下文对象并初始化数据\n        refundcontext context = new refundcontext();\n\n        //退票引擎执行流程\n        this.refundengine.invokeall(context);\n    }\n}\n\n\n\n后续扩展：如果要新增一个处理节点，只要新增一个子处理器类，在执行引擎invokeall方法加载这个处理器，就可以完成扩展。\n\n\n# reference\n\n * 责任链模式 - aj小菜 - 博客园\n\n * 设计模式在外卖营销业务中的实践- 美团技术团队",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"模版方法模式",frontmatter:{title:"模版方法模式",date:"2023-10-24T07:40:36.000Z",permalink:"/pages/a2e658/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/05.%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03.%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html",relativePath:"01.Java 知识体系/05.代码质量/01.设计模式/03.模版方法模式.md",key:"v-7cc9a2b6",path:"/pages/a2e658/",headers:[{level:1,title:"实际应用场景",slug:"实际应用场景",normalizedTitle:"实际应用场景",charIndex:315},{level:2,title:"1.定义抽象模板",slug:"_1-定义抽象模板",normalizedTitle:"1.定义抽象模板",charIndex:428},{level:2,title:"2.定义具体模板",slug:"_2-定义具体模板",normalizedTitle:"2.定义具体模板",charIndex:2416},{level:2,title:"3.应用类（使用工厂模式获取对应子类）",slug:"_3-应用类-使用工厂模式获取对应子类",normalizedTitle:"3.应用类（使用工厂模式获取对应子类）",charIndex:3464},{level:1,title:"reference",slug:"reference",normalizedTitle:"reference",charIndex:4262}],headersStr:"实际应用场景 1.定义抽象模板 2.定义具体模板 3.应用类（使用工厂模式获取对应子类） reference",content:'模版方法模式定义：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n模版方法模式使用了Java的继承机制，有两类角色：抽象模版（抽象父类）和具体模版（实现子类）\n\n抽象模版中有两类方法：\n\n * 基本方法：基本方法也叫做基本操作，是由子类实现的方法，并且在模板方法被调用。抽象模板中的基本方法尽量设计为protected类型。\n * 模板方法：可以有一个或几个，一般是一个具体方法，也就是一个框架，实现对基本方法的调度，完成固定的逻辑。一般模板方法都加上final关键字，不允许被覆写。\n\n具体模版主要对父类定义的一个或多个抽象方法进行个性化实现。\n\n\n# 实际应用场景\n\n场景：退票需要生成退款单，生成退款单需要经过构建退款单基本信息、构建退款单税费信息、构建退款单明细信息、退款单数据入库。其中构建退款单税费信息、构建退款单明细信息这两步，国内退票和国际退票处理不一样。\n\n\n# 1.定义抽象模板\n\n/**\n * 退票模板父类\n *\n */\npublic abstract class AbstractOrderRefundTemplate {\n\n    private IOrderRefundWarehousingService orderRefundWarehousingService;\n\n    /**\n     * 生成退款单\n     *\n     * @param dto\n     * @param context\n     * @return\n     */\n    public final String createOrderRefund(RefundCreateRequestDTO dto, OrderRefundContext context) {\n\n        //构建退款单基础信息\n        OrderRefundInfo orderRefundInfo = OrderRefundInfoBuilder.buildOrderRefundInfo(dto);\n        //构建税费信息\n        List<OrderTaxInfo> orderRefundTaxInfoList = OrderRefundInfoBuilder.buildOrderRefundTaxInfo(context);\n        //构建退款明细\n        List<OrderRefundDetailInfo> orderRefundDetailInfoList = this.buildOrderRefundDetailInfo(context, orderRefundInfo, orderRefundTaxInfoList);\n        //退款单数据入库(抽象类获取Spring Bean，从ApplicationContext获取)\n        this.orderRefundWarehousingService = (OrderRefundWarehousingServiceImpl) SpringContextUtils.getBean(OrderRefundWarehousingServiceImpl.BEAN_NAME);\n        return this.orderRefundWarehousingService.orderRefundWarehousing(context, orderRefundInfo, orderRefundTaxInfoList, orderRefundDetailInfoList);\n    }\n\n    /**\n     * 构建退款明细信息\n     *\n     * @param context                退票上下文\n     * @param orderRefundInfo        构建的退款单信息\n     * @param orderRefundTaxInfoList 构建的退款税费信息\n     * @return\n     */\n    protected abstract List<OrderRefundDetailInfo> buildOrderRefundDetailInfo(OrderRefundContext context, OrderRefundInfo orderRefundInfo, List<OrderTaxInfo> orderRefundTaxInfoList);\n}\n\n\n\n获取Spring上下文对象工具类。\n\n@Component\npublic class SpringContextUtils {\n\n    private static ApplicationContext context;\n\n    @Autowired\n    public SpringContextUtils(ApplicationContext applicationContext) {\n        setContext(applicationContext);\n    }\n\n    public static void setContext(ApplicationContext applicationContext) {\n        SpringContextUtils.context = applicationContext;\n    }\n\n    public static Object getBean(String clazz) {\n        return context.getBean(clazz);\n    }\n\n}\n\n\n\n# 2.定义具体模板\n\n国内退票模板\n\n/**\n * 国内退票模板\n */\n@Component(BEAN_NAME)\npublic class DomesticOrderRefundTemplate extends AbstractOrderRefundTemplate {\n    public static final String BEAN_NAME = "domesticOrderRefundTemplate";\n\n    @Override\n    protected List<OrderRefundDetailInfo> buildOrderRefundDetailInfo(OrderRefundContext context, OrderRefundInfo orderRefundInfo, List<OrderTaxInfo> orderRefundTaxInfoList) {\n        return OrderRefundInfoBuilder.buildOrderRefundDetailInfo(context, orderRefundInfo, orderRefundTaxInfoList);\n    }\n}\n\n\n\n国际退票模板\n\n/**\n * 国际退票模板\n */\n@Component(BEAN_NAME)\npublic class IntelOrderRefundTemplate extends AbstractOrderRefundTemplate {\n    public static final String BEAN_NAME = "intelOrderRefundTemplate";\n\n    @Override\n    protected List<OrderRefundDetailInfo> buildOrderRefundDetailInfo(OrderRefundContext context, OrderRefundInfo orderRefundInfo, List<OrderTaxInfo> orderRefundTaxInfoList) {\n        return OrderRefundInfoBuilder.buildIntelOrderRefundDetailInfo(context, orderRefundInfo, orderRefundTaxInfoList);\n    }\n}\n\n\n\n\n# 3.应用类（使用工厂模式获取对应子类）\n\npublic class OrderRefundServiceImpl implements IOrderRefundService {\n    private static Map<String, String> orderRefundTemplateBeanMap = new HashMap<>();\n\n    static {\n        orderRefundTemplateBeanMap.put(DomesticOrIntelEnum.DOMESTIC.getValue(), DomesticOrderRefundTemplate.BEAN_NAME);\n        orderRefundTemplateBeanMap.put(DomesticOrIntelEnum.INTEL.getValue(), IntelOrderRefundTemplate.BEAN_NAME);\n    }\n    \n    @Override\n    public OrderRefundCreateDTO createOrderRefund(RefundCreateRequestDTO request) {\n        //生成退款单\n        AbstractOrderRefundTemplate orderRefundTemplate = (AbstractOrderRefundTemplate)SpringContextUtils.getBean(orderRefundTemplateBeanMap.get(domesticOrIntel.getValue()));   \n\t\torderRefundTemplate.createOrderRefund(request, context);\n    }\n}\n\n\n\n# reference\n\n * 《设计模式之禅》\n * 21 | 代码重复：搞定代码重复的三个绝招',normalizedContent:'模版方法模式定义：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n模版方法模式使用了java的继承机制，有两类角色：抽象模版（抽象父类）和具体模版（实现子类）\n\n抽象模版中有两类方法：\n\n * 基本方法：基本方法也叫做基本操作，是由子类实现的方法，并且在模板方法被调用。抽象模板中的基本方法尽量设计为protected类型。\n * 模板方法：可以有一个或几个，一般是一个具体方法，也就是一个框架，实现对基本方法的调度，完成固定的逻辑。一般模板方法都加上final关键字，不允许被覆写。\n\n具体模版主要对父类定义的一个或多个抽象方法进行个性化实现。\n\n\n# 实际应用场景\n\n场景：退票需要生成退款单，生成退款单需要经过构建退款单基本信息、构建退款单税费信息、构建退款单明细信息、退款单数据入库。其中构建退款单税费信息、构建退款单明细信息这两步，国内退票和国际退票处理不一样。\n\n\n# 1.定义抽象模板\n\n/**\n * 退票模板父类\n *\n */\npublic abstract class abstractorderrefundtemplate {\n\n    private iorderrefundwarehousingservice orderrefundwarehousingservice;\n\n    /**\n     * 生成退款单\n     *\n     * @param dto\n     * @param context\n     * @return\n     */\n    public final string createorderrefund(refundcreaterequestdto dto, orderrefundcontext context) {\n\n        //构建退款单基础信息\n        orderrefundinfo orderrefundinfo = orderrefundinfobuilder.buildorderrefundinfo(dto);\n        //构建税费信息\n        list<ordertaxinfo> orderrefundtaxinfolist = orderrefundinfobuilder.buildorderrefundtaxinfo(context);\n        //构建退款明细\n        list<orderrefunddetailinfo> orderrefunddetailinfolist = this.buildorderrefunddetailinfo(context, orderrefundinfo, orderrefundtaxinfolist);\n        //退款单数据入库(抽象类获取spring bean，从applicationcontext获取)\n        this.orderrefundwarehousingservice = (orderrefundwarehousingserviceimpl) springcontextutils.getbean(orderrefundwarehousingserviceimpl.bean_name);\n        return this.orderrefundwarehousingservice.orderrefundwarehousing(context, orderrefundinfo, orderrefundtaxinfolist, orderrefunddetailinfolist);\n    }\n\n    /**\n     * 构建退款明细信息\n     *\n     * @param context                退票上下文\n     * @param orderrefundinfo        构建的退款单信息\n     * @param orderrefundtaxinfolist 构建的退款税费信息\n     * @return\n     */\n    protected abstract list<orderrefunddetailinfo> buildorderrefunddetailinfo(orderrefundcontext context, orderrefundinfo orderrefundinfo, list<ordertaxinfo> orderrefundtaxinfolist);\n}\n\n\n\n获取spring上下文对象工具类。\n\n@component\npublic class springcontextutils {\n\n    private static applicationcontext context;\n\n    @autowired\n    public springcontextutils(applicationcontext applicationcontext) {\n        setcontext(applicationcontext);\n    }\n\n    public static void setcontext(applicationcontext applicationcontext) {\n        springcontextutils.context = applicationcontext;\n    }\n\n    public static object getbean(string clazz) {\n        return context.getbean(clazz);\n    }\n\n}\n\n\n\n# 2.定义具体模板\n\n国内退票模板\n\n/**\n * 国内退票模板\n */\n@component(bean_name)\npublic class domesticorderrefundtemplate extends abstractorderrefundtemplate {\n    public static final string bean_name = "domesticorderrefundtemplate";\n\n    @override\n    protected list<orderrefunddetailinfo> buildorderrefunddetailinfo(orderrefundcontext context, orderrefundinfo orderrefundinfo, list<ordertaxinfo> orderrefundtaxinfolist) {\n        return orderrefundinfobuilder.buildorderrefunddetailinfo(context, orderrefundinfo, orderrefundtaxinfolist);\n    }\n}\n\n\n\n国际退票模板\n\n/**\n * 国际退票模板\n */\n@component(bean_name)\npublic class intelorderrefundtemplate extends abstractorderrefundtemplate {\n    public static final string bean_name = "intelorderrefundtemplate";\n\n    @override\n    protected list<orderrefunddetailinfo> buildorderrefunddetailinfo(orderrefundcontext context, orderrefundinfo orderrefundinfo, list<ordertaxinfo> orderrefundtaxinfolist) {\n        return orderrefundinfobuilder.buildintelorderrefunddetailinfo(context, orderrefundinfo, orderrefundtaxinfolist);\n    }\n}\n\n\n\n\n# 3.应用类（使用工厂模式获取对应子类）\n\npublic class orderrefundserviceimpl implements iorderrefundservice {\n    private static map<string, string> orderrefundtemplatebeanmap = new hashmap<>();\n\n    static {\n        orderrefundtemplatebeanmap.put(domesticorintelenum.domestic.getvalue(), domesticorderrefundtemplate.bean_name);\n        orderrefundtemplatebeanmap.put(domesticorintelenum.intel.getvalue(), intelorderrefundtemplate.bean_name);\n    }\n    \n    @override\n    public orderrefundcreatedto createorderrefund(refundcreaterequestdto request) {\n        //生成退款单\n        abstractorderrefundtemplate orderrefundtemplate = (abstractorderrefundtemplate)springcontextutils.getbean(orderrefundtemplatebeanmap.get(domesticorintel.getvalue()));   \n\t\torderrefundtemplate.createorderrefund(request, context);\n    }\n}\n\n\n\n# reference\n\n * 《设计模式之禅》\n * 21 | 代码重复：搞定代码重复的三个绝招',charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"代码优化",frontmatter:{title:"代码优化",date:"2023-10-24T07:41:51.000Z",permalink:"/pages/6281f2/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/05.%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/03.%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96.html",relativePath:"01.Java 知识体系/05.代码质量/03.代码优化.md",key:"v-39d6b1f3",path:"/pages/6281f2/",headers:[{level:1,title:"1.命名规范",slug:"_1-命名规范",normalizedTitle:"1.命名规范",charIndex:2},{level:1,title:"2.添加必要的注释",slug:"_2-添加必要的注释",normalizedTitle:"2.添加必要的注释",charIndex:174},{level:1,title:"3.日志打印规范",slug:"_3-日志打印规范",normalizedTitle:"3.日志打印规范",charIndex:385},{level:1,title:"4.参数校验",slug:"_4-参数校验",normalizedTitle:"4.参数校验",charIndex:671},{level:1,title:"5.判空处理",slug:"_5-判空处理",normalizedTitle:"5.判空处理",charIndex:877},{level:1,title:"6.异常规范处理",slug:"_6-异常规范处理",normalizedTitle:"6.异常规范处理",charIndex:1137},{level:1,title:"7.单元测试规范",slug:"_7-单元测试规范",normalizedTitle:"7.单元测试规范",charIndex:1690},{level:1,title:"8.代码格式规范",slug:"_8-代码格式规范",normalizedTitle:"8.代码格式规范",charIndex:1904},{level:1,title:"9.模块化，可扩展性",slug:"_9-模块化-可扩展性",normalizedTitle:"9.模块化，可扩展性",charIndex:2046},{level:1,title:"10.程序逻辑清晰，主次分明",slug:"_10-程序逻辑清晰-主次分明",normalizedTitle:"10.程序逻辑清晰，主次分明",charIndex:2117},{level:1,title:"11.安全规范",slug:"_11-安全规范",normalizedTitle:"11.安全规范",charIndex:2265},{level:1,title:"12.事务控制规范",slug:"_12-事务控制规范",normalizedTitle:"12.事务控制规范",charIndex:2763},{level:1,title:"13.重复代码处理",slug:"_13-重复代码处理",normalizedTitle:"13.重复代码处理",charIndex:3009},{level:1,title:"14.操作数据库、缓存、中间件、外部接口的代码单独抽取一个类",slug:"_14-操作数据库、缓存、中间件、外部接口的代码单独抽取一个类",normalizedTitle:"14.操作数据库、缓存、中间件、外部接口的代码单独抽取一个类",charIndex:3070},{level:1,title:"15.使用String.format进行字符串格式化",slug:"_15-使用string-format进行字符串格式化",normalizedTitle:"15.使用string.format进行字符串格式化",charIndex:3105},{level:1,title:"16.避免“炫技式”的单行代码",slug:"_16-避免-炫技式-的单行代码",normalizedTitle:"16.避免“炫技式”的单行代码",charIndex:3195},{level:1,title:"reference",slug:"reference",normalizedTitle:"reference",charIndex:3280}],headersStr:"1.命名规范 2.添加必要的注释 3.日志打印规范 4.参数校验 5.判空处理 6.异常规范处理 7.单元测试规范 8.代码格式规范 9.模块化，可扩展性 10.程序逻辑清晰，主次分明 11.安全规范 12.事务控制规范 13.重复代码处理 14.操作数据库、缓存、中间件、外部接口的代码单独抽取一个类 15.使用String.format进行字符串格式化 16.避免“炫技式”的单行代码 reference",content:"# 1.命名规范\n\nJava代码的命名应该清晰、简洁和易于理解。我们代码评审的时候，要注意是否有命名不规范，不清晰的代码。下面是一些命名规范的建议：\n\n * 类和接口应该使用首字母大写的驼峰命名法\n * 方法和变量应该使用小写的驼峰命名法\n * 常量应该使用全大写字母和下划线\n * 开发者是不是选择易于理解的名称给变量、类和方法进行命名\n\n\n# 2.添加必要的注释\n\n * 所有的类都必须添加创建者和创建日期，以及简单的注释描述\n * 方法内部的复杂业务逻辑或者算法，需要添加清楚的注释\n * 一般情况下，注释描述类、方法、变量的作用\n * 任何需要提醒的警告或TODO，也要注释清楚\n * 如果是注释一行代码的，就用//;如果注释代码块或者接口方法的，有多行/* **/\n * 一块代码逻辑如果你站在一个陌生人的角度去看,第一遍看不懂的话,就需要添加注释了\n\n\n# 3.日志打印规范\n\n这些日志规范没遵守，就需要修改：\n\n * 日志级别选择不对。常见的日志级别有error、warn、info、debug四种，不要反手就是info哈\n * 日志没打印出调用方法的入参和响应结果，尤其是跨系统调用的时候。\n * 业务日志没包含关键参数,如userId,bizSeq等等,不方便问题排查\n * 如果日志包含关键信息，比如手机号、身份证等，需要脱敏处理\n * 一些不符合预期的情况，如一些未知异常（数据库的数据异常等），又或者不符合业务预期的特殊场景，都需要打印相关的日志\n\n对于日志打印规范，可以参考 工作总结！日志打印的15个建议\n\n\n# 4.参数校验\n\n我们代码评审的时候，要注意参数是否都做了校验，如userId非空检查、金额范围检查、userName长度校验等等。一般我们在处理业务逻辑的时候，要遵循先检查、后处理的原则。\n\n> 如果你的数据库字段userName设置为varchar(16),对方传了一个32位的字符串过来，你不校验参数，插入数据库直接异常了。\n\n很多bug都是因为没做参数校验造成的，这一军规，是代码评审重点关注的哈\n\n\n# 5.判空处理\n\n * 获取对象的属性时，都要判空处理。要不然很多时候会出现空指针异常。\n\n\nif(object!=null){\n   String name = object.getName();\n}\n\n\n如果你要遍历列表，也需要判空\n\n\n  if (CollectionUtils.isNotEmpty(tianLuolist)) {\n        for (TianLuo temp : tianLuolist) {\n            //do something\n        }\n    }\n\n\n\n# 6.异常规范处理\n\n良好的异常处理可以确保代码的可靠性和可维护性。因此，异常处理也是代码评审的一项重要规范。以下是一些异常处理的建议：\n\n * 不要捕获通用的Exception异常，而应该尽可能捕获特定的异常\n * 在捕获异常时，应该记录异常信息以便于调试\n * 内部异常要确认最终的处理方式，避免未知异常当作失败处理。\n * 在finally块中释放资源，或者使用try-with-resource\n * 不要使用e.printStackTrace(),而是使用log打印。\n * catch了异常，要打印出具体的exception，否则无法更好定位问题\n * 捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类\n * 捕获到的异常，不能忽略它，要打印相对应的日志\n * 注意异常对你的代码层次结构的侵染（早发现早处理）\n * 自定义封装异常，不要丢弃原始异常的信息Throwable cause\n * 注意异常匹配的顺序，优先捕获具体的异常\n * 对外提供APi时，要提供对应的错误码\n * 系统内部应该抛出有业务含义的自定义异常，而不是直接抛出RuntimeException，或者直接抛出Exception\\Throwable。\n\n异常处理可以参考 Java 异常处理的十个建议\n\n\n# 7.单元测试规范\n\n * 测试类的命名,一般以测试的类+Test,如:CalculatorTest.\n * 测试方法的命名,一般以test开头+ 测试的方法,如testAdd.\n * 单测行覆盖率一般要求大于75%.\n * 单测一般要求包含主流程用例、参数边界值等校验用例\n * 单测一般也要求包含中间件访问超时、返回空、等异常的用例,比如访问数据库或者Redis异常.\n * 单测用例要求包含并发、防重、幂等等用例.\n\n\n# 8.代码格式规范\n\n良好的代码格式，可以使代码更容易阅读和理解。下面是一些常见的代码格式化建议：\n\n * 缩进使用四个空格\n * 代码块使用花括号分隔\n * 每行不超过80个字符\n * 每个方法应该按照特定的顺序排列，例如：类变量、实例变量、构造函数、公共方法、私有方法等。\n\n\n# 9.模块化，可扩展性\n\n代码编写设计是否满足模块化，接口是否具有可扩展性\n\n可以使用设计模式（策略模式、模板方法模式）提高可扩展性。\n\n\n# 10.程序逻辑清晰，主次分明\n\n代码评审的时候，要关注程序逻辑是否清晰。比如，你的一个注册接口，有参数校验、判断用户是否已经注册、插入用户记录、发送注册成功通知等功能。如果你把所有所有功能代码塞到一个方法里面，程序逻辑就不清晰，主次不够分明。\n\n可以将参数校验的代码单独抽取到一个方法。\n\n\n# 11.安全规范\n\n代码评审，也非常有必要评审代码是否存在安全性问题。比如：\n\n * 输入校验：应该始终对任何来自外部的输入数据进行校验，以确保它们符合预期并且不会对系统造成伤害。校验应该包括检查数据的类型、大小和格式。\n * 防范SQL注入攻击:在使用SQL查询时，应该始终使用参数化查询或预处理语句，以防止SQL注入攻击。\n * 防范跨站脚本攻击（XSS）: 在Web应用程序中，应该始终对输入的HTML、JavaScript和CSS进行校验，并转义特殊字符，以防止XSS攻击。\n * 避免敏感信息泄露: 敏感信息（如密码、密钥、会话ID等）应该在传输和存储时进行加密，以防止被未经授权的人访问。同时，应该避免在日志、调试信息或错误消息中泄露敏感信息。\n * 防范跨站请求伪造（CSRF）: 应该为所有敏感操作（如更改密码、删除数据等）添加CSRF令牌，以防止未经授权的人员执行这些操作。\n * 防范安全漏洞: 应该使用安全性高的算法和协议（如HTTPS、TLS）来保护敏感数据的传输和存储，并定期对系统进行漏洞扫描和安全性审计\n\n保证数据安全的方案参考 保证接口数据安全的10种方案\n\n\n# 12.事务控制规范\n\n * 一般推荐使用编程式事务，而不是一个注解 @Transactional的声明式事务。因为 @Transactional有很多场景，可能导致事务不生效。\n * 事务范围要明确，数据库操作必须在事务作用范围内，如果是非数据库操作，尽量不要包含在事务内。\n * 不要在事务内进行远程调用（可能导致数据不一致，比如本地成功了，但是远程方法失败了，这时候需要用分布式事务解决方案）\n * 事务中避免处理太多数据，一些查询相关的操作，尽量放到事务之外（避免大事务问题）\n\n\n# 13.重复代码处理\n\n大量重复代码（抽公用方法，设计模式）\n\n具体可以参考：优化重复冗余代码的8种方式 - 掘金\n\n\n# 14.操作数据库、缓存、中间件、外部接口的代码单独抽取一个类\n\n\n# 15.使用String.format进行字符串格式化\n\n字符串格式化使用String.format()。用法参考：string.format()详解 - 双间 - 博客园\n\n\n# 16.避免“炫技式”的单行代码\n\n“炫技式”的单行代码难以理解、排查和修改起来都麻烦且耗时。\n\n一个较重的代码坏味：“炫技式”的单行代码 - 琴水玉 - 博客园\n\n\n# reference\n\n * 代码评审的18个军规，收藏好！ - 掘金",normalizedContent:"# 1.命名规范\n\njava代码的命名应该清晰、简洁和易于理解。我们代码评审的时候，要注意是否有命名不规范，不清晰的代码。下面是一些命名规范的建议：\n\n * 类和接口应该使用首字母大写的驼峰命名法\n * 方法和变量应该使用小写的驼峰命名法\n * 常量应该使用全大写字母和下划线\n * 开发者是不是选择易于理解的名称给变量、类和方法进行命名\n\n\n# 2.添加必要的注释\n\n * 所有的类都必须添加创建者和创建日期，以及简单的注释描述\n * 方法内部的复杂业务逻辑或者算法，需要添加清楚的注释\n * 一般情况下，注释描述类、方法、变量的作用\n * 任何需要提醒的警告或todo，也要注释清楚\n * 如果是注释一行代码的，就用//;如果注释代码块或者接口方法的，有多行/* **/\n * 一块代码逻辑如果你站在一个陌生人的角度去看,第一遍看不懂的话,就需要添加注释了\n\n\n# 3.日志打印规范\n\n这些日志规范没遵守，就需要修改：\n\n * 日志级别选择不对。常见的日志级别有error、warn、info、debug四种，不要反手就是info哈\n * 日志没打印出调用方法的入参和响应结果，尤其是跨系统调用的时候。\n * 业务日志没包含关键参数,如userid,bizseq等等,不方便问题排查\n * 如果日志包含关键信息，比如手机号、身份证等，需要脱敏处理\n * 一些不符合预期的情况，如一些未知异常（数据库的数据异常等），又或者不符合业务预期的特殊场景，都需要打印相关的日志\n\n对于日志打印规范，可以参考 工作总结！日志打印的15个建议\n\n\n# 4.参数校验\n\n我们代码评审的时候，要注意参数是否都做了校验，如userid非空检查、金额范围检查、username长度校验等等。一般我们在处理业务逻辑的时候，要遵循先检查、后处理的原则。\n\n> 如果你的数据库字段username设置为varchar(16),对方传了一个32位的字符串过来，你不校验参数，插入数据库直接异常了。\n\n很多bug都是因为没做参数校验造成的，这一军规，是代码评审重点关注的哈\n\n\n# 5.判空处理\n\n * 获取对象的属性时，都要判空处理。要不然很多时候会出现空指针异常。\n\n\nif(object!=null){\n   string name = object.getname();\n}\n\n\n如果你要遍历列表，也需要判空\n\n\n  if (collectionutils.isnotempty(tianluolist)) {\n        for (tianluo temp : tianluolist) {\n            //do something\n        }\n    }\n\n\n\n# 6.异常规范处理\n\n良好的异常处理可以确保代码的可靠性和可维护性。因此，异常处理也是代码评审的一项重要规范。以下是一些异常处理的建议：\n\n * 不要捕获通用的exception异常，而应该尽可能捕获特定的异常\n * 在捕获异常时，应该记录异常信息以便于调试\n * 内部异常要确认最终的处理方式，避免未知异常当作失败处理。\n * 在finally块中释放资源，或者使用try-with-resource\n * 不要使用e.printstacktrace(),而是使用log打印。\n * catch了异常，要打印出具体的exception，否则无法更好定位问题\n * 捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类\n * 捕获到的异常，不能忽略它，要打印相对应的日志\n * 注意异常对你的代码层次结构的侵染（早发现早处理）\n * 自定义封装异常，不要丢弃原始异常的信息throwable cause\n * 注意异常匹配的顺序，优先捕获具体的异常\n * 对外提供api时，要提供对应的错误码\n * 系统内部应该抛出有业务含义的自定义异常，而不是直接抛出runtimeexception，或者直接抛出exception\\throwable。\n\n异常处理可以参考 java 异常处理的十个建议\n\n\n# 7.单元测试规范\n\n * 测试类的命名,一般以测试的类+test,如:calculatortest.\n * 测试方法的命名,一般以test开头+ 测试的方法,如testadd.\n * 单测行覆盖率一般要求大于75%.\n * 单测一般要求包含主流程用例、参数边界值等校验用例\n * 单测一般也要求包含中间件访问超时、返回空、等异常的用例,比如访问数据库或者redis异常.\n * 单测用例要求包含并发、防重、幂等等用例.\n\n\n# 8.代码格式规范\n\n良好的代码格式，可以使代码更容易阅读和理解。下面是一些常见的代码格式化建议：\n\n * 缩进使用四个空格\n * 代码块使用花括号分隔\n * 每行不超过80个字符\n * 每个方法应该按照特定的顺序排列，例如：类变量、实例变量、构造函数、公共方法、私有方法等。\n\n\n# 9.模块化，可扩展性\n\n代码编写设计是否满足模块化，接口是否具有可扩展性\n\n可以使用设计模式（策略模式、模板方法模式）提高可扩展性。\n\n\n# 10.程序逻辑清晰，主次分明\n\n代码评审的时候，要关注程序逻辑是否清晰。比如，你的一个注册接口，有参数校验、判断用户是否已经注册、插入用户记录、发送注册成功通知等功能。如果你把所有所有功能代码塞到一个方法里面，程序逻辑就不清晰，主次不够分明。\n\n可以将参数校验的代码单独抽取到一个方法。\n\n\n# 11.安全规范\n\n代码评审，也非常有必要评审代码是否存在安全性问题。比如：\n\n * 输入校验：应该始终对任何来自外部的输入数据进行校验，以确保它们符合预期并且不会对系统造成伤害。校验应该包括检查数据的类型、大小和格式。\n * 防范sql注入攻击:在使用sql查询时，应该始终使用参数化查询或预处理语句，以防止sql注入攻击。\n * 防范跨站脚本攻击（xss）: 在web应用程序中，应该始终对输入的html、javascript和css进行校验，并转义特殊字符，以防止xss攻击。\n * 避免敏感信息泄露: 敏感信息（如密码、密钥、会话id等）应该在传输和存储时进行加密，以防止被未经授权的人访问。同时，应该避免在日志、调试信息或错误消息中泄露敏感信息。\n * 防范跨站请求伪造（csrf）: 应该为所有敏感操作（如更改密码、删除数据等）添加csrf令牌，以防止未经授权的人员执行这些操作。\n * 防范安全漏洞: 应该使用安全性高的算法和协议（如https、tls）来保护敏感数据的传输和存储，并定期对系统进行漏洞扫描和安全性审计\n\n保证数据安全的方案参考 保证接口数据安全的10种方案\n\n\n# 12.事务控制规范\n\n * 一般推荐使用编程式事务，而不是一个注解 @transactional的声明式事务。因为 @transactional有很多场景，可能导致事务不生效。\n * 事务范围要明确，数据库操作必须在事务作用范围内，如果是非数据库操作，尽量不要包含在事务内。\n * 不要在事务内进行远程调用（可能导致数据不一致，比如本地成功了，但是远程方法失败了，这时候需要用分布式事务解决方案）\n * 事务中避免处理太多数据，一些查询相关的操作，尽量放到事务之外（避免大事务问题）\n\n\n# 13.重复代码处理\n\n大量重复代码（抽公用方法，设计模式）\n\n具体可以参考：优化重复冗余代码的8种方式 - 掘金\n\n\n# 14.操作数据库、缓存、中间件、外部接口的代码单独抽取一个类\n\n\n# 15.使用string.format进行字符串格式化\n\n字符串格式化使用string.format()。用法参考：string.format()详解 - 双间 - 博客园\n\n\n# 16.避免“炫技式”的单行代码\n\n“炫技式”的单行代码难以理解、排查和修改起来都麻烦且耗时。\n\n一个较重的代码坏味：“炫技式”的单行代码 - 琴水玉 - 博客园\n\n\n# reference\n\n * 代码评审的18个军规，收藏好！ - 掘金",charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"Java 命名规范",frontmatter:{title:"Java 命名规范",date:"2023-10-24T07:41:51.000Z",permalink:"/pages/d83c14/"},regularPath:"/01.Java%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/05.%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/02.Java%20%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83.html",relativePath:"01.Java 知识体系/05.代码质量/02.Java 命名规范.md",key:"v-193c5be4",path:"/pages/d83c14/",headers:[{level:1,title:"为什么要重视命名？",slug:"为什么要重视命名",normalizedTitle:"为什么要重视命名？",charIndex:2},{level:1,title:"常见命名规则以及适用场景",slug:"常见命名规则以及适用场景",normalizedTitle:"常见命名规则以及适用场景",charIndex:435},{level:2,title:"驼峰命名法（CamelCase）",slug:"驼峰命名法-camelcase",normalizedTitle:"驼峰命名法（camelcase）",charIndex:472},{level:3,title:"大驼峰命名法（UpperCamelCase）",slug:"大驼峰命名法-uppercamelcase",normalizedTitle:"大驼峰命名法（uppercamelcase）",charIndex:561},{level:3,title:"小驼峰命名法（lowerCamelCase）",slug:"小驼峰命名法-lowercamelcase",normalizedTitle:"小驼峰命名法（lowercamelcase）",charIndex:730},{level:2,title:"蛇形命名法（snake_case）",slug:"蛇形命名法-snake-case",normalizedTitle:"蛇形命名法（snake_case）",charIndex:1005},{level:2,title:"串式命名法（kebab-case）",slug:"串式命名法-kebab-case",normalizedTitle:"串式命名法（kebab-case）",charIndex:1461},{level:1,title:"常见命名规范",slug:"常见命名规范",normalizedTitle:"常见命名规范",charIndex:1558},{level:2,title:"Java 语言基本命名规范",slug:"java-语言基本命名规范",normalizedTitle:"java 语言基本命名规范",charIndex:1569},{level:2,title:"命名易读性规范",slug:"命名易读性规范",normalizedTitle:"命名易读性规范",charIndex:2701},{level:1,title:"reference",slug:"reference",normalizedTitle:"reference",charIndex:3149}],headersStr:"为什么要重视命名？ 常见命名规则以及适用场景 驼峰命名法（CamelCase） 大驼峰命名法（UpperCamelCase） 小驼峰命名法（lowerCamelCase） 蛇形命名法（snake_case） 串式命名法（kebab-case） 常见命名规范 Java 语言基本命名规范 命名易读性规范 reference",content:'# 为什么要重视命名？\n\n为什么命名很重要呢？ 这是因为 好的命名即是注释，别人一看到你的命名就知道你的变量、方法或者类是做什么的！\n\n简单来说就是 别人根据你的命名就能知道你的代码要表达的意思\n\n《Clean Code》这本书明确指出：\n\n> 好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。\n> \n> 若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。\n> \n> 举个例子：\n> \n> 去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可\n> \n> // check to see if the employee is eligible for full benefits\n> if ((employee.flags & HOURLY_FLAG) && (employee.age > 65))\n> \n> \n> 应替换为\n> \n> if (employee.isEligibleForFullBenefits())\n\n\n# 常见命名规则以及适用场景\n\n这里只介绍 3 种最常见的命名规范。\n\n\n# 驼峰命名法（CamelCase）\n\n驼峰命名法应该我们最常见的一个，这种命名方式使用大小写混合的格式来区别各个单词，并且单词之间不使用空格隔开或者连接字符连接的命名方式\n\n\n# 大驼峰命名法（UpperCamelCase）\n\n类名需要使用大驼峰命名法（UpperCamelCase）\n\n正例：\n\nServiceDiscovery、ServiceInstance、LruCacheFactory\n\n\n反例：\n\nserviceDiscovery、Serviceinstance、LRUCacheFactory\n\n\n\n# 小驼峰命名法（lowerCamelCase）\n\n方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase）。\n\n正例：\n\ngetUserInfo()\ncreateCustomThreadPool()\nsetNameFormat(String nameFormat)\nUservice userService;\n\n\n反例：\n\nGetUserInfo()、CreateCustomThreadPool()、setNameFormat(String NameFormat)\nUservice user_service\n\n\n\n# 蛇形命名法（snake_case）\n\n测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case）\n\n在蛇形命名法中，各个单词之间通过下划线“_”连接，比如should_get_200_status_code_when_request_is_valid、CLIENT_CONNECT_SERVER_FAILURE。\n\n蛇形命名法的优势是命名所需要的单词比较多的时候，比如我把上面的命名通过小驼峰命名法给大家看一下：“shouldGet200StatusCodeWhenRequestIsValid”。\n\n感觉如何？ 相比于使用蛇形命名法（snake_case）来说是不是不那么易读？\n\n正例：\n\n@Test\nvoid should_get_200_status_code_when_request_is_valid() {\n  ......\n}\n\n\n反例：\n\n@Test\nvoid shouldGet200StatusCodeWhenRequestIsValid() {\n  ......\n}\n\n\n\n# 串式命名法（kebab-case）\n\n在串式命名法中，各个单词之间通过连接符“-”连接，比如dubbo-registry。\n\n建议项目文件夹名称使用串式命名法（kebab-case）。\n\n\n# 常见命名规范\n\n\n# Java 语言基本命名规范\n\n1、类名需要使用大驼峰命名法（UpperCamelCase）风格。方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase）。\n\n2、测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case），比如should_get_200_status_code_when_request_is_valid、CLIENT_CONNECT_SERVER_FAILURE。并且，测试方法名称要求全部小写，常量以及枚举名称需要全部大写。\n\n3、项目文件夹名称使用串式命名法（kebab-case），比如dubbo-registry。\n\n4、包名统一使用小写，尽量使用单个名词作为包名，各个单词通过 "." 分隔符连接，并且各个单词必须为单数。\n\n正例：org.apache.dubbo.common.threadlocal\n\n反例：org.apache_dubbo.Common.threadLocals\n\n5、抽象类命名使用 Abstract 开头。\n\n//为远程传输部分抽象出来的一个抽象类（出处：Dubbo源码）\npublic abstract class AbstractClient extends AbstractEndpoint implements Client {\n\n}\n\n\n6、异常类命名使用 Exception 结尾。\n\n//自定义的 NoSuchMethodException（出处：Dubbo源码）\npublic class NoSuchMethodException extends RuntimeException {\n    private static final long serialVersionUID = -2725364246023268766L;\n\n    public NoSuchMethodException() {\n        super();\n    }\n\n    public NoSuchMethodException(String msg) {\n        super(msg);\n    }\n}\n\n\n7、测试类命名以它要测试的类的名称开始，以 Test 结尾。\n\n//为 AnnotationUtils 类写的测试类（出处：Dubbo源码）\npublic class AnnotationUtilsTest {\n  ......\n}\n\n\nPOJO 类中布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。\n\n如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。如模版方法模式以Template结尾。\n\n\n# 命名易读性规范\n\n1、为了能让命名更加易懂和易读，尽量不要缩写/简写单词，除非这些单词已经被公认可以被这样缩写/简写。比如 CustomThreadFactory 不可以被写成 ~~CustomTF 。\n\n2、命名不像函数一样要尽量追求短，可读性强的名字优先于简短的名字，虽然可读性强的名字会比较长一点。 这个对应我们上面说的第 1 点。\n\n3、避免无意义的命名，你起的每一个名字都要能表明意思。\n\n正例：UserService userService; int userCount;\n\n反例: UserService service int count\n\n4、避免命名过长（50 个字符以内最好），过长的命名难以阅读并且丑陋。\n\n5、不要使用拼音，更不要使用中文。 不过像 alibaba、wuhan、taobao 这种国际通用名词可以当做英文来看待。\n\n正例：discount\n\n反例：dazhe\n\n全面的命名规范可以参考 编码5分钟，命名2小时？史上最全的Java命名规范参考！。\n\n\n# reference\n\n * 代码命名指南 | JavaGuide(Java面试 学习指南)\n\n * 通用类命名规范 - 就永远夏天 - 博客园\n\n * 编码5分钟，命名2小时？史上最全的Java命名规范参考！\n\n * 编程中最难的就是命名？这几招教你快速上手\n\n * 程序员“起名”头痛根治指南',normalizedContent:'# 为什么要重视命名？\n\n为什么命名很重要呢？ 这是因为 好的命名即是注释，别人一看到你的命名就知道你的变量、方法或者类是做什么的！\n\n简单来说就是 别人根据你的命名就能知道你的代码要表达的意思\n\n《clean code》这本书明确指出：\n\n> 好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。\n> \n> 若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。\n> \n> 举个例子：\n> \n> 去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可\n> \n> // check to see if the employee is eligible for full benefits\n> if ((employee.flags & hourly_flag) && (employee.age > 65))\n> \n> \n> 应替换为\n> \n> if (employee.iseligibleforfullbenefits())\n\n\n# 常见命名规则以及适用场景\n\n这里只介绍 3 种最常见的命名规范。\n\n\n# 驼峰命名法（camelcase）\n\n驼峰命名法应该我们最常见的一个，这种命名方式使用大小写混合的格式来区别各个单词，并且单词之间不使用空格隔开或者连接字符连接的命名方式\n\n\n# 大驼峰命名法（uppercamelcase）\n\n类名需要使用大驼峰命名法（uppercamelcase）\n\n正例：\n\nservicediscovery、serviceinstance、lrucachefactory\n\n\n反例：\n\nservicediscovery、serviceinstance、lrucachefactory\n\n\n\n# 小驼峰命名法（lowercamelcase）\n\n方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowercamelcase）。\n\n正例：\n\ngetuserinfo()\ncreatecustomthreadpool()\nsetnameformat(string nameformat)\nuservice userservice;\n\n\n反例：\n\ngetuserinfo()、createcustomthreadpool()、setnameformat(string nameformat)\nuservice user_service\n\n\n\n# 蛇形命名法（snake_case）\n\n测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case）\n\n在蛇形命名法中，各个单词之间通过下划线“_”连接，比如should_get_200_status_code_when_request_is_valid、client_connect_server_failure。\n\n蛇形命名法的优势是命名所需要的单词比较多的时候，比如我把上面的命名通过小驼峰命名法给大家看一下：“shouldget200statuscodewhenrequestisvalid”。\n\n感觉如何？ 相比于使用蛇形命名法（snake_case）来说是不是不那么易读？\n\n正例：\n\n@test\nvoid should_get_200_status_code_when_request_is_valid() {\n  ......\n}\n\n\n反例：\n\n@test\nvoid shouldget200statuscodewhenrequestisvalid() {\n  ......\n}\n\n\n\n# 串式命名法（kebab-case）\n\n在串式命名法中，各个单词之间通过连接符“-”连接，比如dubbo-registry。\n\n建议项目文件夹名称使用串式命名法（kebab-case）。\n\n\n# 常见命名规范\n\n\n# java 语言基本命名规范\n\n1、类名需要使用大驼峰命名法（uppercamelcase）风格。方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowercamelcase）。\n\n2、测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case），比如should_get_200_status_code_when_request_is_valid、client_connect_server_failure。并且，测试方法名称要求全部小写，常量以及枚举名称需要全部大写。\n\n3、项目文件夹名称使用串式命名法（kebab-case），比如dubbo-registry。\n\n4、包名统一使用小写，尽量使用单个名词作为包名，各个单词通过 "." 分隔符连接，并且各个单词必须为单数。\n\n正例：org.apache.dubbo.common.threadlocal\n\n反例：org.apache_dubbo.common.threadlocals\n\n5、抽象类命名使用 abstract 开头。\n\n//为远程传输部分抽象出来的一个抽象类（出处：dubbo源码）\npublic abstract class abstractclient extends abstractendpoint implements client {\n\n}\n\n\n6、异常类命名使用 exception 结尾。\n\n//自定义的 nosuchmethodexception（出处：dubbo源码）\npublic class nosuchmethodexception extends runtimeexception {\n    private static final long serialversionuid = -2725364246023268766l;\n\n    public nosuchmethodexception() {\n        super();\n    }\n\n    public nosuchmethodexception(string msg) {\n        super(msg);\n    }\n}\n\n\n7、测试类命名以它要测试的类的名称开始，以 test 结尾。\n\n//为 annotationutils 类写的测试类（出处：dubbo源码）\npublic class annotationutilstest {\n  ......\n}\n\n\npojo 类中布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。\n\n如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。如模版方法模式以template结尾。\n\n\n# 命名易读性规范\n\n1、为了能让命名更加易懂和易读，尽量不要缩写/简写单词，除非这些单词已经被公认可以被这样缩写/简写。比如 customthreadfactory 不可以被写成 ~~customtf 。\n\n2、命名不像函数一样要尽量追求短，可读性强的名字优先于简短的名字，虽然可读性强的名字会比较长一点。 这个对应我们上面说的第 1 点。\n\n3、避免无意义的命名，你起的每一个名字都要能表明意思。\n\n正例：userservice userservice; int usercount;\n\n反例: userservice service int count\n\n4、避免命名过长（50 个字符以内最好），过长的命名难以阅读并且丑陋。\n\n5、不要使用拼音，更不要使用中文。 不过像 alibaba、wuhan、taobao 这种国际通用名词可以当做英文来看待。\n\n正例：discount\n\n反例：dazhe\n\n全面的命名规范可以参考 编码5分钟，命名2小时？史上最全的java命名规范参考！。\n\n\n# reference\n\n * 代码命名指南 | javaguide(java面试 学习指南)\n\n * 通用类命名规范 - 就永远夏天 - 博客园\n\n * 编码5分钟，命名2小时？史上最全的java命名规范参考！\n\n * 编程中最难的就是命名？这几招教你快速上手\n\n * 程序员“起名”头痛根治指南',charsets:{cjk:!0},lastUpdated:"2023/10/24, 03:39:33",lastUpdatedTimestamp:1698118773e3},{title:"简历制作",frontmatter:{title:"简历制作",date:"2023-10-24T15:27:49.000Z",permalink:"/pages/80654c/"},regularPath:"/02.Java%20%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/01.%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/02.%E7%AE%80%E5%8E%86%E5%88%B6%E4%BD%9C.html",relativePath:"02.Java 面试宝典/01.面试准备/02.简历制作.md",key:"v-8ad2cece",path:"/pages/80654c/",headers:[{level:1,title:"简历内容",slug:"简历内容",normalizedTitle:"简历内容",charIndex:63},{level:2,title:"个人信息",slug:"个人信息",normalizedTitle:"个人信息",charIndex:72},{level:2,title:"求职意向",slug:"求职意向",normalizedTitle:"求职意向",charIndex:127},{level:2,title:"教育背景",slug:"教育背景",normalizedTitle:"教育背景",charIndex:159},{level:2,title:"技能清单",slug:"技能清单",normalizedTitle:"技能清单",charIndex:185},{level:2,title:"工作经历",slug:"工作经历",normalizedTitle:"工作经历",charIndex:373},{level:2,title:"项目经验",slug:"项目经验",normalizedTitle:"项目经验",charIndex:417},{level:2,title:"自我评价",slug:"自我评价",normalizedTitle:"自我评价",charIndex:642},{level:1,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:667},{level:1,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:773}],headersStr:"简历内容 个人信息 求职意向 教育背景 技能清单 工作经历 项目经验 自我评价 注意事项 参考资料",content:"简历制作的目的是为了获得面试机会，再通过面试查缺补漏。\n\n文件格式：使用md文件编写，并导出pdf格式进行简历投递。\n\n\n# 简历内容\n\n\n# 个人信息\n\n内容：姓名、性别、年龄（出生年份也可以）、籍贯、联系方式（手机、邮箱）。最好不要放照片。\n\n\n# 求职意向\n\n内容：期望职位、期望城市，不要写期望薪资。\n\n\n# 教育背景\n\n内容：学校、学历、专业、时间。\n\n\n# 技能清单\n\n技能清单主要是为了直接展示求职者的优势（FAB法则），让面试官对你有直接的了解。 技能清单可以写技术亮点，也可以写软技能（带领团队、跨部门沟通）。 技能清单写的亮点大概率是面试题提问的点，要进行相应的面试准备。心态放平，面试就算被问倒，不要怕被嘲笑，回来补上就行。 精通的界限：能回答市面上所有的相关面试题就可以写精通。精通不能无中生有，不然会有反作用。\n\n\n# 工作经历\n\n写上公司名称、工作起止时间、职位就可以。 工作经验不多，可以不写。\n\n\n# 项目经验\n\n内容：\n\n * 项目描述：主要描述项目的作用。\n * 项目架构：项目使用的技术架构\n * 我的项目职责（非常重要）：主要写自己负责的模块以及自己对项目的优化（优化成果要尽量量化下），可以使用STAR法则进行描述。这是面试中发问的点，要吃透，提前准备，注入水分，自圆其说。\n   * 优化例子：\n     * 双写一致性，延时双删。\n     * 多线程（线程池）数据入库\n     * JVM：OOM处理\n     * 分布式锁\n\n\n# 自我评价\n\n适合刚刚毕业或者经验比较浅。\n\n\n# 注意事项\n\n * 一些技术名词不要弄错了大小写比如 MySQL 不要写成 mysql，Java 不要写成 java\n * 中文和数字英文之间加上空格的话看起来会舒服一点。\n * 不会的东西不要写在简历上\n\n\n# 参考资料\n\n * Java程序员，如何书写一手好简历（诱饵）本人脱敏简历展示给大家，并附带书写思路，可与上个视频结合观看。_哔哩哔哩_bilibili\n * 如何写一份好的吸引人的简历 - 琴水玉 - 博客园",normalizedContent:"简历制作的目的是为了获得面试机会，再通过面试查缺补漏。\n\n文件格式：使用md文件编写，并导出pdf格式进行简历投递。\n\n\n# 简历内容\n\n\n# 个人信息\n\n内容：姓名、性别、年龄（出生年份也可以）、籍贯、联系方式（手机、邮箱）。最好不要放照片。\n\n\n# 求职意向\n\n内容：期望职位、期望城市，不要写期望薪资。\n\n\n# 教育背景\n\n内容：学校、学历、专业、时间。\n\n\n# 技能清单\n\n技能清单主要是为了直接展示求职者的优势（fab法则），让面试官对你有直接的了解。 技能清单可以写技术亮点，也可以写软技能（带领团队、跨部门沟通）。 技能清单写的亮点大概率是面试题提问的点，要进行相应的面试准备。心态放平，面试就算被问倒，不要怕被嘲笑，回来补上就行。 精通的界限：能回答市面上所有的相关面试题就可以写精通。精通不能无中生有，不然会有反作用。\n\n\n# 工作经历\n\n写上公司名称、工作起止时间、职位就可以。 工作经验不多，可以不写。\n\n\n# 项目经验\n\n内容：\n\n * 项目描述：主要描述项目的作用。\n * 项目架构：项目使用的技术架构\n * 我的项目职责（非常重要）：主要写自己负责的模块以及自己对项目的优化（优化成果要尽量量化下），可以使用star法则进行描述。这是面试中发问的点，要吃透，提前准备，注入水分，自圆其说。\n   * 优化例子：\n     * 双写一致性，延时双删。\n     * 多线程（线程池）数据入库\n     * jvm：oom处理\n     * 分布式锁\n\n\n# 自我评价\n\n适合刚刚毕业或者经验比较浅。\n\n\n# 注意事项\n\n * 一些技术名词不要弄错了大小写比如 mysql 不要写成 mysql，java 不要写成 java\n * 中文和数字英文之间加上空格的话看起来会舒服一点。\n * 不会的东西不要写在简历上\n\n\n# 参考资料\n\n * java程序员，如何书写一手好简历（诱饵）本人脱敏简历展示给大家，并附带书写思路，可与上个视频结合观看。_哔哩哔哩_bilibili\n * 如何写一份好的吸引人的简历 - 琴水玉 - 博客园",charsets:{cjk:!0},lastUpdated:"2023/11/01, 07:57:39",lastUpdatedTimestamp:1698825459e3},{title:"面试准备",frontmatter:{title:"面试准备",date:"2023-10-24T15:21:13.000Z",permalink:"/pages/5547aa/"},regularPath:"/02.Java%20%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/01.%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/01.%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.html",relativePath:"02.Java 面试宝典/01.面试准备/01.面试准备.md",key:"v-33cdacc0",path:"/pages/5547aa/",headers:[{level:1,title:"1、以求职为导向学习",slug:"_1、以求职为导向学习",normalizedTitle:"1、以求职为导向学习",charIndex:71},{level:1,title:"2、简历制作",slug:"_2、简历制作",normalizedTitle:"2、简历制作",charIndex:203},{level:1,title:"3、自我介绍",slug:"_3、自我介绍",normalizedTitle:"3、自我介绍",charIndex:223},{level:2,title:"HR自我介绍",slug:"hr自我介绍",normalizedTitle:"hr自我介绍",charIndex:234},{level:2,title:"技术自我介绍",slug:"技术自我介绍",normalizedTitle:"技术自我介绍",charIndex:267},{level:1,title:"4、项目介绍",slug:"_4、项目介绍",normalizedTitle:"4、项目介绍",charIndex:581},{level:1,title:"5、技术面试题准备",slug:"_5、技术面试题准备",normalizedTitle:"5、技术面试题准备",charIndex:837},{level:2,title:"如何回答自己会的问题",slug:"如何回答自己会的问题",normalizedTitle:"如何回答自己会的问题",charIndex:873},{level:2,title:"如何回答自己不会的问题",slug:"如何回答自己不会的问题",normalizedTitle:"如何回答自己不会的问题",charIndex:1146},{level:1,title:"6、投简历",slug:"_6、投简历",normalizedTitle:"6、投简历",charIndex:1371},{level:2,title:"选择意向职位",slug:"选择意向职位",normalizedTitle:"选择意向职位",charIndex:1414},{level:2,title:"如何了解公司信息",slug:"如何了解公司信息",normalizedTitle:"如何了解公司信息",charIndex:1451},{level:1,title:"7、面试过程技巧",slug:"_7、面试过程技巧",normalizedTitle:"7、面试过程技巧",charIndex:1594},{level:1,title:"8、面试后记的复盘",slug:"_8、面试后记的复盘",normalizedTitle:"8、面试后记的复盘",charIndex:1749}],headersStr:"1、以求职为导向学习 2、简历制作 3、自我介绍 HR自我介绍 技术自我介绍 4、项目介绍 5、技术面试题准备 如何回答自己会的问题 如何回答自己不会的问题 6、投简历 选择意向职位 如何了解公司信息 7、面试过程技巧 8、面试后记的复盘",content:"总体流程：写简历->准备面试题（开口回答并录音）->面试（录音）->复盘->更新简历、面试题查缺补漏->继续面试->拿到 Offer\n\n\n# 1、以求职为导向学习\n\n根据招聘要求整理一份目标岗位的技能清单，然后按照技能清单去学习和提升。\n\n 1. 你首先搞清楚自己要做什么工作\n 2. 根据招聘岗位要求梳理一份技能清单\n 3. 根据技能清单写好最终的简历\n 4. 然后再按照建立的要求去学习和提升\n\n\n# 2、简历制作\n\n参考：简历制作\n\n\n# 3、自我介绍\n\n\n# HR自我介绍\n\n主要讲自己的经历，会的编程技术一语带过。\n\n\n# 技术自我介绍\n\n主要讲自己会的技术细节和项目经验。\n\n时长大约3~5分钟。\n\n 1. 基础情况：姓名、年龄（年龄小不用说）、学校专业（211,、985或者科班可以说）\n 2. 最近一段时间的工作经验：描述一个最熟悉、技术栈最丰富的项目经验\n 3. 项目介绍\n\n * 当前项目的价值（如：全国80%医院都用到这个项目）\n * 用到的技术栈：选择自己最熟悉的\n * 承担的主要职责（如：需求开发、数据库建模）\n * 解决项目的主要问题（展示自己的技术实力）\n\n 4. 说一下对这家公司的了解（展示态度）：当前公司的行业解决方案。\n 5. 结束语（正常面试官会前面的环节打断你）：上面就是我的个人简介，您看您有什么想了解的。\n\n\n# 4、项目介绍\n\n不要把所有项目都说一遍，显的没有重点。可以说自己工作几年，做了几个项目，拿最近最熟悉的项目来陈述。\n\n结构：总-分-总\n\n 1. 表述项目的核心功能：有哪些模块，哪些核心功能\n 2. 说明项目中你参与的核心技术模块（职责描述）：当前项目所使用的技能、项目架构（微服务、中间件）。\n 3. 描述项目开发过程中存在的技术问题、解决思路和方案：不能说问领导或者问同事，一定要自己解决的，体现自己解决问题的能力。\n 4. **结束语：**上面就是我对自己项目经验的简单介绍，您看下有什么想问的。\n\n\n# 5、技术面试题准备\n\n根据自己写好的技能清单准备好相关面试题。\n\n\n# 如何回答自己会的问题\n\n回答问题要用总-分的思想：\n\n 1. 技术的应用场景，为什么要用这个技术，这个技术解决什么问题\n 2. 分步骤说明怎么使用这技术\n 3. 使用这技术会遇见什么问题？怎么解决这些问题（扩展知识点并体现自己的实际工作经验）\n 4. 结束语：面试官，我回答完了，这就是我对这个知识点的理解。\n\n比如回答mysql的主从复制：\n\n 1. 为什么要用mysql主从复制，解决什么问题\n 2. 分步骤说明怎么实现主从复制\n 3. 主从复制延迟问题（体现自己的实际工作经验），主从复制-》读写分离-》分库分表。\n 4. 结束语\n\n\n# 如何回答自己不会的问题\n\n分两种情况：\n\n * 有一点了解或者接触过类似的技术：不好意思，面试官，这个技术我没接触过，但是我了解过跟他类似的技术，这个技术在我项目是怎么使用的。如果面试官打断你，就结束你的陈述，等面试官进一步动作，不要自顾自的一直说下去。\n * 一点都不会：切记不要不懂装懂。不好意思，面试官。这些技术我没接触过，但我自学能力强，给我时间我相信自己能更快学会。您能告诉这个技术在咱们项目中是如何使用的吗（把问题抛回给面试官）\n\n\n# 6、投简历\n\n投简历的目的就是得到面试机会。一定要根据招聘要求对应修改简历。\n\n\n# 选择意向职位\n\n确认自己的硬性要求，比如：五险一金必须有，双休。\n\n\n# 如何了解公司信息\n\n * 国家企业信息公示网：https://www.gsxt.gov.cn/corp-query-homepage.html\n * 看准网：https://www.kanzhun.com/\n * 天眼查：https://www.tianyancha.com/\n\n\n# 7、面试过程技巧\n\n面试过程最好录音，方便复盘。\n\n面试最尴尬的场景是两个人或者多个人都不说话，如果这样的话这场面试正常是不通过。\n\n面试技巧：\n\n * 要自己掌握节奏，引导面试官问你最擅长的方向，不能让面试官一直问你问题。\n * 一天最多面两家面试，并且要对面试的公司有基本的了解，并做好面试准备。\n\n\n# 8、面试后记的复盘",normalizedContent:"总体流程：写简历->准备面试题（开口回答并录音）->面试（录音）->复盘->更新简历、面试题查缺补漏->继续面试->拿到 offer\n\n\n# 1、以求职为导向学习\n\n根据招聘要求整理一份目标岗位的技能清单，然后按照技能清单去学习和提升。\n\n 1. 你首先搞清楚自己要做什么工作\n 2. 根据招聘岗位要求梳理一份技能清单\n 3. 根据技能清单写好最终的简历\n 4. 然后再按照建立的要求去学习和提升\n\n\n# 2、简历制作\n\n参考：简历制作\n\n\n# 3、自我介绍\n\n\n# hr自我介绍\n\n主要讲自己的经历，会的编程技术一语带过。\n\n\n# 技术自我介绍\n\n主要讲自己会的技术细节和项目经验。\n\n时长大约3~5分钟。\n\n 1. 基础情况：姓名、年龄（年龄小不用说）、学校专业（211,、985或者科班可以说）\n 2. 最近一段时间的工作经验：描述一个最熟悉、技术栈最丰富的项目经验\n 3. 项目介绍\n\n * 当前项目的价值（如：全国80%医院都用到这个项目）\n * 用到的技术栈：选择自己最熟悉的\n * 承担的主要职责（如：需求开发、数据库建模）\n * 解决项目的主要问题（展示自己的技术实力）\n\n 4. 说一下对这家公司的了解（展示态度）：当前公司的行业解决方案。\n 5. 结束语（正常面试官会前面的环节打断你）：上面就是我的个人简介，您看您有什么想了解的。\n\n\n# 4、项目介绍\n\n不要把所有项目都说一遍，显的没有重点。可以说自己工作几年，做了几个项目，拿最近最熟悉的项目来陈述。\n\n结构：总-分-总\n\n 1. 表述项目的核心功能：有哪些模块，哪些核心功能\n 2. 说明项目中你参与的核心技术模块（职责描述）：当前项目所使用的技能、项目架构（微服务、中间件）。\n 3. 描述项目开发过程中存在的技术问题、解决思路和方案：不能说问领导或者问同事，一定要自己解决的，体现自己解决问题的能力。\n 4. **结束语：**上面就是我对自己项目经验的简单介绍，您看下有什么想问的。\n\n\n# 5、技术面试题准备\n\n根据自己写好的技能清单准备好相关面试题。\n\n\n# 如何回答自己会的问题\n\n回答问题要用总-分的思想：\n\n 1. 技术的应用场景，为什么要用这个技术，这个技术解决什么问题\n 2. 分步骤说明怎么使用这技术\n 3. 使用这技术会遇见什么问题？怎么解决这些问题（扩展知识点并体现自己的实际工作经验）\n 4. 结束语：面试官，我回答完了，这就是我对这个知识点的理解。\n\n比如回答mysql的主从复制：\n\n 1. 为什么要用mysql主从复制，解决什么问题\n 2. 分步骤说明怎么实现主从复制\n 3. 主从复制延迟问题（体现自己的实际工作经验），主从复制-》读写分离-》分库分表。\n 4. 结束语\n\n\n# 如何回答自己不会的问题\n\n分两种情况：\n\n * 有一点了解或者接触过类似的技术：不好意思，面试官，这个技术我没接触过，但是我了解过跟他类似的技术，这个技术在我项目是怎么使用的。如果面试官打断你，就结束你的陈述，等面试官进一步动作，不要自顾自的一直说下去。\n * 一点都不会：切记不要不懂装懂。不好意思，面试官。这些技术我没接触过，但我自学能力强，给我时间我相信自己能更快学会。您能告诉这个技术在咱们项目中是如何使用的吗（把问题抛回给面试官）\n\n\n# 6、投简历\n\n投简历的目的就是得到面试机会。一定要根据招聘要求对应修改简历。\n\n\n# 选择意向职位\n\n确认自己的硬性要求，比如：五险一金必须有，双休。\n\n\n# 如何了解公司信息\n\n * 国家企业信息公示网：https://www.gsxt.gov.cn/corp-query-homepage.html\n * 看准网：https://www.kanzhun.com/\n * 天眼查：https://www.tianyancha.com/\n\n\n# 7、面试过程技巧\n\n面试过程最好录音，方便复盘。\n\n面试最尴尬的场景是两个人或者多个人都不说话，如果这样的话这场面试正常是不通过。\n\n面试技巧：\n\n * 要自己掌握节奏，引导面试官问你最擅长的方向，不能让面试官一直问你问题。\n * 一天最多面两家面试，并且要对面试的公司有基本的了解，并做好面试准备。\n\n\n# 8、面试后记的复盘",charsets:{cjk:!0},lastUpdated:"2023/11/01, 07:57:39",lastUpdatedTimestamp:1698825459e3},{title:"Boss 直聘投简历技巧",frontmatter:{title:"Boss 直聘投简历技巧",date:"2023-11-02T08:56:08.000Z",permalink:"/pages/5da9d3/"},regularPath:"/02.Java%20%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/01.%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/03.Boss%20%E7%9B%B4%E8%81%98%E6%8A%95%E7%AE%80%E5%8E%86%E6%8A%80%E5%B7%A7.html",relativePath:"02.Java 面试宝典/01.面试准备/03.Boss 直聘投简历技巧.md",key:"v-6d7f8b89",path:"/pages/5da9d3/",headers:[{level:1,title:"简历筛选的3道关卡",slug:"简历筛选的3道关卡",normalizedTitle:"简历筛选的3道关卡",charIndex:2},{level:1,title:"在线简历优化",slug:"在线简历优化",normalizedTitle:"在线简历优化",charIndex:167}],headersStr:"简历筛选的3道关卡 在线简历优化",content:"# 简历筛选的3道关卡\n\n 1. HR筛选在线简历： HR刷新简历列表或接收推荐的简历列表，审核Boss在线简历(第一印象)\n 2. HR筛选附件简历： HR邀请面试者发送附件简历，或面试者提出感兴趣后，第一关过了后，发送附件简历\n 3. 企业用人部门确定面试人员： 面试招聘团队，面试官审核HR审核后的简历，确定面试人员。\n\n\n# 在线简历优化\n\n 1. Boss上第一关卡就是在线简历，在线简历不用太真实，但是和附件简历差距也不要太大。不会的写上也没关系，主要吸引HR聊为主，不会背下面试题。 如果自己的在线简历连外包性质公司和HR的都没有吸引到，还得持续优化。\n 2. 工作经历上可以选择一些目标岗位要求的技能，吸引HR找你聊\n 3. 充值Boss上的30元豆，每天可以手动刷新50-100个曝光度，每日保持在600+的曝光度比较好一点。没事的时候，自己随便修改下简历的某些字，可能会触发简历的修改刷新，HR那边也会看到自己的状态是不是刚刚在线的。\n 4. 如果是自己主动投递的，在工作日，找那种刚刚上线的或者HR的状态是绿色在线的，几率会大一点。 如果是HR主动来聊感兴趣的，先别着急发送附件简历，先去看看公司的人数和招聘的需求和公司的类型，判断下是否是外包、外派、驻场业务(也可以和HR确认下)以及是否自己想去积累面试经验的。",normalizedContent:"# 简历筛选的3道关卡\n\n 1. hr筛选在线简历： hr刷新简历列表或接收推荐的简历列表，审核boss在线简历(第一印象)\n 2. hr筛选附件简历： hr邀请面试者发送附件简历，或面试者提出感兴趣后，第一关过了后，发送附件简历\n 3. 企业用人部门确定面试人员： 面试招聘团队，面试官审核hr审核后的简历，确定面试人员。\n\n\n# 在线简历优化\n\n 1. boss上第一关卡就是在线简历，在线简历不用太真实，但是和附件简历差距也不要太大。不会的写上也没关系，主要吸引hr聊为主，不会背下面试题。 如果自己的在线简历连外包性质公司和hr的都没有吸引到，还得持续优化。\n 2. 工作经历上可以选择一些目标岗位要求的技能，吸引hr找你聊\n 3. 充值boss上的30元豆，每天可以手动刷新50-100个曝光度，每日保持在600+的曝光度比较好一点。没事的时候，自己随便修改下简历的某些字，可能会触发简历的修改刷新，hr那边也会看到自己的状态是不是刚刚在线的。\n 4. 如果是自己主动投递的，在工作日，找那种刚刚上线的或者hr的状态是绿色在线的，几率会大一点。 如果是hr主动来聊感兴趣的，先别着急发送附件简历，先去看看公司的人数和招聘的需求和公司的类型，判断下是否是外包、外派、驻场业务(也可以和hr确认下)以及是否自己想去积累面试经验的。",charsets:{cjk:!0},lastUpdated:"2023/11/02, 00:58:56",lastUpdatedTimestamp:1698886736e3},{title:"Java 集合 面试题",frontmatter:{title:"Java 集合 面试题",date:"2023-10-24T15:38:08.000Z",permalink:"/pages/346648/"},regularPath:"/02.Java%20%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%20%E5%85%AB%E8%82%A1%E6%96%87/02.Java%20%E9%9B%86%E5%90%88%20%E9%9D%A2%E8%AF%95%E9%A2%98.html",relativePath:"02.Java 面试宝典/02.Java 八股文/02.Java 集合 面试题.md",key:"v-6ced3d6b",path:"/pages/346648/",headers:[{level:1,title:"基础",slug:"基础",normalizedTitle:"基础",charIndex:2},{level:2,title:"说一说 List、Set、Map 三者的区别",slug:"说一说-list、set、map-三者的区别",normalizedTitle:"说一说 list、set、map 三者的区别",charIndex:9},{level:2,title:"List、Set、Map、在 Java 中分别有哪些对应的实现类？底层的数据结构",slug:"list、set、map、在-java-中分别有哪些对应的实现类-底层的数据结构",normalizedTitle:"list、set、map、在 java 中分别有哪些对应的实现类？底层的数据结构",charIndex:234},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:0},{level:1,title:"List",slug:"list",normalizedTitle:"list",charIndex:13},{level:2,title:"ArrayList 和 Vector 的区别",slug:"arraylist-和-vector-的区别",normalizedTitle:"arraylist 和 vector 的区别",charIndex:971},{level:2,title:"ArrayList 和 LinkedList的区别",slug:"arraylist-和-linkedlist的区别",normalizedTitle:"arraylist 和 linkedlist的区别",charIndex:1108},{level:2,title:"说一说 ArrayList 的扩容机制吧",slug:"说一说-arraylist-的扩容机制吧",normalizedTitle:"说一说 arraylist 的扩容机制吧",charIndex:2048},{level:1,title:"HashMap",slug:"hashmap",normalizedTitle:"hashmap",charIndex:409},{level:2,title:"HashMap 的底层实现",slug:"hashmap-的底层实现",normalizedTitle:"hashmap 的底层实现",charIndex:2321},{level:2,title:"HashMap 多线程操作导致死循环问题（CPU占满）",slug:"hashmap-多线程操作导致死循环问题-cpu占满",normalizedTitle:"hashmap 多线程操作导致死循环问题（cpu占满）",charIndex:2490},{level:1,title:"ConcurrentHashMap",slug:"concurrenthashmap",normalizedTitle:"concurrenthashmap",charIndex:2679},{level:2,title:"ConcurrentHashMap 线程安全的底层实现方式",slug:"concurrenthashmap-线程安全的底层实现方式",normalizedTitle:"concurrenthashmap 线程安全的底层实现方式",charIndex:2701},{level:2,title:"HashMap和ConcurrentHashMap区别",slug:"hashmap和concurrenthashmap区别",normalizedTitle:"hashmap和concurrenthashmap区别",charIndex:3072}],headersStr:"基础 说一说 List、Set、Map 三者的区别 List、Set、Map、在 Java 中分别有哪些对应的实现类？底层的数据结构  List ArrayList 和 Vector 的区别 ArrayList 和 LinkedList的区别 说一说 ArrayList 的扩容机制吧 HashMap HashMap 的底层实现 HashMap 多线程操作导致死循环问题（CPU占满） ConcurrentHashMap ConcurrentHashMap 线程安全的底层实现方式 HashMap和ConcurrentHashMap区别",content:'# 基础\n\n\n# 说一说 List、Set、Map 三者的区别\n\n * List(对付顺序的好帮手): 存储的元素是有序的、可重复的。\n * Set(注重独一无二的性质): 存储的元素是无序的、不可重复的。\n * Map(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，"x" 代表 key，"y" 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。\n\n\n# List、Set、Map、在 Java 中分别有哪些对应的实现类？底层的数据结构\n\nList：\n\n * ArrayList： Object[] 数组\n * Vector：Object[] 数组\n * LinkedList： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)\n\nSet：\n\n * HashSet(无序，唯一): 基于 HashMap 实现的，底层采用 HashMap 来保存元素\n * LinkedHashSet: LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。\n * TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树)\n\nMap：\n\n * HashMap： JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间\n * LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：《LinkedHashMap 源码详细分析（JDK1.8）》\n\n\n#\n\n\n# List\n\n\n# ArrayList 和 Vector 的区别\n\n * ArrayList 是 List 的主要实现类，底层使用 Object[]存储，适用于频繁的查找工作，线程不安全 ；\n * Vector 是 List 的古老实现类，底层使用Object[] 存储，线程安全的。\n\n\n# ArrayList 和 LinkedList的区别\n\n * **是否保证线程安全：**ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；\n * **底层数据结构：**ArrayList 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）\n * 插入和删除是否受元素位置的影响：\n * ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。\n * LinkedList 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst() 、 removeLast()），时间复杂度为 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o)）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。\n * **是否支持快速随机访问：**LinkedList 不支持高效的随机元素访问，而 ArrayList（实现了RandomAccess接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。\n * **内存空间占用：**ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。\n\n\n# 说一说 ArrayList 的扩容机制吧\n\nArrayList 底层是 Object 数组。当ArrayList添加一个元素时，如果所需的最小容量大于当前存储数据的数组长度时，就会进行扩容。 扩容会先计算新数组的容量，然后将原先旧数组的数据复制到新数组中。 新数组的容量计算经过两次判断：\n\n * 如果原先数组的容量加上右移一位的容量跟所需的最小的容量对比，取两者最大值。\n * 如果上面计算的容量小于MAX_ARRAY_SIZE，新数组容量就是MAX_ARRAY_SIZE或者Integer.MAX_VALUE\n\n\n# HashMap\n\n\n# HashMap 的底层实现\n\nJDK1.8 之前：HashMap的底层数据结构是数组+链表。链表是为了解决哈希冲突。 JDK1.8 之后：HashMap的底层数据结构是数组+链表+红黑树。当链表的长度大于阈值（默认是8），会判断当前数组长度是否小于64，如果小于64，会先进行扩容，否则的话，会将链表转换为红黑树，减少搜索时间。\n\n\n# HashMap 多线程操作导致死循环问题（CPU占满）\n\n原因在于 HashMap 的扩容 resize() 方法。由于扩容是新增数组，然后复制原数据到数组。但数组下有链表，多线程时复制链表可以会形成一个循环链表。 不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。\n\n\n# ConcurrentHashMap\n\n\n# ConcurrentHashMap 线程安全的底层实现方式\n\nJDK 1.8 之前 ConcurrentHashMap 是由 Segment 数组+HashEntry数组+链表构成的。Segment 继承了 ReentrantLock，采用分段锁，每把锁只锁一个 Segment，Segment不可扩容，默认Segment数组为16。1个 Segment 包含一个HashEntry 数组，HashEntry 存储键数据，支持扩容。每个 HashEntry 是个链表结构。\n\n\n\nJDK 1.8 之后由 Node数组+链表+红黑树构成。链表长度在超过8时将链表转换成红黑树。取消了 Segment分段锁，采用Node+CAS+synchronized 保证并发安全。synchronized  只会锁定当前链表或红黑二叉树的首节点。\n\n\n# HashMap和ConcurrentHashMap区别\n\n * HashMap线程不安全，ConcurrentHashMap 线程安全，\n * HashMap允许Null键和Null值，而ConcurrentHashMap都不允许',normalizedContent:'# 基础\n\n\n# 说一说 list、set、map 三者的区别\n\n * list(对付顺序的好帮手): 存储的元素是有序的、可重复的。\n * set(注重独一无二的性质): 存储的元素是无序的、不可重复的。\n * map(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，"x" 代表 key，"y" 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。\n\n\n# list、set、map、在 java 中分别有哪些对应的实现类？底层的数据结构\n\nlist：\n\n * arraylist： object[] 数组\n * vector：object[] 数组\n * linkedlist： 双向链表(jdk1.6 之前为循环链表，jdk1.7 取消了循环)\n\nset：\n\n * hashset(无序，唯一): 基于 hashmap 实现的，底层采用 hashmap 来保存元素\n * linkedhashset: linkedhashset 是 hashset 的子类，并且其内部是通过 linkedhashmap 来实现的。\n * treeset(有序，唯一): 红黑树(自平衡的排序二叉树)\n\nmap：\n\n * hashmap： jdk1.8 之前 hashmap 由数组+链表组成的，数组是 hashmap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。jdk1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间\n * linkedhashmap： linkedhashmap 继承自 hashmap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，linkedhashmap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：《linkedhashmap 源码详细分析（jdk1.8）》\n\n\n#\n\n\n# list\n\n\n# arraylist 和 vector 的区别\n\n * arraylist 是 list 的主要实现类，底层使用 object[]存储，适用于频繁的查找工作，线程不安全 ；\n * vector 是 list 的古老实现类，底层使用object[] 存储，线程安全的。\n\n\n# arraylist 和 linkedlist的区别\n\n * **是否保证线程安全：**arraylist 和 linkedlist 都是不同步的，也就是不保证线程安全；\n * **底层数据结构：**arraylist 底层使用的是 object 数组；linkedlist 底层使用的是 双向链表 数据结构（jdk1.6 之前为循环链表，jdk1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）\n * 插入和删除是否受元素位置的影响：\n * arraylist 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(e e)方法的时候， arraylist 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 o(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, e element)）时间复杂度就为 o(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。\n * linkedlist 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（add(e e)、addfirst(e e)、addlast(e e)、removefirst() 、 removelast()），时间复杂度为 o(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, e element)，remove(object o)）， 时间复杂度为 o(n) ，因为需要先移动到指定位置再插入。\n * **是否支持快速随机访问：**linkedlist 不支持高效的随机元素访问，而 arraylist（实现了randomaccess接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。\n * **内存空间占用：**arraylist 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 linkedlist 的空间花费则体现在它的每一个元素都需要消耗比 arraylist 更多的空间（因为要存放直接后继和直接前驱以及数据）。\n\n\n# 说一说 arraylist 的扩容机制吧\n\narraylist 底层是 object 数组。当arraylist添加一个元素时，如果所需的最小容量大于当前存储数据的数组长度时，就会进行扩容。 扩容会先计算新数组的容量，然后将原先旧数组的数据复制到新数组中。 新数组的容量计算经过两次判断：\n\n * 如果原先数组的容量加上右移一位的容量跟所需的最小的容量对比，取两者最大值。\n * 如果上面计算的容量小于max_array_size，新数组容量就是max_array_size或者integer.max_value\n\n\n# hashmap\n\n\n# hashmap 的底层实现\n\njdk1.8 之前：hashmap的底层数据结构是数组+链表。链表是为了解决哈希冲突。 jdk1.8 之后：hashmap的底层数据结构是数组+链表+红黑树。当链表的长度大于阈值（默认是8），会判断当前数组长度是否小于64，如果小于64，会先进行扩容，否则的话，会将链表转换为红黑树，减少搜索时间。\n\n\n# hashmap 多线程操作导致死循环问题（cpu占满）\n\n原因在于 hashmap 的扩容 resize() 方法。由于扩容是新增数组，然后复制原数据到数组。但数组下有链表，多线程时复制链表可以会形成一个循环链表。 不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 hashmap,因为多线程下使用 hashmap 还是会存在其他问题比如数据丢失。\n\n\n# concurrenthashmap\n\n\n# concurrenthashmap 线程安全的底层实现方式\n\njdk 1.8 之前 concurrenthashmap 是由 segment 数组+hashentry数组+链表构成的。segment 继承了 reentrantlock，采用分段锁，每把锁只锁一个 segment，segment不可扩容，默认segment数组为16。1个 segment 包含一个hashentry 数组，hashentry 存储键数据，支持扩容。每个 hashentry 是个链表结构。\n\n\n\njdk 1.8 之后由 node数组+链表+红黑树构成。链表长度在超过8时将链表转换成红黑树。取消了 segment分段锁，采用node+cas+synchronized 保证并发安全。synchronized  只会锁定当前链表或红黑二叉树的首节点。\n\n\n# hashmap和concurrenthashmap区别\n\n * hashmap线程不安全，concurrenthashmap 线程安全，\n * hashmap允许null键和null值，而concurrenthashmap都不允许',charsets:{cjk:!0},lastUpdated:"2023/10/24, 07:59:40",lastUpdatedTimestamp:169813438e4},{title:"Java 基础面试题",frontmatter:{title:"Java 基础面试题",date:"2023-10-24T15:37:42.000Z",permalink:"/pages/b4d599/"},regularPath:"/02.Java%20%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%20%E5%85%AB%E8%82%A1%E6%96%87/01.Java%20%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.html",relativePath:"02.Java 面试宝典/02.Java 八股文/01.Java 基础面试题.md",key:"v-01767fb0",path:"/pages/b4d599/",headers:[{level:1,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:2},{level:2,title:"Java 中有哪8中基本数据类型?它们的默认值和占用空间大小知道不？说说这8种基本数据类型对应的包装类型。",slug:"java-中有哪8中基本数据类型-它们的默认值和占用空间大小知道不-说说这8种基本数据类型对应的包装类型。",normalizedTitle:"java 中有哪8中基本数据类型?它们的默认值和占用空间大小知道不？说说这8种基本数据类型对应的包装类型。",charIndex:11},{level:2,title:"包装类型的常量池技术了解么",slug:"包装类型的常量池技术了解么",normalizedTitle:"包装类型的常量池技术了解么",charIndex:623},{level:2,title:"为什么要有包装类型",slug:"为什么要有包装类型",normalizedTitle:"为什么要有包装类型",charIndex:872},{level:2,title:"什么是自动拆装箱？原理？",slug:"什么是自动拆装箱-原理",normalizedTitle:"什么是自动拆装箱？原理？",charIndex:1353},{level:2,title:"遇见过自动拆装引发的NPE问题吗",slug:"遇见过自动拆装引发的npe问题吗",normalizedTitle:"遇见过自动拆装引发的npe问题吗",charIndex:1492},{level:1,title:"面向对象",slug:"面向对象",normalizedTitle:"面向对象",charIndex:899},{level:2,title:"String、StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?",slug:"string、stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的",normalizedTitle:"string、stringbuffer 和 stringbuilder 的区别是什么? string 为什么是不可变的?",charIndex:1680},{level:2,title:"重载和重写的区别？",slug:"重载和重写的区别",normalizedTitle:"重载和重写的区别？",charIndex:2083},{level:2,title:"== 和 equals() 的区别",slug:"和-equals-的区别",normalizedTitle:"== 和 equals() 的区别",charIndex:2382},{level:2,title:"深拷贝和浅拷贝区别了解吗？什么是引用拷贝？",slug:"深拷贝和浅拷贝区别了解吗-什么是引用拷贝",normalizedTitle:"深拷贝和浅拷贝区别了解吗？什么是引用拷贝？",charIndex:2716},{level:2,title:"接口和抽象类有什么共同点和区别？如何选择？",slug:"接口和抽象类有什么共同点和区别-如何选择",normalizedTitle:"接口和抽象类有什么共同点和区别？如何选择？",charIndex:2913},{level:1,title:"反射&注解&泛型",slug:"反射-注解-泛型",normalizedTitle:"反射&amp;注解&amp;泛型",charIndex:null},{level:2,title:"Java 反射？反射有什么优点/缺点？你是怎么理解反射的（为什么框架需要反射）？",slug:"java-反射-反射有什么优点-缺点-你是怎么理解反射的-为什么框架需要反射",normalizedTitle:"java 反射？反射有什么优点/缺点？你是怎么理解反射的（为什么框架需要反射）？",charIndex:3220},{level:2,title:"Java 泛型了解么？泛型的作用？什么是类型擦除？泛型有哪些限制？介绍一下常用的通配符？",slug:"java-泛型了解么-泛型的作用-什么是类型擦除-泛型有哪些限制-介绍一下常用的通配符",normalizedTitle:"java 泛型了解么？泛型的作用？什么是类型擦除？泛型有哪些限制？介绍一下常用的通配符？",charIndex:3523},{level:1,title:"SPI",slug:"spi",normalizedTitle:"spi",charIndex:3725},{level:2,title:"什么是SPI？有什么用？",slug:"什么是spi-有什么用",normalizedTitle:"什么是spi？有什么用？",charIndex:3733},{level:2,title:"SPI和API有什么区别",slug:"spi和api有什么区别",normalizedTitle:"spi和api有什么区别",charIndex:3982}],headersStr:"数据类型 Java 中有哪8中基本数据类型?它们的默认值和占用空间大小知道不？说说这8种基本数据类型对应的包装类型。 包装类型的常量池技术了解么 为什么要有包装类型 什么是自动拆装箱？原理？ 遇见过自动拆装引发的NPE问题吗 面向对象 String、StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的? 重载和重写的区别？ == 和 equals() 的区别 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？ 接口和抽象类有什么共同点和区别？如何选择？ 反射&注解&泛型 Java 反射？反射有什么优点/缺点？你是怎么理解反射的（为什么框架需要反射）？ Java 泛型了解么？泛型的作用？什么是类型擦除？泛型有哪些限制？介绍一下常用的通配符？ SPI 什么是SPI？有什么用？ SPI和API有什么区别",content:"# 数据类型\n\n\n# Java 中有哪8中基本数据类型?它们的默认值和占用空间大小知道不？说说这8种基本数据类型对应的包装类型。\n\nJava 中有 8 种基本数据类型，分别为：\n\n * 6 种数字类型：\n   * 4 种整数型：byte、short、int、long\n   * 2 种浮点型：float、double\n * 1 种字符类型：char\n * 1 种布尔型：boolean。\n\n这 8 种基本数据类型的默认值以及所占空间的大小如下：\n\n| 基本类型\n\n| 位数\n\n| 字节\n\n| 默认值\n\n\nint\n\n| 32\n\n| 4\n\n| 0\n\n| | short\n\n| 16\n\n| 2\n\n| 0\n\n| | long\n\n| 64\n\n| 8\n\n| 0L\n\n| | byte\n\n| 8\n\n| 1\n\n| 0\n\n| | char\n\n| 16\n\n| 2\n\n| 'u0000'\n\n| | float\n\n| 32\n\n| 4\n\n| 0f\n\n| | double\n\n| 64\n\n| 8\n\n| 0d\n\n| | boolean\n\n| 1\n\n| | false\n\n|\n\n对于 boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。 这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean 。\n\n\n# 包装类型的常量池技术了解么\n\nJava 基本类型的包装类的大部分都实现了常量池技术。 Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。 如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。 两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。\n\n\n# 为什么要有包装类型\n\nJava 本身就是一门 OOP（面向对象编程）语言，对象可以说是 Java 的灵魂。 除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。比如：\n\n * 假如你有一个对象中的属性使用了 基本类型，那这个属性就必然存在默认值了。这个逻辑不正确的！因为很多业务场景下，对象的某些属性没有赋值，我就希望它的值为 null。你给我默认赋个值，不是帮倒忙么？\n * 另外，像泛型参数不能是基本类型。因为基本类型不是 Object 子类，应该用基本类型对应的包装类型代替。我们直接拿 JDK 中线程的代码举例。\n * Java 中的集合在定义类型的时候不能使用基本类型的。比如：\n\npublic class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable  {\n    \n}\n\nMap<Integer, Set<String>> map = new HashMap<>();\n\n\n\n# 什么是自动拆装箱？原理？\n\nJava 中的集合在定义类型的时候不能使用基本类型的。比如：\n\nInteger i = 10; //装箱\nint n = i; //拆箱\n\n\n装箱其实就是调用了 包装类的valueOf()方法，拆箱其实就是调用了 xxxValue()方法。\n\n\n# 遇见过自动拆装引发的NPE问题吗\n\n两种常见的场景：\n\n 1. 数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。因为拆箱其实就是调用了xxxValue()方法，一个null调用方法就会有NPE。\n 2. 三目运算符condition？表达式1:表达式2中，表达式1和2在类型对齐时，可能抛出因自动拆箱导致的NPE异常。\n\n\n# 面向对象\n\n\n# String、StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?\n\n区别：\n\n * **可变性：**String 不可变，StringBuffer和StringBuilder可变。\n * **线程安全性：**String 不可变，线程安全。StringBuffer 对方法或者对调用的方法加了同步锁，也是线程安全。StringBuilder 没有对方法加同步锁，所以是非线程安全的。\n * **性能：**StringBuilder >StringBuffer >String\n\nString 真正不可变有下面几点原因：\n\n 1. 保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。\n 2. String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。\n\n\n# 重载和重写的区别？\n\n重载就是同样的⼀个⽅法能够根据输⼊数据的不同，做出不同的处理。 重写就是当⼦类继承自父类的相同方法，输⼊数据⼀样，但要做出有别于父类的响应时，你就 要覆盖父类方法 区别：\n\n区别点     重载方法   重写方法\n发生范围    同一个类   子类\n参数列表    必须修改   一定不能修改\n返回类型    可修改    子类返回值类型应比父类方法返回值更小或相等\n异常      可修改    子类方法声明抛出异常类应比父类方法声明抛出的异常类更小或相等\n访问修饰符   可修改    一定不能做更严格的限制（可以降低限制）\n发生阶段    编译期    运行期\n\n\n# == 和 equals() 的区别\n\n== 对于基本类型和引用类型的作用效果是不同的：\n\n * 对于基本数据类型来说，==比较的是值。\n * 对于引用数据类型来说，==比较的是对象的内存地址\n\nequals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals() 方法存在两种使用情况：\n\n * 类没有重写 equals()方法 ：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法。\n * 类重写了 equals()方法 ：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。\n\n\n# 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？\n\n深拷贝和浅拷贝区别：\n\n * 浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。\n * 深拷贝 ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。\n\n引用拷贝就是两个不同的引用指向同一个对象。\n\n\n\n# 接口和抽象类有什么共同点和区别？如何选择？\n\n共同点 ：\n\n * 都不能被实例化。\n * 都可以包含抽象方法。\n * 都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。\n\n区别 ：\n\n * 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。\n * 一个类只能继承一个类，但是可以实现多个接口。\n * 接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。\n\n\n# 反射&注解&泛型\n\n\n# Java 反射？反射有什么优点/缺点？你是怎么理解反射的（为什么框架需要反射）？\n\n反射赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。 反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点。 像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。\n\n\n# Java 泛型了解么？泛型的作用？什么是类型擦除？泛型有哪些限制？介绍一下常用的通配符？\n\nJava 泛型（Generics） 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。 Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。\n\n\n# SPI\n\n\n# 什么是SPI？有什么用？\n\nSPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。 SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。 很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。\n\n\n# SPI和API有什么区别\n\n一般模块之间都是通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。 API：当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。 SPI：当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。",normalizedContent:"# 数据类型\n\n\n# java 中有哪8中基本数据类型?它们的默认值和占用空间大小知道不？说说这8种基本数据类型对应的包装类型。\n\njava 中有 8 种基本数据类型，分别为：\n\n * 6 种数字类型：\n   * 4 种整数型：byte、short、int、long\n   * 2 种浮点型：float、double\n * 1 种字符类型：char\n * 1 种布尔型：boolean。\n\n这 8 种基本数据类型的默认值以及所占空间的大小如下：\n\n| 基本类型\n\n| 位数\n\n| 字节\n\n| 默认值\n\n\nint\n\n| 32\n\n| 4\n\n| 0\n\n| | short\n\n| 16\n\n| 2\n\n| 0\n\n| | long\n\n| 64\n\n| 8\n\n| 0l\n\n| | byte\n\n| 8\n\n| 1\n\n| 0\n\n| | char\n\n| 16\n\n| 2\n\n| 'u0000'\n\n| | float\n\n| 32\n\n| 4\n\n| 0f\n\n| | double\n\n| 64\n\n| 8\n\n| 0d\n\n| | boolean\n\n| 1\n\n| | false\n\n|\n\n对于 boolean，官方文档未明确定义，它依赖于 jvm 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。 这八种基本类型都有对应的包装类分别为：byte、short、integer、long、float、double、character、boolean 。\n\n\n# 包装类型的常量池技术了解么\n\njava 基本类型的包装类的大部分都实现了常量池技术。 byte,short,integer,long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，character 创建了数值在[0,127]范围的缓存数据，boolean 直接返回 true or false。 如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。 两种浮点数类型的包装类 float,double 并没有实现常量池技术。\n\n\n# 为什么要有包装类型\n\njava 本身就是一门 oop（面向对象编程）语言，对象可以说是 java 的灵魂。 除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。比如：\n\n * 假如你有一个对象中的属性使用了 基本类型，那这个属性就必然存在默认值了。这个逻辑不正确的！因为很多业务场景下，对象的某些属性没有赋值，我就希望它的值为 null。你给我默认赋个值，不是帮倒忙么？\n * 另外，像泛型参数不能是基本类型。因为基本类型不是 object 子类，应该用基本类型对应的包装类型代替。我们直接拿 jdk 中线程的代码举例。\n * java 中的集合在定义类型的时候不能使用基本类型的。比如：\n\npublic class hashmap<k,v> extends abstractmap<k,v> implements map<k,v>, cloneable, serializable  {\n    \n}\n\nmap<integer, set<string>> map = new hashmap<>();\n\n\n\n# 什么是自动拆装箱？原理？\n\njava 中的集合在定义类型的时候不能使用基本类型的。比如：\n\ninteger i = 10; //装箱\nint n = i; //拆箱\n\n\n装箱其实就是调用了 包装类的valueof()方法，拆箱其实就是调用了 xxxvalue()方法。\n\n\n# 遇见过自动拆装引发的npe问题吗\n\n两种常见的场景：\n\n 1. 数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有npe风险。因为拆箱其实就是调用了xxxvalue()方法，一个null调用方法就会有npe。\n 2. 三目运算符condition？表达式1:表达式2中，表达式1和2在类型对齐时，可能抛出因自动拆箱导致的npe异常。\n\n\n# 面向对象\n\n\n# string、stringbuffer 和 stringbuilder 的区别是什么? string 为什么是不可变的?\n\n区别：\n\n * **可变性：**string 不可变，stringbuffer和stringbuilder可变。\n * **线程安全性：**string 不可变，线程安全。stringbuffer 对方法或者对调用的方法加了同步锁，也是线程安全。stringbuilder 没有对方法加同步锁，所以是非线程安全的。\n * **性能：**stringbuilder >stringbuffer >string\n\nstring 真正不可变有下面几点原因：\n\n 1. 保存字符串的数组被 final 修饰且为私有的，并且string 类没有提供/暴露修改这个字符串的方法。\n 2. string 类被 final 修饰导致其不能被继承，进而避免了子类破坏 string 不可变。\n\n\n# 重载和重写的区别？\n\n重载就是同样的⼀个⽅法能够根据输⼊数据的不同，做出不同的处理。 重写就是当⼦类继承自父类的相同方法，输⼊数据⼀样，但要做出有别于父类的响应时，你就 要覆盖父类方法 区别：\n\n区别点     重载方法   重写方法\n发生范围    同一个类   子类\n参数列表    必须修改   一定不能修改\n返回类型    可修改    子类返回值类型应比父类方法返回值更小或相等\n异常      可修改    子类方法声明抛出异常类应比父类方法声明抛出的异常类更小或相等\n访问修饰符   可修改    一定不能做更严格的限制（可以降低限制）\n发生阶段    编译期    运行期\n\n\n# == 和 equals() 的区别\n\n== 对于基本类型和引用类型的作用效果是不同的：\n\n * 对于基本数据类型来说，==比较的是值。\n * 对于引用数据类型来说，==比较的是对象的内存地址\n\nequals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals() 方法存在两种使用情况：\n\n * 类没有重写 equals()方法 ：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 object类equals()方法。\n * 类重写了 equals()方法 ：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。\n\n\n# 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？\n\n深拷贝和浅拷贝区别：\n\n * 浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。\n * 深拷贝 ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。\n\n引用拷贝就是两个不同的引用指向同一个对象。\n\n\n\n# 接口和抽象类有什么共同点和区别？如何选择？\n\n共同点 ：\n\n * 都不能被实例化。\n * 都可以包含抽象方法。\n * 都可以有默认实现的方法（java 8 可以用 default 关键字在接口中定义默认方法）。\n\n区别 ：\n\n * 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。\n * 一个类只能继承一个类，但是可以实现多个接口。\n * 接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。\n\n\n# 反射&注解&泛型\n\n\n# java 反射？反射有什么优点/缺点？你是怎么理解反射的（为什么框架需要反射）？\n\n反射赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。 反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点。 像 spring/spring boot、mybatis 等等框架中都大量使用了反射机制这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。\n\n\n# java 泛型了解么？泛型的作用？什么是类型擦除？泛型有哪些限制？介绍一下常用的通配符？\n\njava 泛型（generics） 是 jdk 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。 java 的泛型是伪泛型，这是因为 java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。\n\n\n# spi\n\n\n# 什么是spi？有什么用？\n\nspi 即 service provider interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。 spi 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。 很多框架都使用了 java 的 spi 机制，比如：spring 框架、数据库加载驱动、日志接口、以及 dubbo 的扩展实现等等。\n\n\n# spi和api有什么区别\n\n一般模块之间都是通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。 api：当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 api ，这种接口和实现都是放在实现方的。 spi：当接口存在于调用方这边时，就是 spi ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。",charsets:{cjk:!0},lastUpdated:"2023/10/24, 07:59:40",lastUpdatedTimestamp:169813438e4},{title:"Java 并发面试题",frontmatter:{title:"Java 并发面试题",date:"2023-10-24T15:37:53.000Z",permalink:"/pages/f4f268/"},regularPath:"/02.Java%20%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%20%E5%85%AB%E8%82%A1%E6%96%87/03.Java%20%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98.html",relativePath:"02.Java 面试宝典/02.Java 八股文/03.Java 并发面试题.md",key:"v-74c22a5e",path:"/pages/f4f268/",headers:[{level:1,title:"",slug:"",normalizedTitle:"",charIndex:0},{level:1,title:"基础",slug:"基础",normalizedTitle:"基础",charIndex:6},{level:2,title:"什么是线程和进程？线程与进程的关系，区别及优缺点？",slug:"什么是线程和进程-线程与进程的关系-区别及优缺点",normalizedTitle:"什么是线程和进程？线程与进程的关系，区别及优缺点？",charIndex:13},{level:2,title:"为什么要使用多线程呢",slug:"为什么要使用多线程呢",normalizedTitle:"为什么要使用多线程呢",charIndex:256},{level:2,title:"说说线程的生命周期和状态",slug:"说说线程的生命周期和状态",normalizedTitle:"说说线程的生命周期和状态",charIndex:462},{level:1,title:"Java 中有哪些锁？",slug:"java-中有哪些锁",normalizedTitle:"java 中有哪些锁？",charIndex:806},{level:2,title:"什么是线程死锁？如何预防和避免线程死锁",slug:"什么是线程死锁-如何预防和避免线程死锁",normalizedTitle:"什么是线程死锁？如何预防和避免线程死锁",charIndex:910},{level:1,title:"乐观锁和悲观锁",slug:"乐观锁和悲观锁",normalizedTitle:"乐观锁和悲观锁",charIndex:1334},{level:2,title:"乐观锁和悲观锁的区别",slug:"乐观锁和悲观锁的区别",normalizedTitle:"乐观锁和悲观锁的区别",charIndex:1346},{level:2,title:"如何实现乐观锁",slug:"如何实现乐观锁",normalizedTitle:"如何实现乐观锁",charIndex:1454},{level:2,title:"CAS了解么？原理？",slug:"cas了解么-原理",normalizedTitle:"cas了解么？原理？",charIndex:1507},{level:2,title:"乐观锁存在哪些问题",slug:"乐观锁存在哪些问题",normalizedTitle:"乐观锁存在哪些问题",charIndex:2177},{level:2,title:"什么是ABA问题？ABA问题怎么解决",slug:"什么是aba问题-aba问题怎么解决",normalizedTitle:"什么是aba问题？aba问题怎么解决",charIndex:2538},{level:1,title:"JMM",slug:"jmm",normalizedTitle:"jmm",charIndex:2757},{level:2,title:"并发编程的三个重要特性",slug:"并发编程的三个重要特性",normalizedTitle:"并发编程的三个重要特性",charIndex:2765},{level:2,title:"什么是JMM？为什么需要JMM",slug:"什么是jmm-为什么需要jmm",normalizedTitle:"什么是jmm？为什么需要jmm",charIndex:3302},{level:2,title:"JMM是如何抽象线程和主内存之间的关系？",slug:"jmm是如何抽象线程和主内存之间的关系",normalizedTitle:"jmm是如何抽象线程和主内存之间的关系？",charIndex:3724},{level:2,title:"Java内存区域和JMM有何区别",slug:"java内存区域和jmm有何区别",normalizedTitle:"java内存区域和jmm有何区别",charIndex:3821},{level:2,title:"happens-before原则是什么？为什么需要happens-before原则",slug:"happens-before原则是什么-为什么需要happens-before原则",normalizedTitle:"happens-before原则是什么？为什么需要happens-before原则",charIndex:4081},{level:1,title:"synchronized 关键字",slug:"synchronized-关键字",normalizedTitle:"synchronized 关键字",charIndex:4300},{level:2,title:"synchronized 关键字的作用，自己是怎么使用的。",slug:"synchronized-关键字的作用-自己是怎么使用的。",normalizedTitle:"synchronized 关键字的作用，自己是怎么使用的。",charIndex:4321},{level:2,title:"synchronized 关键字的底层原理",slug:"synchronized-关键字的底层原理",normalizedTitle:"synchronized 关键字的底层原理",charIndex:4813},{level:2,title:"JDK1.6 之后 synchronized 关键字底层做了哪些优化。synchronized 锁升级流程。",slug:"jdk1-6-之后-synchronized-关键字底层做了哪些优化。synchronized-锁升级流程。",normalizedTitle:"jdk1.6 之后 synchronized 关键字底层做了哪些优化。synchronized 锁升级流程。",charIndex:5086},{level:2,title:"synchronized 和 ReentranLock 的区别",slug:"synchronized-和-reentranlock-的区别",normalizedTitle:"synchronized 和 reentranlock 的区别",charIndex:5352},{level:2,title:"synchronized 和 volatile 的区别",slug:"synchronized-和-volatile-的区别",normalizedTitle:"synchronized 和 volatile 的区别",charIndex:5659},{level:1,title:"volatile关键字",slug:"volatile关键字",normalizedTitle:"volatile关键字",charIndex:5917},{level:2,title:"volatile 关键字如何保证变量的可见性",slug:"volatile-关键字如何保证变量的可见性",normalizedTitle:"volatile 关键字如何保证变量的可见性",charIndex:6006},{level:2,title:"volatile 如何禁止指令重排序",slug:"volatile-如何禁止指令重排序",normalizedTitle:"volatile 如何禁止指令重排序",charIndex:6183},{level:2,title:"volatile 可以保证原子性么",slug:"volatile-可以保证原子性么",normalizedTitle:"volatile 可以保证原子性么",charIndex:6482},{level:1,title:"ThreadLocal",slug:"threadlocal",normalizedTitle:"threadlocal",charIndex:6545},{level:2,title:"ThreadLocal 有什么用",slug:"threadlocal-有什么用",normalizedTitle:"threadlocal 有什么用",charIndex:6561},{level:2,title:"如何使用 ThreadLocal",slug:"如何使用-threadlocal",normalizedTitle:"如何使用 threadlocal",charIndex:6997},{level:2,title:"ThreadLocal 原理了解吗",slug:"threadlocal-原理了解吗",normalizedTitle:"threadlocal 原理了解吗",charIndex:9234},{level:2,title:"ThreadLocal 内存泄露问题是怎么导致的？",slug:"threadlocal-内存泄露问题是怎么导致的",normalizedTitle:"threadlocal 内存泄露问题是怎么导致的？",charIndex:10764},{level:1,title:"线程池",slug:"线程池",normalizedTitle:"线程池",charIndex:11123},{level:2,title:"什么是线程池",slug:"什么是线程池",normalizedTitle:"什么是线程池",charIndex:11131},{level:2,title:"为什么要用线程池",slug:"为什么要用线程池",normalizedTitle:"为什么要用线程池",charIndex:11216},{level:2,title:"如何创建线程池",slug:"如何创建线程池",normalizedTitle:"如何创建线程池",charIndex:11532},{level:2,title:"线程池常见参数有哪些？如何解释？",slug:"线程池常见参数有哪些-如何解释",normalizedTitle:"线程池常见参数有哪些？如何解释？",charIndex:12117},{level:2,title:"线程池的饱和策略有哪些",slug:"线程池的饱和策略有哪些",normalizedTitle:"线程池的饱和策略有哪些",charIndex:13785},{level:2,title:"线程池的执行流程",slug:"线程池的执行流程",normalizedTitle:"线程池的执行流程",charIndex:14625},{level:2,title:"如何设定线程池的大小",slug:"如何设定线程池的大小",normalizedTitle:"如何设定线程池的大小",charIndex:14912},{level:1,title:"AQS",slug:"aqs",normalizedTitle:"aqs",charIndex:15495},{level:2,title:"AQS 是什么？",slug:"aqs-是什么",normalizedTitle:"aqs 是什么？",charIndex:15503},{level:2,title:"AQS的原理是什么",slug:"aqs的原理是什么",normalizedTitle:"aqs的原理是什么",charIndex:15906}],headersStr:" 基础 什么是线程和进程？线程与进程的关系，区别及优缺点？ 为什么要使用多线程呢 说说线程的生命周期和状态 Java 中有哪些锁？ 什么是线程死锁？如何预防和避免线程死锁 乐观锁和悲观锁 乐观锁和悲观锁的区别 如何实现乐观锁 CAS了解么？原理？ 乐观锁存在哪些问题 什么是ABA问题？ABA问题怎么解决 JMM 并发编程的三个重要特性 什么是JMM？为什么需要JMM JMM是如何抽象线程和主内存之间的关系？ Java内存区域和JMM有何区别 happens-before原则是什么？为什么需要happens-before原则 synchronized 关键字 synchronized 关键字的作用，自己是怎么使用的。 synchronized 关键字的底层原理 JDK1.6 之后 synchronized 关键字底层做了哪些优化。synchronized 锁升级流程。 synchronized 和 ReentranLock 的区别 synchronized 和 volatile 的区别 volatile关键字 volatile 关键字如何保证变量的可见性 volatile 如何禁止指令重排序 volatile 可以保证原子性么 ThreadLocal ThreadLocal 有什么用 如何使用 ThreadLocal ThreadLocal 原理了解吗 ThreadLocal 内存泄露问题是怎么导致的？ 线程池 什么是线程池 为什么要用线程池 如何创建线程池 线程池常见参数有哪些？如何解释？ 线程池的饱和策略有哪些 线程池的执行流程 如何设定线程池的大小 AQS AQS 是什么？ AQS的原理是什么",content:'#\n\n\n# 基础\n\n\n# 什么是线程和进程？线程与进程的关系，区别及优缺点？\n\n进程是程序的一次执行过程，是系统运行程序的基本单位。系统运行一个程序就是一个进程从创建，运行到消亡的过程。线程是一个进程更小的执行单位。一个进程在执行过程中可以产生多个线程。 多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。\n进程是独立的，而线程则不一定，因为同一进程中线程可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。\n\n\n# 为什么要使用多线程呢\n\n * 从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。\n * 从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。\n\n\n# 说说线程的生命周期和状态\n\nJava 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：\n\n * NEW: 初始状态，线程被创建出来但没有被调用 start() 。\n * RUNNABLE: 运行状态，线程被调用了 start()等待运行的状态。\n * BLOCKED ：阻塞状态，需要等待锁释放。\n * WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。\n * TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。\n * TERMINATED：终止状态，表示该线程已经运行完毕。\n\n线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。\n\n\n# Java 中有哪些锁？\n\nJava 中锁可以分：\n\n * 悲观锁/乐观锁\n * 共享锁/独占锁\n * 公平锁/非公平锁\n * 可中断锁/非可中断锁\n * 可重入锁/不可重入锁\n * 自旋锁/非自旋锁\n\n\n# 什么是线程死锁？如何预防和避免线程死锁\n\n线程死锁就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期阻塞，因此程序不能正常终止。\n\n产生死锁需要满足四个必要条件：\n\n 1. 互斥条件：该资源任意一个时刻只由一个线程占用。\n 2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。\n 3. 不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。\n 4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。\n\n要避免线程死锁，只要破坏死锁产生的必要条件就可以：\n\n 1. 破坏请求与保持条件 ：一次性申请所有的资源。\n 2. 破坏不剥夺条件 ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。\n 3. 破坏循环等待条件 ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\n\n\n# 乐观锁和悲观锁\n\n\n# 乐观锁和悲观锁的区别\n\n * 乐观锁通常用多于写比较少的情况下（多读场景），避免频繁加锁影响性能，大大提升了系统的吞吐量。\n * 悲观锁通常多用于写多比较多的情况下（多写场景），避免频繁失败和重试影响性能。\n\n\n# 如何实现乐观锁\n\n乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些。\n\n\n# CAS了解么？原理？\n\nCAS 的全称是 Compare And Swap（比较与交换） ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。 CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。 原子操作 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。 CAS 涉及到三个操作数：\n\n * V ：要更新的变量值(Var)\n * E ：预期值(Expected)\n * N ：拟写入的新值(New)\n\n当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。 举一个简单的例子 ：线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6，假设不存在 ABA 问题）。\n\n 1. i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。\n 2. i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。\n\n当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。 Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及 CPU 都有关系。\n\n\n# 乐观锁存在哪些问题\n\n * ABA问题：一个变量V初始值是A，期间被改为其他值，然后又改回A，那么CAS操作就会误认为它从来没被修改过，这就是ABA问题。解决办法是在变量前面追加上版本号和时间戳。\n * 循环时间长开销大： CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。\n * 只能保证一个共享变量的原子操作： CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。\n\n\n# 什么是ABA问题？ABA问题怎么解决\n\nABA问题是乐观锁常见的问题。 如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 "ABA"问题。 ABA 问题的解决思路是在变量前面追加上版本号或者时间戳\n\n\n# JMM\n\n\n# 并发编程的三个重要特性\n\n * 原子性： 一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。 在 Java 中，可以借助synchronized 、各种 Lock 以及各种原子类实现原子性。synchronized 和各种 Lock 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 volatile或者final关键字）来保证原子操作。\n * 可见性：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。在 Java 中，可以借助synchronized 、volatile 以及各种 Lock 实现可见性。如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\n * 有序性：由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致 ，所以在多线程下，指令重排序可能会导致一些问题。 在 Java 中，volatile 关键字可以禁止指令进行重排序优化。\n\n\n# 什么是JMM？为什么需要JMM\n\nJMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。 为什么要遵守这些并发相关的原则和规范呢？ 这是因为并发编程下，像 CPU 多级缓存和指令重排这类设计可能会导致程序运行出现一些问题。就比如说我们上面提到的指令重排序就可能会让多线程程序的执行出现问题，为此，JMM 抽象了 happens-before 原则来解决这个指令重排序问题。 JMM 说白了就是定义了一些规范来解决这些问题，开发者可以利用这些规范更方便地开发多线程程序。对于 Java 开发者说，你不需要了解底层原理，直接使用并发相关的一些关键字和类（比如 volatile、synchronized、各种 Lock）即可开发出并发安全的程序。\n\n\n# JMM是如何抽象线程和主内存之间的关系？\n\nJava 内存模型（JMM） 抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中， 为共享变量提供了可见性的保障 。\n\n\n# Java内存区域和JMM有何区别\n\nJava 内存区域和内存模型是完全不一样的两个东西 ：\n\n * JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。\n * Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。\n\n\n# happens-before原则是什么？为什么需要happens-before原则\n\n逻辑时钟并不度量时间本身，仅区分事件发生的前后顺序，其本质就是定义了一种 happens-before 关系。 happens-before 原则的诞生是为了程序员和编译器、处理器之间的平衡。程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可。编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化。\n\n\n# synchronized 关键字\n\n\n# synchronized 关键字的作用，自己是怎么使用的。\n\nsynchronized是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 在 Java 早期版本中，synchronized属于 重量级锁，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。 不过，在 Java 6 之后， synchronized引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 synchronized 锁的效率提升了很多。因此， synchronized 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 synchronized\n\n\n# synchronized 关键字的底层原理\n\nsynchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。 不过两者的本质都是对对象监视器 monitor 的获取。\n\n\n# JDK1.6 之后 synchronized 关键字底层做了哪些优化。synchronized 锁升级流程。\n\nDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。 锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。\n\n> 参考：https://www.cnblogs.com/wuqinglong/p/9945618.html\n\n\n# synchronized 和 ReentranLock 的区别\n\n * synchronized 依赖于 JVM 实现的，在 JDK1.6 对 synchronized 关键字进行了很多优化，但是这些优化都是基于虚拟机层面实现的。\n\nReentrantLock 是 JDK 实现的，查看源码，可以看到底层是通过lock() 和 unlock() 方法配合 try/finally 语句块来完成\n\n * ReentrantLock 支持中断等待锁的机制，而 synchronized 不支持\n * ReentrantLock 支持公平锁和非公平锁，默认是非公平锁，synchronized 只能是非公平锁。\n\n\n# synchronized 和 volatile 的区别\n\nsynchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在！\n\n * volatile 关键字是线程同步的轻量级实现，所以 volatile性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。\n * volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。\n * volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。\n\n\n# volatile关键字\n\n\n# volatile 关键字如何保证变量的可见性\n\n在 Java 中，volatile 关键字可以保证变量的可见性，如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\nvolatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。\n\n\n# volatile 如何禁止指令重排序\n\n在 Java 中，volatile 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。 如果我们将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。 在 Java 中，Unsafe 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：\n\npublic native void loadFence();\npublic native void storeFence();\npublic native void fullFence();\n\n\n\n\n# volatile 可以保证原子性么\n\nvolatile 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。\n\n\n# ThreadLocal\n\n\n# ThreadLocal 有什么用\n\n通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ JDK 中自带的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。 如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。 再举个简单的例子：两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。\n\n\n# 如何使用 ThreadLocal\n\n下面简单演示一下如何在项目中实际使用 ThreadLocal 。\n\nimport java.text.SimpleDateFormat;\nimport java.util.Random;\n\npublic class ThreadLocalExample implements Runnable{\n\n     // SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本\n    private static final ThreadLocal<SimpleDateFormat> formatter = ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyyMMdd HHmm"));\n\n    public static void main(String[] args) throws InterruptedException {\n        ThreadLocalExample obj = new ThreadLocalExample();\n        for(int i=0 ; i<10; i++){\n            Thread t = new Thread(obj, ""+i);\n            Thread.sleep(new Random().nextInt(1000));\n            t.start();\n        }\n    }\n\n    @Override\n    public void run() {\n        System.out.println("Thread Name= "+Thread.currentThread().getName()+" default Formatter = "+formatter.get().toPattern());\n        try {\n            Thread.sleep(new Random().nextInt(1000));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //formatter pattern is changed here by thread, but it won\'t reflect to other threads\n        formatter.set(new SimpleDateFormat());\n\n        System.out.println("Thread Name= "+Thread.currentThread().getName()+" formatter = "+formatter.get().toPattern());\n    }\n\n}\n\n\n\n\n输出结果：\n\nThread Name= 0 default Formatter = yyyyMMdd HHmm\nThread Name= 0 formatter = yy-M-d ah:mm\nThread Name= 1 default Formatter = yyyyMMdd HHmm\nThread Name= 2 default Formatter = yyyyMMdd HHmm\nThread Name= 1 formatter = yy-M-d ah:mm\nThread Name= 3 default Formatter = yyyyMMdd HHmm\nThread Name= 2 formatter = yy-M-d ah:mm\nThread Name= 4 default Formatter = yyyyMMdd HHmm\nThread Name= 3 formatter = yy-M-d ah:mm\nThread Name= 4 formatter = yy-M-d ah:mm\nThread Name= 5 default Formatter = yyyyMMdd HHmm\nThread Name= 5 formatter = yy-M-d ah:mm\nThread Name= 6 default Formatter = yyyyMMdd HHmm\nThread Name= 6 formatter = yy-M-d ah:mm\nThread Name= 7 default Formatter = yyyyMMdd HHmm\nThread Name= 7 formatter = yy-M-d ah:mm\nThread Name= 8 default Formatter = yyyyMMdd HHmm\nThread Name= 9 default Formatter = yyyyMMdd HHmm\nThread Name= 8 formatter = yy-M-d ah:mm\nThread Name= 9 formatter = yy-M-d ah:mm\n\n\n\n从输出中可以看出，虽然 Thread-0 已经改变了 formatter 的值，但 Thread-1 默认格式化值与初始化值相同，其他线程也一样。\n\n\n# ThreadLocal 原理了解吗\n\n从 Thread类源代码入手。\n\npublic class Thread implements Runnable {\n    //......\n    //与此线程有关的ThreadLocal值。由ThreadLocal类维护\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n\n    //与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护\n    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;\n    //......\n}\n\n\n\n从上面Thread类 源代码可以看出Thread 类中有一个 threadLocals 和 一个 inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量,我们可以把 ThreadLocalMap 理解为ThreadLocal 类实现的定制化的 HashMap。默认情况下这两个变量都是 null，只有当前线程调用 ThreadLocal 类的 set或get方法时才创建它们，实际上调用这两个方法的时候，我们调用的是ThreadLocalMap类对应的 get()、set()方法。 ThreadLocal类的set()方法\n\npublic void set(T value) {\n    //获取当前请求的线程\n    Thread t = Thread.currentThread();\n    //取出 Thread 类内部的 threadLocals 变量(哈希表结构)\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        // 将需要存储的值放入到这个哈希表中\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n\n\n\n通过上面这些内容，我们足以通过猜测得出结论：**最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。**ThrealLocal 类中可以通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread t)可以访问到该线程的ThreadLocalMap对象。 每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。\n\nThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {\n    //......\n}\n\n\n\n比如我们在同一个线程中声明了两个 ThreadLocal 对象的话， Thread内部都是使用仅有的那个ThreadLocalMap 存放数据的，ThreadLocalMap的 key 就是 ThreadLocal对象，value 就是 ThreadLocal 对象调用set方法设置的值。 ThreadLocal 数据结构如下图所示：\n\n\n# ThreadLocal 内存泄露问题是怎么导致的？\n\nThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。 这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法\n\n\n# 线程池\n\n\n# 什么是线程池\n\n顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。\n\n\n# 为什么要用线程池\n\n池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。 线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。 使用线程池的好处：\n\n * 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n * 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。\n * 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\n\n\n# 如何创建线程池\n\n方式一：通过**ThreadPoolExecutor**构造函数来创建（推荐）。\n\n方式二：通过 **Executor** 框架的工具类 **Executors** 来创建。\n\n我们可以创建多种类型的 ThreadPoolExecutor：\n\n * FixedThreadPool ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。\n * SingleThreadExecutor： 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。\n * CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。\n * ScheduledThreadPool ：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。\n\n对应 Executors 工具类中的方法如图所示：\n\n\n# 线程池常见参数有哪些？如何解释？\n\n    /**\n     * 用给定的初始参数创建一个新的ThreadPoolExecutor。\n     */\n    public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量\n                              int maximumPoolSize,//线程池的最大线程数\n                              long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间\n                              TimeUnit unit,//时间单位\n                              BlockingQueue<Runnable> workQueue,//任务队列，用来储存等待执行任务的队列\n                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可\n                              RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务\n                               ) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n\n\n\nThreadPoolExecutor 3 个最重要的参数：\n\n * corePoolSize : 任务队列未达到队列容量时，最大可以同时运行的线程数量。\n * maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。\n * workQueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。\n\nThreadPoolExecutor其他常见参数 :\n\n * keepAliveTime:线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；\n * unit : keepAliveTime 参数的时间单位。\n * threadFactory :executor 创建新线程的时候会用到。\n * handler :饱和策略。关于饱和策略下面单独介绍一下。\n\n\n# 线程池的饱和策略有哪些\n\n如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，ThreadPoolTaskExecutor 定义一些策略:\n\n * ThreadPoolExecutor.AbortPolicy： 抛出 RejectedExecutionException来拒绝新任务的处理。\n * ThreadPoolExecutor.CallerRunsPolicy： 调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。\n * ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。\n * ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。\n\n举个例子： Spring 通过 ThreadPoolTaskExecutor 或者我们直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，当我们不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 ThreadPoolExecutor 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）\n\n\n# 线程池的执行流程\n\n\n\n 1. 如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。\n 2. 如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。\n 3. 如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。\n 4. 如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用RejectedExecutionHandler.rejectedExecution()方法。\n\n\n# 如何设定线程池的大小\n\n线程池大小设置过大或者过小都会有问题，合适的才是最好。\n\n * 如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的，CPU 根本没有得到充分利用。\n * 如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。\n\n有一个简单并且适用面比较广的公式：\n\n * CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。\n * I/O 密集型任务(2N)： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。\n\n\n# AQS\n\n\n# AQS 是什么？\n\nAQS 的全称为 AbstractQueuedSynchronizer ，翻译过来的意思就是抽象队列同步器。这个类在 java.util.concurrent.locks 包下面。\nAQS 就是一个抽象类，主要用来构建锁和同步器\n\npublic abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable {\n}\n\n\n\nAQS 为构建锁和同步器提供了一些通用功能的是实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue等等皆是基于 AQS 的。\n\n\n# AQS的原理是什么\n\nAQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁 实现的，即将暂时获取不到锁的线程加入到队列中。',normalizedContent:'#\n\n\n# 基础\n\n\n# 什么是线程和进程？线程与进程的关系，区别及优缺点？\n\n进程是程序的一次执行过程，是系统运行程序的基本单位。系统运行一个程序就是一个进程从创建，运行到消亡的过程。线程是一个进程更小的执行单位。一个进程在执行过程中可以产生多个线程。 多个线程共享进程的堆和方法区 (jdk1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。\n进程是独立的，而线程则不一定，因为同一进程中线程可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。\n\n\n# 为什么要使用多线程呢\n\n * 从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 cpu 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。\n * 从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。\n\n\n# 说说线程的生命周期和状态\n\njava 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：\n\n * new: 初始状态，线程被创建出来但没有被调用 start() 。\n * runnable: 运行状态，线程被调用了 start()等待运行的状态。\n * blocked ：阻塞状态，需要等待锁释放。\n * waiting：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。\n * time_waiting：超时等待状态，可以在指定的时间后自行返回而不是像 waiting 那样一直等待。\n * terminated：终止状态，表示该线程已经运行完毕。\n\n线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。\n\n\n# java 中有哪些锁？\n\njava 中锁可以分：\n\n * 悲观锁/乐观锁\n * 共享锁/独占锁\n * 公平锁/非公平锁\n * 可中断锁/非可中断锁\n * 可重入锁/不可重入锁\n * 自旋锁/非自旋锁\n\n\n# 什么是线程死锁？如何预防和避免线程死锁\n\n线程死锁就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期阻塞，因此程序不能正常终止。\n\n产生死锁需要满足四个必要条件：\n\n 1. 互斥条件：该资源任意一个时刻只由一个线程占用。\n 2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。\n 3. 不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。\n 4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。\n\n要避免线程死锁，只要破坏死锁产生的必要条件就可以：\n\n 1. 破坏请求与保持条件 ：一次性申请所有的资源。\n 2. 破坏不剥夺条件 ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。\n 3. 破坏循环等待条件 ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\n\n\n# 乐观锁和悲观锁\n\n\n# 乐观锁和悲观锁的区别\n\n * 乐观锁通常用多于写比较少的情况下（多读场景），避免频繁加锁影响性能，大大提升了系统的吞吐量。\n * 悲观锁通常多用于写多比较多的情况下（多写场景），避免频繁失败和重试影响性能。\n\n\n# 如何实现乐观锁\n\n乐观锁一般会使用版本号机制或 cas 算法实现，cas 算法相对来说更多一些。\n\n\n# cas了解么？原理？\n\ncas 的全称是 compare and swap（比较与交换） ，用于实现乐观锁，被广泛应用于各大框架中。cas 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。 cas 是一个原子操作，底层依赖于一条 cpu 的原子指令。 原子操作 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。 cas 涉及到三个操作数：\n\n * v ：要更新的变量值(var)\n * e ：预期值(expected)\n * n ：拟写入的新值(new)\n\n当且仅当 v 的值等于 e 时，cas 通过原子方式用新值 n 来更新 v 的值。如果不等，说明已经有其它线程更新了 v，则当前线程放弃更新。 举一个简单的例子 ：线程 a 要修改变量 i 的值为 6，i 原值为 1（v = 1，e=1，n=6，假设不存在 aba 问题）。\n\n 1. i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。\n 2. i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，cas 操作失败。\n\n当多个线程同时使用 cas 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。 java 语言并没有直接实现 cas，cas 相关的实现是通过 c++ 内联汇编的形式实现的（jni 调用）。因此， cas 的具体实现和操作系统以及 cpu 都有关系。\n\n\n# 乐观锁存在哪些问题\n\n * aba问题：一个变量v初始值是a，期间被改为其他值，然后又改回a，那么cas操作就会误认为它从来没被修改过，这就是aba问题。解决办法是在变量前面追加上版本号和时间戳。\n * 循环时间长开销大： cas 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 cpu 带来非常大的执行开销。\n * 只能保证一个共享变量的原子操作： cas 只对单个共享变量有效，当操作涉及跨多个共享变量时 cas 无效。但是从 jdk 1.5 开始，提供了atomicreference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 cas 操作.所以我们可以使用锁或者利用atomicreference类把多个共享变量合并成一个共享变量来操作。\n\n\n# 什么是aba问题？aba问题怎么解决\n\naba问题是乐观锁常见的问题。 如果一个变量 v 初次读取的时候是 a 值，并且在准备赋值的时候检查到它仍然是 a 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 a，那 cas 操作就会误认为它从来没有被修改过。这个问题被称为 cas 操作的 "aba"问题。 aba 问题的解决思路是在变量前面追加上版本号或者时间戳\n\n\n# jmm\n\n\n# 并发编程的三个重要特性\n\n * 原子性： 一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。 在 java 中，可以借助synchronized 、各种 lock 以及各种原子类实现原子性。synchronized 和各种 lock 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 cas (compare and swap) 操作（可能也会用到 volatile或者final关键字）来保证原子操作。\n * 可见性：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。在 java 中，可以借助synchronized 、volatile 以及各种 lock 实现可见性。如果我们将变量声明为 volatile ，这就指示 jvm，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\n * 有序性：由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致 ，所以在多线程下，指令重排序可能会导致一些问题。 在 java 中，volatile 关键字可以禁止指令进行重排序优化。\n\n\n# 什么是jmm？为什么需要jmm\n\njmm 看作是 java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 java 源代码到 cpu 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。 为什么要遵守这些并发相关的原则和规范呢？ 这是因为并发编程下，像 cpu 多级缓存和指令重排这类设计可能会导致程序运行出现一些问题。就比如说我们上面提到的指令重排序就可能会让多线程程序的执行出现问题，为此，jmm 抽象了 happens-before 原则来解决这个指令重排序问题。 jmm 说白了就是定义了一些规范来解决这些问题，开发者可以利用这些规范更方便地开发多线程程序。对于 java 开发者说，你不需要了解底层原理，直接使用并发相关的一些关键字和类（比如 volatile、synchronized、各种 lock）即可开发出并发安全的程序。\n\n\n# jmm是如何抽象线程和主内存之间的关系？\n\njava 内存模型（jmm） 抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中， 为共享变量提供了可见性的保障 。\n\n\n# java内存区域和jmm有何区别\n\njava 内存区域和内存模型是完全不一样的两个东西 ：\n\n * jvm 内存结构和 java 虚拟机的运行时区域相关，定义了 jvm 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。\n * java 内存模型和 java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 java 源代码到 cpu 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。\n\n\n# happens-before原则是什么？为什么需要happens-before原则\n\n逻辑时钟并不度量时间本身，仅区分事件发生的前后顺序，其本质就是定义了一种 happens-before 关系。 happens-before 原则的诞生是为了程序员和编译器、处理器之间的平衡。程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可。编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化。\n\n\n# synchronized 关键字\n\n\n# synchronized 关键字的作用，自己是怎么使用的。\n\nsynchronized是 java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 在 java 早期版本中，synchronized属于 重量级锁，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 mutex lock 来实现的，java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。 不过，在 java 6 之后， synchronized引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 synchronized 锁的效率提升了很多。因此， synchronized 还是可以在实际项目中使用的，像 jdk 源码、很多开源框架都大量使用了 synchronized\n\n\n# synchronized 关键字的底层原理\n\nsynchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 acc_synchronized 标识，该标识指明了该方法是一个同步方法。 不过两者的本质都是对对象监视器 monitor 的获取。\n\n\n# jdk1.6 之后 synchronized 关键字底层做了哪些优化。synchronized 锁升级流程。\n\ndk1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。 锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。\n\n> 参考：https://www.cnblogs.com/wuqinglong/p/9945618.html\n\n\n# synchronized 和 reentranlock 的区别\n\n * synchronized 依赖于 jvm 实现的，在 jdk1.6 对 synchronized 关键字进行了很多优化，但是这些优化都是基于虚拟机层面实现的。\n\nreentrantlock 是 jdk 实现的，查看源码，可以看到底层是通过lock() 和 unlock() 方法配合 try/finally 语句块来完成\n\n * reentrantlock 支持中断等待锁的机制，而 synchronized 不支持\n * reentrantlock 支持公平锁和非公平锁，默认是非公平锁，synchronized 只能是非公平锁。\n\n\n# synchronized 和 volatile 的区别\n\nsynchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在！\n\n * volatile 关键字是线程同步的轻量级实现，所以 volatile性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。\n * volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。\n * volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。\n\n\n# volatile关键字\n\n\n# volatile 关键字如何保证变量的可见性\n\n在 java 中，volatile 关键字可以保证变量的可见性，如果我们将变量声明为 volatile ，这就指示 jvm，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\nvolatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。\n\n\n# volatile 如何禁止指令重排序\n\n在 java 中，volatile 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 jvm 的指令重排序。 如果我们将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。 在 java 中，unsafe 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：\n\npublic native void loadfence();\npublic native void storefence();\npublic native void fullfence();\n\n\n\n\n# volatile 可以保证原子性么\n\nvolatile 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。\n\n\n# threadlocal\n\n\n# threadlocal 有什么用\n\n通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ jdk 中自带的threadlocal类正是为了解决这样的问题。 threadlocal类主要解决的就是让每个线程绑定自己的值，可以将threadlocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。 如果你创建了一个threadlocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是threadlocal变量名的由来。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。 再举个简单的例子：两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 threadlocal 就是用来避免这两个线程竞争的。\n\n\n# 如何使用 threadlocal\n\n下面简单演示一下如何在项目中实际使用 threadlocal 。\n\nimport java.text.simpledateformat;\nimport java.util.random;\n\npublic class threadlocalexample implements runnable{\n\n     // simpledateformat 不是线程安全的，所以每个线程都要有自己独立的副本\n    private static final threadlocal<simpledateformat> formatter = threadlocal.withinitial(() -> new simpledateformat("yyyymmdd hhmm"));\n\n    public static void main(string[] args) throws interruptedexception {\n        threadlocalexample obj = new threadlocalexample();\n        for(int i=0 ; i<10; i++){\n            thread t = new thread(obj, ""+i);\n            thread.sleep(new random().nextint(1000));\n            t.start();\n        }\n    }\n\n    @override\n    public void run() {\n        system.out.println("thread name= "+thread.currentthread().getname()+" default formatter = "+formatter.get().topattern());\n        try {\n            thread.sleep(new random().nextint(1000));\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        //formatter pattern is changed here by thread, but it won\'t reflect to other threads\n        formatter.set(new simpledateformat());\n\n        system.out.println("thread name= "+thread.currentthread().getname()+" formatter = "+formatter.get().topattern());\n    }\n\n}\n\n\n\n\n输出结果：\n\nthread name= 0 default formatter = yyyymmdd hhmm\nthread name= 0 formatter = yy-m-d ah:mm\nthread name= 1 default formatter = yyyymmdd hhmm\nthread name= 2 default formatter = yyyymmdd hhmm\nthread name= 1 formatter = yy-m-d ah:mm\nthread name= 3 default formatter = yyyymmdd hhmm\nthread name= 2 formatter = yy-m-d ah:mm\nthread name= 4 default formatter = yyyymmdd hhmm\nthread name= 3 formatter = yy-m-d ah:mm\nthread name= 4 formatter = yy-m-d ah:mm\nthread name= 5 default formatter = yyyymmdd hhmm\nthread name= 5 formatter = yy-m-d ah:mm\nthread name= 6 default formatter = yyyymmdd hhmm\nthread name= 6 formatter = yy-m-d ah:mm\nthread name= 7 default formatter = yyyymmdd hhmm\nthread name= 7 formatter = yy-m-d ah:mm\nthread name= 8 default formatter = yyyymmdd hhmm\nthread name= 9 default formatter = yyyymmdd hhmm\nthread name= 8 formatter = yy-m-d ah:mm\nthread name= 9 formatter = yy-m-d ah:mm\n\n\n\n从输出中可以看出，虽然 thread-0 已经改变了 formatter 的值，但 thread-1 默认格式化值与初始化值相同，其他线程也一样。\n\n\n# threadlocal 原理了解吗\n\n从 thread类源代码入手。\n\npublic class thread implements runnable {\n    //......\n    //与此线程有关的threadlocal值。由threadlocal类维护\n    threadlocal.threadlocalmap threadlocals = null;\n\n    //与此线程有关的inheritablethreadlocal值。由inheritablethreadlocal类维护\n    threadlocal.threadlocalmap inheritablethreadlocals = null;\n    //......\n}\n\n\n\n从上面thread类 源代码可以看出thread 类中有一个 threadlocals 和 一个 inheritablethreadlocals 变量，它们都是 threadlocalmap 类型的变量,我们可以把 threadlocalmap 理解为threadlocal 类实现的定制化的 hashmap。默认情况下这两个变量都是 null，只有当前线程调用 threadlocal 类的 set或get方法时才创建它们，实际上调用这两个方法的时候，我们调用的是threadlocalmap类对应的 get()、set()方法。 threadlocal类的set()方法\n\npublic void set(t value) {\n    //获取当前请求的线程\n    thread t = thread.currentthread();\n    //取出 thread 类内部的 threadlocals 变量(哈希表结构)\n    threadlocalmap map = getmap(t);\n    if (map != null)\n        // 将需要存储的值放入到这个哈希表中\n        map.set(this, value);\n    else\n        createmap(t, value);\n}\nthreadlocalmap getmap(thread t) {\n    return t.threadlocals;\n}\n\n\n\n通过上面这些内容，我们足以通过猜测得出结论：**最终的变量是放在了当前线程的 threadlocalmap 中，并不是存在 threadlocal 上，threadlocal 可以理解为只是threadlocalmap的封装，传递了变量值。**threallocal 类中可以通过thread.currentthread()获取到当前线程对象后，直接通过getmap(thread t)可以访问到该线程的threadlocalmap对象。 每个thread中都具备一个threadlocalmap，而threadlocalmap可以存储以threadlocal为 key ，object 对象为 value 的键值对。\n\nthreadlocalmap(threadlocal<?> firstkey, object firstvalue) {\n    //......\n}\n\n\n\n比如我们在同一个线程中声明了两个 threadlocal 对象的话， thread内部都是使用仅有的那个threadlocalmap 存放数据的，threadlocalmap的 key 就是 threadlocal对象，value 就是 threadlocal 对象调用set方法设置的值。 threadlocal 数据结构如下图所示：\n\n\n# threadlocal 内存泄露问题是怎么导致的？\n\nthreadlocalmap 中使用的 key 为 threadlocal 的弱引用，而 value 是强引用。所以，如果 threadlocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。 这样一来，threadlocalmap 中就会出现 key 为 null 的 entry。假如我们不做任何措施的话，value 永远无法被 gc 回收，这个时候就可能会产生内存泄露。threadlocalmap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 threadlocal方法后 最好手动调用remove()方法\n\n\n# 线程池\n\n\n# 什么是线程池\n\n顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。\n\n\n# 为什么要用线程池\n\n池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。 线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。 使用线程池的好处：\n\n * 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n * 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。\n * 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\n\n\n# 如何创建线程池\n\n方式一：通过**threadpoolexecutor**构造函数来创建（推荐）。\n\n方式二：通过 **executor** 框架的工具类 **executors** 来创建。\n\n我们可以创建多种类型的 threadpoolexecutor：\n\n * fixedthreadpool ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。\n * singlethreadexecutor： 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。\n * cachedthreadpool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。\n * scheduledthreadpool ：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。\n\n对应 executors 工具类中的方法如图所示：\n\n\n# 线程池常见参数有哪些？如何解释？\n\n    /**\n     * 用给定的初始参数创建一个新的threadpoolexecutor。\n     */\n    public threadpoolexecutor(int corepoolsize,//线程池的核心线程数量\n                              int maximumpoolsize,//线程池的最大线程数\n                              long keepalivetime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间\n                              timeunit unit,//时间单位\n                              blockingqueue<runnable> workqueue,//任务队列，用来储存等待执行任务的队列\n                              threadfactory threadfactory,//线程工厂，用来创建线程，一般默认即可\n                              rejectedexecutionhandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务\n                               ) {\n        if (corepoolsize < 0 ||\n            maximumpoolsize <= 0 ||\n            maximumpoolsize < corepoolsize ||\n            keepalivetime < 0)\n            throw new illegalargumentexception();\n        if (workqueue == null || threadfactory == null || handler == null)\n            throw new nullpointerexception();\n        this.corepoolsize = corepoolsize;\n        this.maximumpoolsize = maximumpoolsize;\n        this.workqueue = workqueue;\n        this.keepalivetime = unit.tonanos(keepalivetime);\n        this.threadfactory = threadfactory;\n        this.handler = handler;\n    }\n\n\n\nthreadpoolexecutor 3 个最重要的参数：\n\n * corepoolsize : 任务队列未达到队列容量时，最大可以同时运行的线程数量。\n * maximumpoolsize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。\n * workqueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。\n\nthreadpoolexecutor其他常见参数 :\n\n * keepalivetime:线程池中的线程数量大于 corepoolsize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepalivetime才会被回收销毁；\n * unit : keepalivetime 参数的时间单位。\n * threadfactory :executor 创建新线程的时候会用到。\n * handler :饱和策略。关于饱和策略下面单独介绍一下。\n\n\n# 线程池的饱和策略有哪些\n\n如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，threadpooltaskexecutor 定义一些策略:\n\n * threadpoolexecutor.abortpolicy： 抛出 rejectedexecutionexception来拒绝新任务的处理。\n * threadpoolexecutor.callerrunspolicy： 调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。\n * threadpoolexecutor.discardpolicy： 不处理新任务，直接丢弃掉。\n * threadpoolexecutor.discardoldestpolicy： 此策略将丢弃最早的未处理的任务请求。\n\n举个例子： spring 通过 threadpooltaskexecutor 或者我们直接通过 threadpoolexecutor 的构造函数创建线程池的时候，当我们不指定 rejectedexecutionhandler 饱和策略的话来配置线程池的时候默认使用的是 threadpoolexecutor.abortpolicy。在默认情况下，threadpoolexecutor 将抛出 rejectedexecutionexception 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 threadpoolexecutor.callerrunspolicy。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 threadpoolexecutor 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）\n\n\n# 线程池的执行流程\n\n\n\n 1. 如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。\n 2. 如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。\n 3. 如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。\n 4. 如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用rejectedexecutionhandler.rejectedexecution()方法。\n\n\n# 如何设定线程池的大小\n\n线程池大小设置过大或者过小都会有问题，合适的才是最好。\n\n * 如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 oom。这样很明显是有问题的，cpu 根本没有得到充分利用。\n * 如果我们设置线程数量太大，大量线程可能会同时在争取 cpu 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。\n\n有一个简单并且适用面比较广的公式：\n\n * cpu 密集型任务(n+1)： 这种任务消耗的主要是 cpu 资源，可以将线程数设置为 n（cpu 核心数）+1。比 cpu 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，cpu 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 cpu 的空闲时间。\n * i/o 密集型任务(2n)： 这种任务应用起来，系统会用大部分的时间来处理 i/o 交互，而线程在处理 i/o 的时间段内不会占用 cpu 来处理，这时就可以将 cpu 交出给其它线程使用。因此在 i/o 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2n。\n\n\n# aqs\n\n\n# aqs 是什么？\n\naqs 的全称为 abstractqueuedsynchronizer ，翻译过来的意思就是抽象队列同步器。这个类在 java.util.concurrent.locks 包下面。\naqs 就是一个抽象类，主要用来构建锁和同步器\n\npublic abstract class abstractqueuedsynchronizer extends abstractownablesynchronizer implements java.io.serializable {\n}\n\n\n\naqs 为构建锁和同步器提供了一些通用功能的是实现，因此，使用 aqs 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 reentrantlock，semaphore，其他的诸如 reentrantreadwritelock，synchronousqueue等等皆是基于 aqs 的。\n\n\n# aqs的原理是什么\n\naqs 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 aqs 是用 clh 队列锁 实现的，即将暂时获取不到锁的线程加入到队列中。',charsets:{cjk:!0},lastUpdated:"2023/11/14, 06:07:31",lastUpdatedTimestamp:1699942051e3},{title:"Java 新特性面试题",frontmatter:{title:"Java 新特性面试题",date:"2023-11-02T11:09:09.000Z",permalink:"/pages/89ee48/"},regularPath:"/02.Java%20%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%20%E5%85%AB%E8%82%A1%E6%96%87/04.Java%20%E6%96%B0%E7%89%B9%E6%80%A7%E9%9D%A2%E8%AF%95%E9%A2%98.html",relativePath:"02.Java 面试宝典/02.Java 八股文/04.Java 新特性面试题.md",key:"v-d4e3c634",path:"/pages/89ee48/",headers:[{level:2,title:"CPU 只有两核的话，并行流还有用吗",slug:"cpu-只有两核的话-并行流还有用吗",normalizedTitle:"cpu 只有两核的话，并行流还有用吗",charIndex:2}],headersStr:"CPU 只有两核的话，并行流还有用吗",content:"# CPU 只有两核的话，并行流还有用吗\n\n有用。\n\n并行流就是将一个流的内容分成多个数据块，并用不同的线程分别处理每个不同数据块的流。\n\n并行流内部使用了默认的 ForkJoinPool 线程池。默认的线程数量就是处理器的核心数。\n\n所以 CPU 只有两核的话，并行流会使用两个线程数对数据进行处理。",normalizedContent:"# cpu 只有两核的话，并行流还有用吗\n\n有用。\n\n并行流就是将一个流的内容分成多个数据块，并用不同的线程分别处理每个不同数据块的流。\n\n并行流内部使用了默认的 forkjoinpool 线程池。默认的线程数量就是处理器的核心数。\n\n所以 cpu 只有两核的话，并行流会使用两个线程数对数据进行处理。",charsets:{cjk:!0},lastUpdated:"2023/11/02, 03:16:54",lastUpdatedTimestamp:1698895014e3},{title:"JVM 面试题",frontmatter:{title:"JVM 面试题",date:"2023-10-24T15:38:18.000Z",permalink:"/pages/752c30/"},regularPath:"/02.Java%20%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%20%E5%85%AB%E8%82%A1%E6%96%87/05.JVM%20%E9%9D%A2%E8%AF%95%E9%A2%98.html",relativePath:"02.Java 面试宝典/02.Java 八股文/05.JVM 面试题.md",key:"v-4e4a101c",path:"/pages/752c30/",headers:[{level:1,title:"运行时数据区",slug:"运行时数据区",normalizedTitle:"运行时数据区",charIndex:2},{level:2,title:"运行时数据区中包含哪些区域？哪些线程共享的？哪些线程独享？哪些区域可能出现OutOFMemoryError？哪些区域不会出现OutOFMemoryError",slug:"运行时数据区中包含哪些区域-哪些线程共享的-哪些线程独享-哪些区域可能出现outofmemoryerror-哪些区域不会出现outofmemoryerror",normalizedTitle:"运行时数据区中包含哪些区域？哪些线程共享的？哪些线程独享？哪些区域可能出现outofmemoryerror？哪些区域不会出现outofmemoryerror",charIndex:13},{level:3,title:"程序计数器",slug:"程序计数器",normalizedTitle:"程序计数器",charIndex:148},{level:3,title:"Java虚拟机栈",slug:"java虚拟机栈",normalizedTitle:"java虚拟机栈",charIndex:417},{level:3,title:"本地方法栈",slug:"本地方法栈",normalizedTitle:"本地方法栈",charIndex:165},{level:3,title:"堆",slug:"堆",normalizedTitle:"堆",charIndex:183},{level:3,title:"方法区",slug:"方法区",normalizedTitle:"方法区",charIndex:188},{level:2,title:"方法区和永久代的关系",slug:"方法区和永久代的关系",normalizedTitle:"方法区和永久代的关系",charIndex:2167},{level:2,title:"Java对象创建的过程",slug:"java对象创建的过程",normalizedTitle:"java对象创建的过程",charIndex:2330},{level:2,title:"对象的访问定位两种方式知道吗？各有什么优缺点",slug:"对象的访问定位两种方式知道吗-各有什么优缺点",normalizedTitle:"对象的访问定位两种方式知道吗？各有什么优缺点",charIndex:3056},{level:2,title:"堆空间的基本结构了解吗？什么情况下对象对会进入老年代",slug:"堆空间的基本结构了解吗-什么情况下对象对会进入老年代",normalizedTitle:"堆空间的基本结构了解吗？什么情况下对象对会进入老年代",charIndex:3378},{level:1,title:"垃圾收集",slug:"垃圾收集",normalizedTitle:"垃圾收集",charIndex:1640},{level:2,title:"如何判断对象是否死亡",slug:"如何判断对象是否死亡",normalizedTitle:"如何判断对象是否死亡",charIndex:4037},{level:2,title:"哪些对象可以作为GC Roots呢",slug:"哪些对象可以作为gc-roots呢",normalizedTitle:"哪些对象可以作为gc roots呢",charIndex:4442},{level:2,title:"对象可以被回收，就代表一定会被回收吗",slug:"对象可以被回收-就代表一定会被回收吗",normalizedTitle:"对象可以被回收，就代表一定会被回收吗",charIndex:4583},{level:2,title:"垃圾收集有哪些算法，各自的特点？",slug:"垃圾收集有哪些算法-各自的特点",normalizedTitle:"垃圾收集有哪些算法，各自的特点？",charIndex:4848},{level:2,title:"程序调用System.gc()时，一定会发生GC吗",slug:"程序调用system-gc-时-一定会发生gc吗",normalizedTitle:"程序调用system.gc()时，一定会发生gc吗",charIndex:5445},{level:2,title:"有哪些常见的GC？谈谈你对Minor GC、还有Full GC的理解。Minor GC与Full GC分别在什么时候发生？Minor GC会发生stop the world现象吗？",slug:"有哪些常见的gc-谈谈你对minor-gc、还有full-gc的理解。minor-gc与full-gc分别在什么时候发生-minor-gc会发生stop-the-world现象吗",normalizedTitle:"有哪些常见的gc？谈谈你对minor gc、还有full gc的理解。minor gc与full gc分别在什么时候发生？minor gc会发生stop the world现象吗？",charIndex:5557},{level:2,title:"讲一下CMS垃圾收集器的四个步骤。CMS有什么缺点",slug:"讲一下cms垃圾收集器的四个步骤。cms有什么缺点",normalizedTitle:"讲一下cms垃圾收集器的四个步骤。cms有什么缺点",charIndex:5920},{level:2,title:"G1垃圾收集器的步骤。有什么缺点",slug:"g1垃圾收集器的步骤。有什么缺点",normalizedTitle:"g1垃圾收集器的步骤。有什么缺点",charIndex:6433},{level:1,title:"类",slug:"类",normalizedTitle:"类",charIndex:598},{level:2,title:"什么是字节码？类文件结果的组成了解吗",slug:"什么是字节码-类文件结果的组成了解吗",normalizedTitle:"什么是字节码？类文件结果的组成了解吗",charIndex:6750},{level:2,title:"类的生命周期？类加载过程了解吗？加载这一步主要做了什么事情？初始化阶段中哪几种情况必须对类初始化",slug:"类的生命周期-类加载过程了解吗-加载这一步主要做了什么事情-初始化阶段中哪几种情况必须对类初始化",normalizedTitle:"类的生命周期？类加载过程了解吗？加载这一步主要做了什么事情？初始化阶段中哪几种情况必须对类初始化",charIndex:7627},{level:2,title:"双亲委派模型了解吗？",slug:"双亲委派模型了解吗",normalizedTitle:"双亲委派模型了解吗？",charIndex:8472},{level:2,title:"双亲委派模型有什么好处？双亲委派模型是为了保证一个Java类在JVM中是唯一的？",slug:"双亲委派模型有什么好处-双亲委派模型是为了保证一个java类在jvm中是唯一的",normalizedTitle:"双亲委派模型有什么好处？双亲委派模型是为了保证一个java类在jvm中是唯一的？",charIndex:8650},{level:2,title:"JDK中有哪些默认的类加载?",slug:"jdk中有哪些默认的类加载",normalizedTitle:"jdk中有哪些默认的类加载?",charIndex:8901},{level:1,title:"性能优化&问题排查",slug:"性能优化-问题排查",normalizedTitle:"性能优化&amp;问题排查",charIndex:null},{level:2,title:"内存泄漏排查",slug:"内存泄漏排查",normalizedTitle:"内存泄漏排查",charIndex:9327},{level:2,title:"项目中实践过JVM调优吗？怎么做的？",slug:"项目中实践过jvm调优吗-怎么做的",normalizedTitle:"项目中实践过jvm调优吗？怎么做的？",charIndex:9612},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:0}],headersStr:"运行时数据区 运行时数据区中包含哪些区域？哪些线程共享的？哪些线程独享？哪些区域可能出现OutOFMemoryError？哪些区域不会出现OutOFMemoryError 程序计数器 Java虚拟机栈 本地方法栈 堆 方法区 方法区和永久代的关系 Java对象创建的过程 对象的访问定位两种方式知道吗？各有什么优缺点 堆空间的基本结构了解吗？什么情况下对象对会进入老年代 垃圾收集 如何判断对象是否死亡 哪些对象可以作为GC Roots呢 对象可以被回收，就代表一定会被回收吗 垃圾收集有哪些算法，各自的特点？ 程序调用System.gc()时，一定会发生GC吗 有哪些常见的GC？谈谈你对Minor GC、还有Full GC的理解。Minor GC与Full GC分别在什么时候发生？Minor GC会发生stop the world现象吗？ 讲一下CMS垃圾收集器的四个步骤。CMS有什么缺点 G1垃圾收集器的步骤。有什么缺点 类 什么是字节码？类文件结果的组成了解吗 类的生命周期？类加载过程了解吗？加载这一步主要做了什么事情？初始化阶段中哪几种情况必须对类初始化 双亲委派模型了解吗？ 双亲委派模型有什么好处？双亲委派模型是为了保证一个Java类在JVM中是唯一的？ JDK中有哪些默认的类加载? 性能优化&问题排查 内存泄漏排查 项目中实践过JVM调优吗？怎么做的？ ",content:'# 运行时数据区\n\n\n# 运行时数据区中包含哪些区域？哪些线程共享的？哪些线程独享？哪些区域可能出现OutOFMemoryError？哪些区域不会出现OutOFMemoryError\n\nJDK1.8 运行时数据区和之前的版本略有不同。 JDK1.8之前： JDK1.8：\n\n线程私有的：\n\n * 程序计数器\n * 虚拟机栈\n * 本地方法栈\n\n线程共享的：\n\n * 堆\n * 方法区（JDK1.8 改成元空间）\n\n\n# 程序计数器\n\n程序计数器是一块较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。主要有两个作用：\n\n * 字节码解释器通过改变程序计数器来依次读取指令，实现代码的流程控制，如：顺序执行、选择、循环，异常处理等。\n * 多线程的情况下，程序计数器会记录当前线程执行的位置，当线程切换回来时可以知道当线程上次运行到哪里\n\n程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域。\n\n\n# Java虚拟机栈\n\nJava虚拟机栈主要给 Java方法使用，所有的 Java 方法调用都是通过栈实现的。方法调用的数据通过栈进行传递，每一次方法调用都有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。 栈由一个个栈帧组成，每个栈帧都拥有：局部变量表、操作数栈、动态链接、方法返回地址。\n\n * 局部变量表： 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。\n * 操作数栈：用于存放方法执行过程中产生的中间计算结果和计算过程中产生的临时变量\n * 动态链接：主要服务于一个方法需要调用其他方法的场景。 在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在 Class 文件的常量池里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。\n * 方法返回地址： Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， 栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。\n\n程序运行中Java虚拟机栈可能会出现两种错误：\n\n * StackOverFlowError： 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError错误。\n * OutOfMemoryError： 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常\n\n\n# 本地方法栈\n\n和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError和 OutOfMemoryError 两种错误。\n\n\n# 堆\n\nJava 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。 堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：\n\n 1. java.lang.OutOfMemoryError: GC Overhead Limit Exceeded ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。\n 2. java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过-Xmx参数配置，若没有特别配置，将会使用默认值。）\n\n\n# 方法区\n\n方法区是一块逻辑区域，Java 虚拟机规范只是规定了方法区的概念和作用，不同的虚拟机方法区的实现也是不同的。 当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。\n\n\n# 方法区和永久代的关系\n\n方法区和永久代以及元空间的关系有点像Java中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作方法区，也就是永久代和元空间是虚拟机对虚拟机规范中方法区的两种实现方式。 永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。\n\n\n\n# Java对象创建的过程\n\n\n\n 1. 类加载检查： 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。\n 2. 分配内存：类加载检查过后，虚拟机将为新生对象分配内存。 对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。\n 3. 初始化零值： 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\n 4. 设置对象头： 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\n 5. 执行init方法： 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。\n\n\n# 对象的访问定位两种方式知道吗？各有什么优缺点\n\n对象的访问定位方式有使用句柄和直接指针\n\n * 句柄：如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。\n * 直接指针： 如果使用直接指针访问，reference 中存储的直接就是对象的地址。\n\n这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。\n\n\n# 堆空间的基本结构了解吗？什么情况下对象对会进入老年代\n\nJava 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。 在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：\n\n 1. 新生代内存(Young Generation)\n 2. 老生代(Old Generation)\n 3. 永久代(Permanent Generation)\n\n下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。 JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存。 对象进入老年代主要有两种情况：\n\n * 长期存活的对象会进入老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。\n * 大对象会直接进入老年代。主要是避免年轻代里出现那种大对象，然后屡次躲过GC，还得把他在两个Survivor区域里来回复制多次之后才能进入老年代。\n\n\n# 垃圾收集\n\n\n# 如何判断对象是否死亡\n\n判断对象是否死亡主要有两种方法：引用计数法和可达性分析算法。 引用计数法给对象中添加一个引用计数器：\n\n * 每当有一个地方引用它，计数器就加 1；\n * 当引用失效，计数器就减 1；\n * 任何时候计数器为 0 的对象就是不可能再被使用的。\n\n这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题（A和B对象互相引用，无其他任何引用）。 可达性分析算法基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。 下图中的 Object 6 ~ Object 10 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象\n\n\n\n# 哪些对象可以作为GC Roots呢\n\n下面这些对象可以作为GC Roots:\n\n * 虚拟机栈（栈帧中的本地变量表）中引用的对象\n * 本地方法栈(Native方法)中引用的对象\n * 方法区中类静态属性引用的对象\n * 方法区中常量引用的对象\n * 所有被同步特有的对象\n\n\n# 对象可以被回收，就代表一定会被回收吗\n\n即使是不可达分析法中的不可达对象，也不一定会被垃圾收集器回收，要真正宣告一个对象死亡，至少要经历两次标记过程。 不可达对象被第一次标记并且进行一次一次筛选，筛选的条件是**此对象是否有必要执行 ****finalize **方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。\n\n\n# 垃圾收集有哪些算法，各自的特点？\n\n * 标记-清除算法：该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。会带来效率问题和**空间问题（标记清除后会产生大量不连续的碎片） **\n * 标记-复制算法： 为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。\n * 标记-整理算法： 根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。 分代收集算法：当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。\n\n\n# 程序调用System.gc()时，一定会发生GC吗\n\n此方法的调用是建议JVM进行Full GC， 不一定会发生GC。但是不建议使用 System.gc()，会增加Full GC的频率，应该让虚拟机自己去管理内存。\n\n\n# 有哪些常见的GC？谈谈你对Minor GC、还有Full GC的理解。Minor GC与Full GC分别在什么时候发生？Minor GC会发生stop the world现象吗？\n\n针对HotSpot VM的实现，GC其实准确分类只有两大种： 部分收集（Partial GC）：\n\n * 新生代收集（Minor GC/Young GC）：只对新生代进行垃圾收集。 Minor GC 非常频繁，回收速度比较快。\n * 老年代收集（Major GC/Old GC）：只对老年代进行垃圾收集。需要注意的是Major GC在有的语境中也用于指代整堆收集\n * 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。 目前只有G1收集器会有这种行为。\n\n整堆收集（Full GC）：收集整个Java堆和方法区。\n\n\n# 讲一下CMS垃圾收集器的四个步骤。CMS有什么缺点\n\nCMS 收集器是第一款实现垃圾收集线程与用户线程（基本上）同时工作的并发收集器，基于**“标记-清除”算法**实现的 。整个过程分为四个步骤：\n\n * 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；\n * 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\n * 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短\n * 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。\n\nCMS的主要优点是并发收集、低停顿。缺点是：\n\n * 对 CPU 资源敏感；\n * 无法处理浮动垃圾；\n * 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。\n\n\n# G1垃圾收集器的步骤。有什么缺点\n\nG1 收集器的运作大致分为以下几个步骤：\n\n * 初始标记：标记一下GC Roots能直接关联到的对象，需要停顿线程，但耗时很短\n * 并发标记：是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行\n * 最终标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录\n * 筛选回收：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划\n\n缺点：G1 收集器为了垃圾收集产生的内存占用（Footprint）和程序运行时的额外执行负载（Overload）都要比CMS要高。\n\n\n# 类\n\n\n# 什么是字节码？类文件结果的组成了解吗\n\n在Java中，JVM可以理解的代码就叫做字节码（即扩展名为.class的文件） ClassFile的结构如下：\n\nClassFile {\n    u4             magic; //魔数，Class 文件的标志\n    u2             minor_version;//Class 的小版本号\n    u2             major_version;//Class 的大版本号\n    u2             constant_pool_count;//常量池的数量\n    cp_info        constant_pool[constant_pool_count-1];//常量池\n    u2             access_flags;//Class 的访问标记\n    u2             this_class;//当前类\n    u2             super_class;//父类\n    u2             interfaces_count;//接口\n    u2             interfaces[interfaces_count];//一个类可以实现多个接口\n    u2             fields_count;//Class 文件的字段属性\n    field_info     fields[fields_count];//一个类可以有多个字段\n    u2             methods_count;//Class 文件的方法数量\n    method_info    methods[methods_count];//一个类可以有个多个方法\n    u2             attributes_count;//此类的属性表中的属性数\n    attribute_info attributes[attributes_count];//属性表集合\n}\n\n\n\n\n# 类的生命周期？类加载过程了解吗？加载这一步主要做了什么事情？初始化阶段中哪几种情况必须对类初始化\n\n类的完整生命周期如下： 类加载过程主要分为三步：加载->连接->初始化。连接过程又分为验证->准备->解析。 加载主要完成：\n\n 1. 通过全类名获取定义此类的二进制字节流\n 2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构\n 3. 在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口\n\n初始化遇见下面5种情况必须对类进行初始化“\n\n 1. 当遇到 new 、 getstatic、putstatic 或 invokestatic 这 4 条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。\n    * 当 jvm 执行 new 指令时会初始化类。即当程序创建一个类的实例对象。\n    * 当 jvm 执行 getstatic 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。\n    * 当 jvm 执行 putstatic 指令时会初始化类。即程序给类的静态变量赋值。\n    * 当 jvm 执行 invokestatic 指令时会初始化类。即程序调用类的静态方法。\n 2. 使用 java.lang.reflect 包的方法对类进行反射调用时如 Class.forname("..."), newInstance() 等等。如果类没初始化，需要触发其初始化。\n 3. 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。\n 4. 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。\n 5. MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 findStaticVarHandle 来初始化要调用的类。\n\n\n# 双亲委派模型了解吗？\n\n类加载的时候，首先会把该请求委派给父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。\n\n\n# 双亲委派模型有什么好处？双亲委派模型是为了保证一个Java类在JVM中是唯一的？\n\n双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。\n\n\n# JDK中有哪些默认的类加载?\n\nJVM中内置了三个重要的ClassLoader，除了BootstrapClassLoader， 其他类加载器均由Java实现并且全部继承自java.lang.ClassLoader；\n\n 1. BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由 C++实现，负责加载 %JAVA_HOME%/lib目录下的 jar 包和类或者被 -Xbootclasspath参数指定的路径中的所有类。\n 2. ExtensionClassLoader(扩展类加载器) ：主要负责加载 %JRE_HOME%/lib/ext 目录下的 jar 包和类，或被 java.ext.dirs 系统变量所指定的路径下的 jar 包。\n 3. AppClassLoader(应用程序类加载器) ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。\n\n\n# 性能优化&问题排查\n\n\n# 内存泄漏排查\n\n 1. 使用 **jps** 命令获取到当前JVM进程的pid\n 2. 使用 **jstat -gc** 命令观察GC： 如果YGC每次GC掉的内存并不多，每次YGC后都有一部分内存未回收，导致在多次YGC后回收不掉的内存被挪到堆的old区，old满了之后FGC发现也是回收不掉。就基本可以确定是内存泄漏问题\n 3. 使用**jmap -dump **命令生成堆转存快照。\n 4. 使用MAT（ MemoryAnalyzer ）分析dump文件，找到具体内存泄漏的代码。（MAT的 Leak Suspects报表帮助我们定位到内存泄漏的代码 ）\n\n\n# 项目中实践过JVM调优吗？怎么做的？\n\n有实践过。 当时线上监控平台报大量 Full GC 的警告。添加打印GC日志的参数，打印出GC日志，上传到gceasy.io进行分析。发现是元空间的初始值太小，导致元空间一旦扩容，进入导致Full GC的大量出现。 解决：通过XX:MetaspaceSize=N 参数适当调大元空间的初始大小。添加到服务器进行监控，通过多次调整，找到最合适的元空间初始值（ 对于8G物理内存的机器来说，一般将这这个值设置为256M即可）。最终解决线上Full GC的大量出现。\n\n> 调优的主要步骤：\n> \n>  1. 监控分析GC日志。\n>  2. 判断JVM问题：\n>     1. 如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化\n>     2. 如果GC时间超过1-3秒，或者频繁GC，则必须优化。\n>  3. 确定调优目标\n>  4. 调整参数\n>     1. 调优一般是从满足程序的内存使用需求开始，之后是时间延迟要求，最后才是吞吐量要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行之。\n>  5. 对比调优前后差距\n>  6. 重复：1、2、3、4、5步骤\n>     1. 找到最佳JVM参数设置\n>  7. 应用JVM到应用服务器\n>     1. 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。\n\n> 参考：https://juejin.cn/post/7128377003224334373#heading-0\n\n\n#',normalizedContent:'# 运行时数据区\n\n\n# 运行时数据区中包含哪些区域？哪些线程共享的？哪些线程独享？哪些区域可能出现outofmemoryerror？哪些区域不会出现outofmemoryerror\n\njdk1.8 运行时数据区和之前的版本略有不同。 jdk1.8之前： jdk1.8：\n\n线程私有的：\n\n * 程序计数器\n * 虚拟机栈\n * 本地方法栈\n\n线程共享的：\n\n * 堆\n * 方法区（jdk1.8 改成元空间）\n\n\n# 程序计数器\n\n程序计数器是一块较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。主要有两个作用：\n\n * 字节码解释器通过改变程序计数器来依次读取指令，实现代码的流程控制，如：顺序执行、选择、循环，异常处理等。\n * 多线程的情况下，程序计数器会记录当前线程执行的位置，当线程切换回来时可以知道当线程上次运行到哪里\n\n程序计数器是唯一一个不会出现 outofmemoryerror 的内存区域。\n\n\n# java虚拟机栈\n\njava虚拟机栈主要给 java方法使用，所有的 java 方法调用都是通过栈实现的。方法调用的数据通过栈进行传递，每一次方法调用都有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。 栈由一个个栈帧组成，每个栈帧都拥有：局部变量表、操作数栈、动态链接、方法返回地址。\n\n * 局部变量表： 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。\n * 操作数栈：用于存放方法执行过程中产生的中间计算结果和计算过程中产生的临时变量\n * 动态链接：主要服务于一个方法需要调用其他方法的场景。 在 java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（symbilic reference）保存在 class 文件的常量池里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。\n * 方法返回地址： java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， 栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。\n\n程序运行中java虚拟机栈可能会出现两种错误：\n\n * stackoverflowerror： 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 java 虚拟机栈的最大深度的时候，就抛出 stackoverflowerror错误。\n * outofmemoryerror： 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出outofmemoryerror异常\n\n\n# 本地方法栈\n\n和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 native 方法服务。 在 hotspot 虚拟机中和 java 虚拟机栈合二为一。 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 stackoverflowerror和 outofmemoryerror 两种错误。\n\n\n# 堆\n\njava 虚拟机所管理的内存中最大的一块，java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**java 堆是垃圾收集器管理的主要区域，因此也被称作 gc 堆（garbage collected heap）。 堆这里最容易出现的就是 outofmemoryerror 错误，并且出现这种错误之后的表现形式还会有几种，比如：\n\n 1. java.lang.outofmemoryerror: gc overhead limit exceeded ： 当 jvm 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。\n 2. java.lang.outofmemoryerror: java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过-xmx参数配置，若没有特别配置，将会使用默认值。）\n\n\n# 方法区\n\n方法区是一块逻辑区域，java 虚拟机规范只是规定了方法区的概念和作用，不同的虚拟机方法区的实现也是不同的。 当虚拟机要使用一个类时，它需要读取并解析 class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。\n\n\n# 方法区和永久代的关系\n\n方法区和永久代以及元空间的关系有点像java中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作方法区，也就是永久代和元空间是虚拟机对虚拟机规范中方法区的两种实现方式。 永久代是 jdk 1.8 之前的方法区实现，jdk 1.8 及以后方法区的实现变成了元空间。\n\n\n\n# java对象创建的过程\n\n\n\n 1. 类加载检查： 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。\n 2. 分配内存：类加载检查过后，虚拟机将为新生对象分配内存。 对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 java 堆是否规整决定，而 java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。\n 3. 初始化零值： 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\n 4. 设置对象头： 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 gc 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\n 5. 执行init方法： 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。\n\n\n# 对象的访问定位两种方式知道吗？各有什么优缺点\n\n对象的访问定位方式有使用句柄和直接指针\n\n * 句柄：如果使用句柄的话，那么 java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。\n * 直接指针： 如果使用直接指针访问，reference 中存储的直接就是对象的地址。\n\n这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。\n\n\n# 堆空间的基本结构了解吗？什么情况下对象对会进入老年代\n\njava 堆还可以细分为：新生代和老年代；再细致一点有：eden、survivor、old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。 在 jdk 7 版本及 jdk 7 版本之前，堆内存被通常分为下面三部分：\n\n 1. 新生代内存(young generation)\n 2. 老生代(old generation)\n 3. 永久代(permanent generation)\n\n下图所示的 eden 区、两个 survivor 区 s0 和 s1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。 jdk 8 版本之后 permgen(永久) 已被 metaspace(元空间) 取代，元空间使用的是直接内存。 对象进入老年代主要有两种情况：\n\n * 长期存活的对象会进入老年代。大部分情况，对象都会首先在 eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(eden 区->survivor 区后对象的初始年龄变为 1)当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -xx:maxtenuringthreshold 来设置。\n * 大对象会直接进入老年代。主要是避免年轻代里出现那种大对象，然后屡次躲过gc，还得把他在两个survivor区域里来回复制多次之后才能进入老年代。\n\n\n# 垃圾收集\n\n\n# 如何判断对象是否死亡\n\n判断对象是否死亡主要有两种方法：引用计数法和可达性分析算法。 引用计数法给对象中添加一个引用计数器：\n\n * 每当有一个地方引用它，计数器就加 1；\n * 当引用失效，计数器就减 1；\n * 任何时候计数器为 0 的对象就是不可能再被使用的。\n\n这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题（a和b对象互相引用，无其他任何引用）。 可达性分析算法基本思想就是通过一系列的称为 “gc roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 gc roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。 下图中的 object 6 ~ object 10 之间虽有引用关系，但它们到 gc roots 不可达，因此为需要被回收的对象\n\n\n\n# 哪些对象可以作为gc roots呢\n\n下面这些对象可以作为gc roots:\n\n * 虚拟机栈（栈帧中的本地变量表）中引用的对象\n * 本地方法栈(native方法)中引用的对象\n * 方法区中类静态属性引用的对象\n * 方法区中常量引用的对象\n * 所有被同步特有的对象\n\n\n# 对象可以被回收，就代表一定会被回收吗\n\n即使是不可达分析法中的不可达对象，也不一定会被垃圾收集器回收，要真正宣告一个对象死亡，至少要经历两次标记过程。 不可达对象被第一次标记并且进行一次一次筛选，筛选的条件是**此对象是否有必要执行 ****finalize **方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。\n\n\n# 垃圾收集有哪些算法，各自的特点？\n\n * 标记-清除算法：该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。会带来效率问题和**空间问题（标记清除后会产生大量不连续的碎片） **\n * 标记-复制算法： 为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。\n * 标记-整理算法： 根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。 分代收集算法：当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。\n\n\n# 程序调用system.gc()时，一定会发生gc吗\n\n此方法的调用是建议jvm进行full gc， 不一定会发生gc。但是不建议使用 system.gc()，会增加full gc的频率，应该让虚拟机自己去管理内存。\n\n\n# 有哪些常见的gc？谈谈你对minor gc、还有full gc的理解。minor gc与full gc分别在什么时候发生？minor gc会发生stop the world现象吗？\n\n针对hotspot vm的实现，gc其实准确分类只有两大种： 部分收集（partial gc）：\n\n * 新生代收集（minor gc/young gc）：只对新生代进行垃圾收集。 minor gc 非常频繁，回收速度比较快。\n * 老年代收集（major gc/old gc）：只对老年代进行垃圾收集。需要注意的是major gc在有的语境中也用于指代整堆收集\n * 混合收集（mixed gc）：对整个新生代和部分老年代进行垃圾收集。 目前只有g1收集器会有这种行为。\n\n整堆收集（full gc）：收集整个java堆和方法区。\n\n\n# 讲一下cms垃圾收集器的四个步骤。cms有什么缺点\n\ncms 收集器是第一款实现垃圾收集线程与用户线程（基本上）同时工作的并发收集器，基于**“标记-清除”算法**实现的 。整个过程分为四个步骤：\n\n * 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；\n * 并发标记： 同时开启 gc 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 gc 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\n * 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短\n * 并发清除： 开启用户线程，同时 gc 线程开始对未标记的区域做清扫。\n\ncms的主要优点是并发收集、低停顿。缺点是：\n\n * 对 cpu 资源敏感；\n * 无法处理浮动垃圾；\n * 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。\n\n\n# g1垃圾收集器的步骤。有什么缺点\n\ng1 收集器的运作大致分为以下几个步骤：\n\n * 初始标记：标记一下gc roots能直接关联到的对象，需要停顿线程，但耗时很短\n * 并发标记：是从gc root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行\n * 最终标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录\n * 筛选回收：对各个region的回收价值和成本进行排序，根据用户所期望的gc停顿时间来制定回收计划\n\n缺点：g1 收集器为了垃圾收集产生的内存占用（footprint）和程序运行时的额外执行负载（overload）都要比cms要高。\n\n\n# 类\n\n\n# 什么是字节码？类文件结果的组成了解吗\n\n在java中，jvm可以理解的代码就叫做字节码（即扩展名为.class的文件） classfile的结构如下：\n\nclassfile {\n    u4             magic; //魔数，class 文件的标志\n    u2             minor_version;//class 的小版本号\n    u2             major_version;//class 的大版本号\n    u2             constant_pool_count;//常量池的数量\n    cp_info        constant_pool[constant_pool_count-1];//常量池\n    u2             access_flags;//class 的访问标记\n    u2             this_class;//当前类\n    u2             super_class;//父类\n    u2             interfaces_count;//接口\n    u2             interfaces[interfaces_count];//一个类可以实现多个接口\n    u2             fields_count;//class 文件的字段属性\n    field_info     fields[fields_count];//一个类可以有多个字段\n    u2             methods_count;//class 文件的方法数量\n    method_info    methods[methods_count];//一个类可以有个多个方法\n    u2             attributes_count;//此类的属性表中的属性数\n    attribute_info attributes[attributes_count];//属性表集合\n}\n\n\n\n\n# 类的生命周期？类加载过程了解吗？加载这一步主要做了什么事情？初始化阶段中哪几种情况必须对类初始化\n\n类的完整生命周期如下： 类加载过程主要分为三步：加载->连接->初始化。连接过程又分为验证->准备->解析。 加载主要完成：\n\n 1. 通过全类名获取定义此类的二进制字节流\n 2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构\n 3. 在内存中生成一个代表该类的 class 对象，作为方法区这些数据的访问入口\n\n初始化遇见下面5种情况必须对类进行初始化“\n\n 1. 当遇到 new 、 getstatic、putstatic 或 invokestatic 这 4 条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。\n    * 当 jvm 执行 new 指令时会初始化类。即当程序创建一个类的实例对象。\n    * 当 jvm 执行 getstatic 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。\n    * 当 jvm 执行 putstatic 指令时会初始化类。即程序给类的静态变量赋值。\n    * 当 jvm 执行 invokestatic 指令时会初始化类。即程序调用类的静态方法。\n 2. 使用 java.lang.reflect 包的方法对类进行反射调用时如 class.forname("..."), newinstance() 等等。如果类没初始化，需要触发其初始化。\n 3. 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。\n 4. 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。\n 5. methodhandle 和 varhandle 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 findstaticvarhandle 来初始化要调用的类。\n\n\n# 双亲委派模型了解吗？\n\n类加载的时候，首先会把该请求委派给父类加载器的 loadclass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 bootstrapclassloader 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 bootstrapclassloader 作为父类加载器。\n\n\n# 双亲委派模型有什么好处？双亲委派模型是为了保证一个java类在jvm中是唯一的？\n\n双亲委派模型保证了 java 程序的稳定运行，可以避免类的重复加载（jvm 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 java 的核心 api 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.object 类的话，那么程序运行的时候，系统就会出现多个不同的 object 类。\n\n\n# jdk中有哪些默认的类加载?\n\njvm中内置了三个重要的classloader，除了bootstrapclassloader， 其他类加载器均由java实现并且全部继承自java.lang.classloader；\n\n 1. bootstrapclassloader(启动类加载器) ：最顶层的加载类，由 c++实现，负责加载 %java_home%/lib目录下的 jar 包和类或者被 -xbootclasspath参数指定的路径中的所有类。\n 2. extensionclassloader(扩展类加载器) ：主要负责加载 %jre_home%/lib/ext 目录下的 jar 包和类，或被 java.ext.dirs 系统变量所指定的路径下的 jar 包。\n 3. appclassloader(应用程序类加载器) ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。\n\n\n# 性能优化&问题排查\n\n\n# 内存泄漏排查\n\n 1. 使用 **jps** 命令获取到当前jvm进程的pid\n 2. 使用 **jstat -gc** 命令观察gc： 如果ygc每次gc掉的内存并不多，每次ygc后都有一部分内存未回收，导致在多次ygc后回收不掉的内存被挪到堆的old区，old满了之后fgc发现也是回收不掉。就基本可以确定是内存泄漏问题\n 3. 使用**jmap -dump **命令生成堆转存快照。\n 4. 使用mat（ memoryanalyzer ）分析dump文件，找到具体内存泄漏的代码。（mat的 leak suspects报表帮助我们定位到内存泄漏的代码 ）\n\n\n# 项目中实践过jvm调优吗？怎么做的？\n\n有实践过。 当时线上监控平台报大量 full gc 的警告。添加打印gc日志的参数，打印出gc日志，上传到gceasy.io进行分析。发现是元空间的初始值太小，导致元空间一旦扩容，进入导致full gc的大量出现。 解决：通过xx:metaspacesize=n 参数适当调大元空间的初始大小。添加到服务器进行监控，通过多次调整，找到最合适的元空间初始值（ 对于8g物理内存的机器来说，一般将这这个值设置为256m即可）。最终解决线上full gc的大量出现。\n\n> 调优的主要步骤：\n> \n>  1. 监控分析gc日志。\n>  2. 判断jvm问题：\n>     1. 如果各项参数设置合理，系统没有超时日志出现，gc频率不高，gc耗时不高，那么没有必要进行gc优化\n>     2. 如果gc时间超过1-3秒，或者频繁gc，则必须优化。\n>  3. 确定调优目标\n>  4. 调整参数\n>     1. 调优一般是从满足程序的内存使用需求开始，之后是时间延迟要求，最后才是吞吐量要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行之。\n>  5. 对比调优前后差距\n>  6. 重复：1、2、3、4、5步骤\n>     1. 找到最佳jvm参数设置\n>  7. 应用jvm到应用服务器\n>     1. 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。\n\n> 参考：https://juejin.cn/post/7128377003224334373#heading-0\n\n\n#',charsets:{cjk:!0},lastUpdated:"2023/11/02, 03:14:56",lastUpdatedTimestamp:1698894896e3},{title:"MySQL 面试题",frontmatter:{title:"MySQL 面试题",date:"2023-10-24T15:44:55.000Z",permalink:"/pages/b23391/"},regularPath:"/02.Java%20%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%20%E5%85%AB%E8%82%A1%E6%96%87/06.MySQL%20%E9%9D%A2%E8%AF%95%E9%A2%98.html",relativePath:"02.Java 面试宝典/02.Java 八股文/06.MySQL 面试题.md",key:"v-1b1c4248",path:"/pages/b23391/",headers:[{level:1,title:"MySQL 体系结构",slug:"mysql-体系结构",normalizedTitle:"mysql 体系结构",charIndex:2},{level:2,title:"MySQL 逻辑架构",slug:"mysql-逻辑架构",normalizedTitle:"mysql 逻辑架构",charIndex:17},{level:2,title:"一条SQL语句在MySQL中是怎么执行的",slug:"一条sql语句在mysql中是怎么执行的",normalizedTitle:"一条sql语句在mysql中是怎么执行的",charIndex:379},{level:1,title:"MySQL存储引擎",slug:"mysql存储引擎",normalizedTitle:"mysql存储引擎",charIndex:616},{level:2,title:"MySQL提供了哪些存储引擎",slug:"mysql提供了哪些存储引擎",normalizedTitle:"mysql提供了哪些存储引擎",charIndex:630},{level:2,title:"MySQL存储引擎架构了解吗",slug:"mysql存储引擎架构了解吗",normalizedTitle:"mysql存储引擎架构了解吗",charIndex:776},{level:2,title:"MyISAM和InnoDB区别",slug:"myisam和innodb区别",normalizedTitle:"myisam和innodb区别",charIndex:863},{level:1,title:"MySQL 事务",slug:"mysql-事务",normalizedTitle:"mysql 事务",charIndex:1209},{level:2,title:"什么是事务",slug:"什么是事务",normalizedTitle:"什么是事务",charIndex:1222},{level:2,title:"什么是数据库事务",slug:"什么是数据库事务",normalizedTitle:"什么是数据库事务",charIndex:1267},{level:2,title:"ACID特性是什么",slug:"acid特性是什么",normalizedTitle:"acid特性是什么",charIndex:1338},{level:2,title:"并发事务带来什么问题",slug:"并发事务带来什么问题",normalizedTitle:"并发事务带来什么问题",charIndex:1626},{level:2,title:"不可重复读和幻读区别",slug:"不可重复读和幻读区别",normalizedTitle:"不可重复读和幻读区别",charIndex:1811},{level:2,title:"SQL标志定义了哪些事务隔离级别",slug:"sql标志定义了哪些事务隔离级别",normalizedTitle:"sql标志定义了哪些事务隔离级别",charIndex:2e3},{level:2,title:"MySQL默认隔离级别是什么？能解决幻读问题吗",slug:"mysql默认隔离级别是什么-能解决幻读问题吗",normalizedTitle:"mysql默认隔离级别是什么？能解决幻读问题吗",charIndex:2362},{level:2,title:"什么是MVCC? 有什么用？原理是什么？（待完善）",slug:"什么是mvcc-有什么用-原理是什么-待完善",normalizedTitle:"什么是mvcc? 有什么用？原理是什么？（待完善）",charIndex:2728},{level:1,title:"MySQL锁",slug:"mysql锁",normalizedTitle:"mysql锁",charIndex:2796},{level:2,title:"表级锁和行级锁了解吗？有什么区别？",slug:"表级锁和行级锁了解吗-有什么区别",normalizedTitle:"表级锁和行级锁了解吗？有什么区别？",charIndex:2807},{level:2,title:"行级锁的使用有什么注意事项",slug:"行级锁的使用有什么注意事项",normalizedTitle:"行级锁的使用有什么注意事项",charIndex:3240},{level:2,title:"共享锁和排他锁呢",slug:"共享锁和排他锁呢",normalizedTitle:"共享锁和排他锁呢",charIndex:3441},{level:2,title:"当前读和快照读有什么区别",slug:"当前读和快照读有什么区别",normalizedTitle:"当前读和快照读有什么区别",charIndex:3736},{level:2,title:"InnoDB有哪几类行锁",slug:"innodb有哪几类行锁",normalizedTitle:"innodb有哪几类行锁",charIndex:4066},{level:1,title:"MySQL索引",slug:"mysql索引",normalizedTitle:"mysql索引",charIndex:4474},{level:2,title:"何为索引？有什么作用？",slug:"何为索引-有什么作用",normalizedTitle:"何为索引？有什么作用？",charIndex:4486},{level:2,title:"索引的优缺点",slug:"索引的优缺点",normalizedTitle:"索引的优缺点",charIndex:4642},{level:2,title:"索引的底层数据结构（待完善）",slug:"索引的底层数据结构-待完善",normalizedTitle:"索引的底层数据结构（待完善）",charIndex:4805},{level:2,title:"MySQL的索引结构为什么使用B+树？",slug:"mysql的索引结构为什么使用b-树",normalizedTitle:"mysql的索引结构为什么使用b+树？",charIndex:4849},{level:2,title:"主键索引和二级索引",slug:"主键索引和二级索引",normalizedTitle:"主键索引和二级索引",charIndex:5181},{level:2,title:"聚簇索引和非聚簇索引",slug:"聚簇索引和非聚簇索引",normalizedTitle:"聚簇索引和非聚簇索引",charIndex:5432},{level:2,title:"覆盖索引",slug:"覆盖索引",normalizedTitle:"覆盖索引",charIndex:5721},{level:2,title:"联合索引",slug:"联合索引",normalizedTitle:"联合索引",charIndex:5803},{level:2,title:"最左前缀匹配原则",slug:"最左前缀匹配原则",normalizedTitle:"最左前缀匹配原则",charIndex:5851},{level:2,title:"创建索引的注意事项有哪些",slug:"创建索引的注意事项有哪些",normalizedTitle:"创建索引的注意事项有哪些",charIndex:6077},{level:2,title:"哪些字段适合创建索引",slug:"哪些字段适合创建索引",normalizedTitle:"哪些字段适合创建索引",charIndex:6258},{level:2,title:"索引失效的情况",slug:"索引失效的情况",normalizedTitle:"索引失效的情况",charIndex:6359},{level:2,title:"如何让唯一索引和逻辑删除兼容",slug:"如何让唯一索引和逻辑删除兼容",normalizedTitle:"如何让唯一索引和逻辑删除兼容",charIndex:6505},{level:1,title:"MySQL日志",slug:"mysql日志",normalizedTitle:"mysql日志",charIndex:6633},{level:2,title:"MySQL常见的日志有哪些",slug:"mysql常见的日志有哪些",normalizedTitle:"mysql常见的日志有哪些",charIndex:6645},{level:2,title:"慢查询日志有什么用",slug:"慢查询日志有什么用",normalizedTitle:"慢查询日志有什么用",charIndex:7130},{level:2,title:"binlog 主要记录了什么？有什么用",slug:"binlog-主要记录了什么-有什么用",normalizedTitle:"binlog 主要记录了什么？有什么用",charIndex:7410},{level:2,title:"redo log 如何保证事务的持久性",slug:"redo-log-如何保证事务的持久性",normalizedTitle:"redo log 如何保证事务的持久性",charIndex:7660},{level:2,title:"页修改之后为什么不直接刷盘呢",slug:"页修改之后为什么不直接刷盘呢",normalizedTitle:"页修改之后为什么不直接刷盘呢",charIndex:7940},{level:2,title:"binlog 和redolog有什么区别",slug:"binlog-和redolog有什么区别",normalizedTitle:"binlog 和redolog有什么区别",charIndex:8167},{level:2,title:"undo log 如何保证事务的原子性",slug:"undo-log-如何保证事务的原子性",normalizedTitle:"undo log 如何保证事务的原子性",charIndex:8512},{level:1,title:"调优",slug:"调优",normalizedTitle:"调优",charIndex:7383},{level:2,title:"SQL优化",slug:"sql优化",normalizedTitle:"sql优化",charIndex:8702},{level:2,title:"MySQL limit深度分页优化",slug:"mysql-limit深度分页优化",normalizedTitle:"mysql limit深度分页优化",charIndex:9869},{level:1,title:"MySQL 读写分离",slug:"mysql-读写分离",normalizedTitle:"mysql 读写分离",charIndex:10063},{level:2,title:"读写分离延迟如何解决",slug:"读写分离延迟如何解决",normalizedTitle:"读写分离延迟如何解决",charIndex:10078}],headersStr:"MySQL 体系结构 MySQL 逻辑架构 一条SQL语句在MySQL中是怎么执行的 MySQL存储引擎 MySQL提供了哪些存储引擎 MySQL存储引擎架构了解吗 MyISAM和InnoDB区别 MySQL 事务 什么是事务 什么是数据库事务 ACID特性是什么 并发事务带来什么问题 不可重复读和幻读区别 SQL标志定义了哪些事务隔离级别 MySQL默认隔离级别是什么？能解决幻读问题吗 什么是MVCC? 有什么用？原理是什么？（待完善） MySQL锁 表级锁和行级锁了解吗？有什么区别？ 行级锁的使用有什么注意事项 共享锁和排他锁呢 当前读和快照读有什么区别 InnoDB有哪几类行锁 MySQL索引 何为索引？有什么作用？ 索引的优缺点 索引的底层数据结构（待完善） MySQL的索引结构为什么使用B+树？ 主键索引和二级索引 聚簇索引和非聚簇索引 覆盖索引 联合索引 最左前缀匹配原则 创建索引的注意事项有哪些 哪些字段适合创建索引 索引失效的情况 如何让唯一索引和逻辑删除兼容 MySQL日志 MySQL常见的日志有哪些 慢查询日志有什么用 binlog 主要记录了什么？有什么用 redo log 如何保证事务的持久性 页修改之后为什么不直接刷盘呢 binlog 和redolog有什么区别 undo log 如何保证事务的原子性 调优 SQL优化 MySQL limit深度分页优化 MySQL 读写分离 读写分离延迟如何解决",content:"# MySQL 体系结构\n\n\n# MySQL 逻辑架构\n\nMySQL 逻辑架构分为三层：\n\n * 第一层的连接层是进行连接管理的，包括连接处理、身份认证、权限获取、安全等功能。连接层有个线程池，MySQL会从线程池分配一个线程与客户端进行交互，省去创建和销毁线程开销。\n * 第二层是服务层，包括SQL接口、解析器、优化器、查询缓存。\n   * SQL接口用来接收SQL命令。并返回结果，支持DML、DDL、存储过程、视图、触发器等多种SQL语言接口。\n   * 解析器是验证和解析SQL，并创建语法树\n   * 优化器生成执行计划，并按照执行计划调用存储引擎的API方法执行查询\n   * 查询缓存会缓存查询结果，不必进行查询解析、优化、执行等过程，直接将结果返回。在MySQL8.0中移除。\n * 第三层是存储引擎层。主要负责数据的存储与提取。\n\n\n# 一条SQL语句在MySQL中是怎么执行的\n\n 1. 服务器中如果在查询缓存中发现这条SQL，就会直接将结果返回，否则进入解析器阶段。\n 2. **解析器 **对SQL语句进行语法分析、语义检查。如果SQL语句正确的话就会生成一个语法树。\n 3. 优化器会对SQL语句进行优化，并确定SQL语句的执行计划。\n 4. 执行器在执行之前判断用户是否具备权限。如果没有权限，返回权限错误。如果具备权限的话，就执行SQL语句并返回结果。如果设置了查询缓存，会将结果进行缓存。\n\n\n# MySQL存储引擎\n\n\n# MySQL提供了哪些存储引擎\n\n可以通过show engines查看MySQL所有存储引擎。最常见的存储引擎是InnoDB和MyISAM。MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。\n\n\n# MySQL存储引擎架构了解吗\n\nMySQL 存储引擎采用的是插件式架构，支持多种存储引擎。存储引擎是基于表的，而不是数据库，可以为不同的数据库表设置不同的存储引擎。\n\n\n# MyISAM和InnoDB区别\n\n 1. 是否支持行级锁：MyISAM只支持表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁。\n 2. 是否支持事务：MyISAM不支持事务，InnoDB支持事务。\n 3. 是否支持外键：MyISAM不支持外键，InnoDB支持外键。\n 4. 是否支持数据库异常崩溃后的安全恢复：MyISAM不支持，InnoDB支持。InnoDB通过redo log保证数据库崩溃后能安全恢复。\n 5. 是否支持MVCC：MyISAM不支持，InnoDB支持。\n 6. 索引实现不一样：MyISAM和InnoDB虽然都是使用B+ Tree实现索引，但是实现方式不太一样，InnoDB的聚簇索引叶子节点存储完整数据，而MyISAM叶子节点存储的是数据记录的地址。\n\n\n# MySQL 事务\n\n\n# 什么是事务\n\n事务是逻辑上的一组操作，事务中的操作要么全都执行，要么全都不执行。\n\n\n# 什么是数据库事务\n\n数据库事务保证多个对数据库的操作（也就是SQL）构成一个逻辑上的整体。这些操作要么全部执行成功，要么全部不执行。\n\n\n# ACID特性是什么\n\n * 原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保事务中操作要么全部完成，要么全都不完成。\n * 一致性（Consistency）：事务前后数据要保持一致。\n * 隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。\n * 持久性（Durability）：事务一旦被提交，将永久的保存到数据库，即使是数据库发生故障也不应该对其有任何影响。\n\n只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的\n\n\n# 并发事务带来什么问题\n\n * 脏读（Dirty read）：一个事务读取另一个事务未提交数据\n * 丢失更新（Lost to modify）：一个事务对数据的修改被另一个事务所覆盖\n * 不可重复读：一个事务两次读取相同数据，在这期间，另一个事务对数据进行修改，导致第一个事务两次读取的数据不一致\n * 幻读：一个事务多次读取数据不一致，发现读取到的数据增加了\n\n\n# 不可重复读和幻读区别\n\n * 不可重复读的重点是内容修改或者记录减少。比如指多次读取一条记录，发现其中某些记录的值被修改。\n * 幻读的重点在于记录新增。比如多次执行同一条查询语句，发现查询到记录增加了。\n\n> delete和update操作，可以直接对记录加锁，保证事务安全。 而执行insert操作时，记录锁只能锁住已存在记录，为了避免插入新记录，需要使用间隙锁。\n\n\n# SQL标志定义了哪些事务隔离级别\n\nSQL标志定义了四个隔离级别：\n\n * READ-UNCOMMITTED(读取未提交) ： 最低的隔离级别，允许读取尚未提交的数据，可能会导致脏读、幻读或不可重复读。\n * READ-COMMITTED(读取已提交) ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。\n * REPEATABLE-READ(可重复读) ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。\n * SERIALIZABLE(可串行化) ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。\n\n\n# MySQL默认隔离级别是什么？能解决幻读问题吗\n\nMySQL InnoDB存储引擎默认隔离级别是REPEATABLE-READ（可重复读）。可以通过SELECT @@tx_isolation;命令查看， MySQL 8.0 该命令改为SELECT @@transaction_isolation; InnoDB实现的 REPEATABLE-READ 隔离级别可以解决幻读问题，主要通过MVCC和Next-key Lock解决幻读问题：\n\n * 快照读：由MVCC机制来保证不会出现幻读。\n * 当前读： 使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是记录锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。\n\n\n# 什么是MVCC? 有什么用？原理是什么？（待完善）\n\nMVCC是多版本并发控制，是InnoDB存储引擎对非锁定一致性读的实现。\n\n\n# MySQL锁\n\n\n# 表级锁和行级锁了解吗？有什么区别？\n\nMyISAM仅仅支持表级锁，一锁就锁整张表，这在并发写的情况下性能非常差。InnoDB不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录进行加锁（对一行或者多行记录进行加锁），所以对于并发写的情况下，InnoDB的性能更高。 表级锁和行级锁对比：\n\n * 表级锁： MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。\n * 行级锁： MySQL 中锁定粒度最小的一种锁，是 针对索引字段加的锁 ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。\n\n\n# 行级锁的使用有什么注意事项\n\nInnoDB行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 UPDATE、DELETE 语句时，如果 WHERE条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！ 不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。\n\n\n# 共享锁和排他锁呢\n\n不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：\n\n * 共享锁（S 锁） ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。\n * 排他锁（X 锁） ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。\n\n排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。\n\n      S 锁   X 锁\nS 锁   不冲突   冲突\nX 锁   冲突    冲突\n\n\n# 当前读和快照读有什么区别\n\n快照读（一致性非锁定读）就是单纯的 SELECT 语句，但不包括下面这两类 SELECT 语句：\n\nSELECT ... FOR UPDATE\nSELECT ... LOCK IN SHARE MODE\n\n\n\n快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。\n\n当前读 （一致性锁定读）就是给行记录加 X 锁或 S 锁。 当前读的一些常见 SQL 语句类型如下：\n\n# 对读的记录加一个X锁\nSELECT...FOR UPDATE\n# 对读的记录加一个S锁\nSELECT...LOCK IN SHARE MODE\n# 对修改的记录加一个X锁\nINSERT...\nUPDATE...\nDELETE...\n\n\n\n\n# InnoDB有哪几类行锁\n\nInnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：\n\n * 记录锁（Record Lock） ：也被称为记录锁，属于单个行记录上的锁。\n * 间隙锁（Gap Lock） ：锁定一个范围，不包括记录本身。\n * 临键锁（Next-Key Lock） ：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。\n\n在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。\n\n\n# MySQL索引\n\n\n# 何为索引？有什么作用？\n\n索引是一种帮助MySQL高效获取数据的数据结构，由具体的存储引擎实现。索引相当于书的目录，有了目录就可以直接定位到我们要查找的数据，无须一页一页的进行查找。常见的索引结构有：B树、B+树、Hash、红黑树。在MySQL中，InnoDB和MyISAM都使用了B+树作为索引结构。\n\n\n# 索引的优缺点\n\n优点：\n\n * 索引可以提高查询效率，这是创建索引最主要的原因。\n * 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性\n\n缺点：\n\n * 创建和维护索引需要一定开销，当对表中的数据进行增删改操作时，索引也要动态的修改，会降低SQL执行效率。\n * 索引需要使用物理文件存储，也会耗费一定空间。\n\n\n# 索引的底层数据结构（待完善）\n\n索引的底层数据结构：Hash表、B树、B+树。\n\n\n# MySQL的索引结构为什么使用B+树？\n\n * 二叉查找树(BST)：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表；\n * 平衡二叉树(AVL)：通过旋转解决了平衡的问题，但是旋转操作效率太低；\n * 红黑树：通过舍弃严格的平衡和引入红黑节点，解决了AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多；\n * B树：通过将二叉树改为多路平衡查找树，解决了树过高的问题；\n * B+树：在B树的基础上，将非叶节点改造为不存储数据的纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效。\n\n参考资料：https://www.cnblogs.com/kismetv/p/11582214.html\n\n\n# 主键索引和二级索引\n\n主键索引：数据表的主键列使用的就是主键索引。一张数据表只能有一个主键，并且不为null，不能重复。在MySQL的InnoDB表中，如果没有显示的指定表的主键，InnoDB会自动检查表中是否有唯一索引并且不允许为null 值的字段，有的话，默认该字段未默认的主键，否则InnoDB将自动创建一个自增主键。 二级索引（辅助索引）：二级索引又称为辅助索引，因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。普通索引，唯一索引等都属于二级索引。\n\n\n# 聚簇索引和非聚簇索引\n\n**聚簇索引：聚簇索引即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。**聚簇索引的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。聚簇索引的查询速度非常快，因为数据是直接存储在叶子节点。 非聚簇索引：**非聚簇索引即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。**非聚簇索叶子节点是不存放数据的。innoDB使用非聚簇索引大部分情况下都需要进行回表操作，除非使用覆盖索引，才不用回表。\n\n\n# 覆盖索引\n\n非聚簇索引查询数据时，如果查询语句所用到字段包含在索引字段+主键，此时就无须进行回表操作，可以直接将数据返回。\n\n\n# 联合索引\n\n使用表中的多个字段创建索引，就是 联合索引，也叫 组合索引 或 复合索引。\n\n\n# 最左前缀匹配原则\n\n最左前缀匹配原则指的是，在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 >、<、between 和 以%开头的like查询 等条件，才会停止匹配。 所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。\n\n\n# 创建索引的注意事项有哪些\n\n * 选择合适的字段创建索引\n * 频繁更新的字段应该慎重建立索引\n * 尽可能的考虑建立联合索引而不是单列索引\n * 避免索引失效\n * 删除长期未使用的索引： 不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用\n\n\n# 哪些字段适合创建索引\n\n * 具有唯一特性的字段应当建立唯一索引\n * 频繁作为where查询条件的字段\n * 经常order by，group by的字段\n * 联合查询时连接条件用到的字段\n\n\n# 索引失效的情况\n\n * 创建了组合索引，但查询条件未准守最左匹配原则;\n * 在索引列上进行计算、函数、类型转换等操作;\n * 以 % 开头的 LIKE 查询比如 like '%abc';\n * 查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到\n\n\n# 如何让唯一索引和逻辑删除兼容\n\n通过唯一索引和逻辑删除字段建立联合唯一索引。如果数据被删除，逻辑删除字段的值就是当前数据的id。\n\n参考：https://blog.csdn.net/Park33/article/details/130015392\n\n\n# MySQL日志\n\n\n# MySQL常见的日志有哪些\n\nMySQL中常见的日志类型主要有下面几类（针对的是InnoDB存储引擎）：\n\n * 错误日志（error log）：对MySQL的启动、运行、关闭过程进行了记录。\n * 二进制日志（binary log，binlog）：主要记录的是更改数据库数据的SQL语句\n * 一般查询日志（general query log）：已建立连接的客户端发送给MySQL服务器的所有SQL记录，因为SQL的量比较大，默认是不开启的，也不建议开启。\n * 慢查询日志（show query log）：执行时间超过long_query_time秒钟的查询，解决SQL慢查询问题会用到。\n * 事务日志（redo log 和undo log）：redo log是重做日志，undo log 是回滚日志。\n * 中继日志（relay log）：relay log 是复制过程中产生的日志，很多方面都跟binary log差不多。不过，relay log 针对的是主从复制中的从库。\n * DDL日志（metadata log）：DDL语句执行的元数据操作。\n\n\n# 慢查询日志有什么用\n\n慢查询日志记录了执行时间超过long_query_time（默认是10s，通常设置为1s）的所有查询语句，在解决SQL慢查询（SQL执行时间长）问题经常会用到。 找到慢SQL是优化SQL语句性能的第一步，然后使用EXPLAIN命名对慢SQL进行分析，获取执行计划。 可以通过show_query_log和long_query_time变量分别查看慢查询日志是否开启（默认关闭）和慢查询时间阈值。 在实际开发中，慢查询日志可能会比较大，直接分析不方便，可以借助MySQL官方的慢查询分析调优工具mysqldumpslow进行分析。\n\n\n# binlog 主要记录了什么？有什么用\n\nMySQL binlog（binary log 即二进制日志文件）主要记录了MySQL数据库中数据的所有变化（数据库执行的所有DDL和DML语句）。binlog最主要的应用场景是主从复制，主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据的一致性。此外，binlog还能帮忙我们进行数据恢复，在启用binlog日志情况下（默认是开启的），当我们误删数据甚至是整个数据库的情况下，就可以使用binlog来帮忙我们恢复数据。\n\n\n# redo log 如何保证事务的持久性\n\nredo log 主要做的事情就是记录页的修改，比如某个页面某个偏移量处修改了几个字节的值以及具体被修改的内容是什么。在事务提交时，我们会将redo log按照刷盘策略刷到磁盘上去，这样即使 MySQL 宕机了，重启之后也能恢复未能写入磁盘的数据，从而保证事务的持久性。\n\n> InnoDB存储引擎使用Buffer Pool（缓冲池）来提高读写性能。当一个事务提交之后，缓冲池的对应页的修改还未持久化到磁盘，这时，如果MySQL突然宕机的话，事务的更改是不是直接就消失了?redo log就是来解决这个问题的\n\n\n# 页修改之后为什么不直接刷盘呢\n\n直接刷盘性能非常差！InnoDB页的大小一般为16KB，而页又是磁盘和内存交互的基本单位。这就导致即使我们只修改页中的几个字节数据，一次刷盘操作也就将16KB 大小的页整个都刷新到磁盘中。而且，这些修改的页可能并不相邻，也就是说这还是随机IO。 采用redo log 的方式可以避免这种性能问题，因为redo log的刷盘性能很好。redo log的写入属于顺序IO，并且一行redo log记录只占几十个字节。\n\n\n# binlog 和redolog有什么区别\n\n * 用途：binlog主要用于数据库还原，属于数据级别的数据恢复，主从复制是binlog最常见的一个应用场景。redolog主要用于保证事务的持久性，属于事务级别的数据恢复。\n * 是否是InnoDB引擎特有的：redolog属于InnoDB引擎特有的，binlog属于所有存储引擎共有的。因为binlog是MySQL的Server层实现的。\n * redolog属于物理日志，主要记录的某个页的修改。binlog属于逻辑日志，主要记录的是数据库执行的所有DDL和DML语句。\n * 写入方式：binlog通过追加的方式进行写入，大小没有限制。redo log 采用循环写的方式进行写入，大小固定，当写到结尾时，会回到开头循环写日志。\n\n\n# undo log 如何保证事务的原子性\n\n每一个事务对数据的修改都会被记录到undo log，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL可以利用undo log将数据恢复到事务开始之前的状态。 undo log 属于逻辑日志，记录的是SQL语句，比如说事务执行一条DELETE语句，那undo log就会记录一条相对于的INSERT语句。\n\n\n# 调优\n\n\n# SQL优化\n\n 1.  **避免使用select ***：select * 会查询多余的数据，造成数据库资源浪费和数据传输消耗。而且select * 不会走覆盖索引，会出现大量的回表操作，降低查询sql的性能。\n 2.  用union all 代替union：union 需要排重，排重过程需要遍历、排序和比较，更耗时，也更消耗cpu资源。\n 3.  小表驱动大表：也就是说用小表的数据集驱动大表的数据集。 in 适用于左边大表，右边小表。exists 适用于左边小表，右边大表。这两个核心思想都是用小表驱动大表。使用left join 时左边应该是小表\n 4.  批量操作：一次性操作适度数据。如果操作的数据量较大时，可以分多批次处理。\n 5.  多用limit：当只需要数据中第一条时，使用limit 1，当数据库找到符合的条件的一条数据就直接返回结果，大大提高了提升了性能。\n 6.  用连接查询代替子查询：MySQL 执行子查询时，需要创建临时表，查询完毕后，需要再删除这些临时表，有一些额外的性能消耗。\n 7.  join的表不宜过多：join 表的数量不应该超过3个，必要时表中可以存在冗余字段\n 8.  控制索引数量：优先使用联合索引，并且删除无用的单列索引。\n 9.  选择合理的字段类型：\n     1. 能用数字类型，就不用字符串，因为字符的处理往往比数字要慢。\n     2. 尽可能使用小的类型，比如：用bit存布尔值，用tinyint存枚举值等。\n     3. 长度固定的字符串字段，用char类型。\n     4. 长度可变的字符串字段，用varchar类型。\n     5. 金额字段用decimal，避免精度丢失问题。\n 10. 提高group by 效率：使用group by 分组时，优化在where 子句分组前进行过滤，而不是在having分组后进行过滤。\n 11. 索引优化：使用explian查看执行计划，看sql是否走了索引，如果没有走索引，看是否建立了索引或者索引是否失效并进行相应的处理。\n\n> 参考：\n> \n>  * https://cloud.tencent.com/developer/article/1899907\n>  * https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247488618&idx=1&sn=e70a31865b5eadcb151f439004a4dd72&chksm=cea25ba1f9d5d2b795222ba90e0326618d649e858ec23e9c7360f90fbfc23a7786c33bff9556&token=1647609083&lang=zh_CN#rd\n\n\n# MySQL limit深度分页优化\n\n原因：MySQL分页到后面越来越慢，其实是进行大量无用回表操作造成（前面数据都不需要，也进行了回表操作）。 解决方案：使用 join+覆盖索引 进行优化。使用覆盖索引查询对应数据主键，再join获取到完整数据，避免大量回表操作。\n\n> 参考：https://mp.weixin.qq.com/s/fNN77OxZbokcl7ax1tdZBA\n\n\n# MySQL 读写分离\n\n\n# 读写分离延迟如何解决\n\n技术上没想到方法。业务上如果要求强一致性，就都读主库，如果不要求强一致性，就读从库。",normalizedContent:"# mysql 体系结构\n\n\n# mysql 逻辑架构\n\nmysql 逻辑架构分为三层：\n\n * 第一层的连接层是进行连接管理的，包括连接处理、身份认证、权限获取、安全等功能。连接层有个线程池，mysql会从线程池分配一个线程与客户端进行交互，省去创建和销毁线程开销。\n * 第二层是服务层，包括sql接口、解析器、优化器、查询缓存。\n   * sql接口用来接收sql命令。并返回结果，支持dml、ddl、存储过程、视图、触发器等多种sql语言接口。\n   * 解析器是验证和解析sql，并创建语法树\n   * 优化器生成执行计划，并按照执行计划调用存储引擎的api方法执行查询\n   * 查询缓存会缓存查询结果，不必进行查询解析、优化、执行等过程，直接将结果返回。在mysql8.0中移除。\n * 第三层是存储引擎层。主要负责数据的存储与提取。\n\n\n# 一条sql语句在mysql中是怎么执行的\n\n 1. 服务器中如果在查询缓存中发现这条sql，就会直接将结果返回，否则进入解析器阶段。\n 2. **解析器 **对sql语句进行语法分析、语义检查。如果sql语句正确的话就会生成一个语法树。\n 3. 优化器会对sql语句进行优化，并确定sql语句的执行计划。\n 4. 执行器在执行之前判断用户是否具备权限。如果没有权限，返回权限错误。如果具备权限的话，就执行sql语句并返回结果。如果设置了查询缓存，会将结果进行缓存。\n\n\n# mysql存储引擎\n\n\n# mysql提供了哪些存储引擎\n\n可以通过show engines查看mysql所有存储引擎。最常见的存储引擎是innodb和myisam。mysql 5.5.5 之前，myisam 是 mysql 的默认存储引擎。5.5.5 版本之后，innodb 是 mysql 的默认存储引擎。\n\n\n# mysql存储引擎架构了解吗\n\nmysql 存储引擎采用的是插件式架构，支持多种存储引擎。存储引擎是基于表的，而不是数据库，可以为不同的数据库表设置不同的存储引擎。\n\n\n# myisam和innodb区别\n\n 1. 是否支持行级锁：myisam只支持表级锁，而innodb支持行级锁和表级锁，默认为行级锁。\n 2. 是否支持事务：myisam不支持事务，innodb支持事务。\n 3. 是否支持外键：myisam不支持外键，innodb支持外键。\n 4. 是否支持数据库异常崩溃后的安全恢复：myisam不支持，innodb支持。innodb通过redo log保证数据库崩溃后能安全恢复。\n 5. 是否支持mvcc：myisam不支持，innodb支持。\n 6. 索引实现不一样：myisam和innodb虽然都是使用b+ tree实现索引，但是实现方式不太一样，innodb的聚簇索引叶子节点存储完整数据，而myisam叶子节点存储的是数据记录的地址。\n\n\n# mysql 事务\n\n\n# 什么是事务\n\n事务是逻辑上的一组操作，事务中的操作要么全都执行，要么全都不执行。\n\n\n# 什么是数据库事务\n\n数据库事务保证多个对数据库的操作（也就是sql）构成一个逻辑上的整体。这些操作要么全部执行成功，要么全部不执行。\n\n\n# acid特性是什么\n\n * 原子性（atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保事务中操作要么全部完成，要么全都不完成。\n * 一致性（consistency）：事务前后数据要保持一致。\n * 隔离性（isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。\n * 持久性（durability）：事务一旦被提交，将永久的保存到数据库，即使是数据库发生故障也不应该对其有任何影响。\n\n只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 a、i、d 是手段，c 是目的\n\n\n# 并发事务带来什么问题\n\n * 脏读（dirty read）：一个事务读取另一个事务未提交数据\n * 丢失更新（lost to modify）：一个事务对数据的修改被另一个事务所覆盖\n * 不可重复读：一个事务两次读取相同数据，在这期间，另一个事务对数据进行修改，导致第一个事务两次读取的数据不一致\n * 幻读：一个事务多次读取数据不一致，发现读取到的数据增加了\n\n\n# 不可重复读和幻读区别\n\n * 不可重复读的重点是内容修改或者记录减少。比如指多次读取一条记录，发现其中某些记录的值被修改。\n * 幻读的重点在于记录新增。比如多次执行同一条查询语句，发现查询到记录增加了。\n\n> delete和update操作，可以直接对记录加锁，保证事务安全。 而执行insert操作时，记录锁只能锁住已存在记录，为了避免插入新记录，需要使用间隙锁。\n\n\n# sql标志定义了哪些事务隔离级别\n\nsql标志定义了四个隔离级别：\n\n * read-uncommitted(读取未提交) ： 最低的隔离级别，允许读取尚未提交的数据，可能会导致脏读、幻读或不可重复读。\n * read-committed(读取已提交) ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。\n * repeatable-read(可重复读) ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。\n * serializable(可串行化) ： 最高的隔离级别，完全服从 acid 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。\n\n\n# mysql默认隔离级别是什么？能解决幻读问题吗\n\nmysql innodb存储引擎默认隔离级别是repeatable-read（可重复读）。可以通过select @@tx_isolation;命令查看， mysql 8.0 该命令改为select @@transaction_isolation; innodb实现的 repeatable-read 隔离级别可以解决幻读问题，主要通过mvcc和next-key lock解决幻读问题：\n\n * 快照读：由mvcc机制来保证不会出现幻读。\n * 当前读： 使用 next-key lock 进行加锁来保证不出现幻读，next-key lock 是记录锁（record lock）和间隙锁（gap lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。\n\n\n# 什么是mvcc? 有什么用？原理是什么？（待完善）\n\nmvcc是多版本并发控制，是innodb存储引擎对非锁定一致性读的实现。\n\n\n# mysql锁\n\n\n# 表级锁和行级锁了解吗？有什么区别？\n\nmyisam仅仅支持表级锁，一锁就锁整张表，这在并发写的情况下性能非常差。innodb不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录进行加锁（对一行或者多行记录进行加锁），所以对于并发写的情况下，innodb的性能更高。 表级锁和行级锁对比：\n\n * 表级锁： mysql 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，myisam 和 innodb 引擎都支持表级锁。\n * 行级锁： mysql 中锁定粒度最小的一种锁，是 针对索引字段加的锁 ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。\n\n\n# 行级锁的使用有什么注意事项\n\ninnodb行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 update、delete 语句时，如果 where条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！ 不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 mysql 优化器的原因。\n\n\n# 共享锁和排他锁呢\n\n不论是表级锁还是行级锁，都存在共享锁（share lock，s 锁）和排他锁（exclusive lock，x 锁）这两类：\n\n * 共享锁（s 锁） ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。\n * 排他锁（x 锁） ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。\n\n排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。\n\n      s 锁   x 锁\ns 锁   不冲突   冲突\nx 锁   冲突    冲突\n\n\n# 当前读和快照读有什么区别\n\n快照读（一致性非锁定读）就是单纯的 select 语句，但不包括下面这两类 select 语句：\n\nselect ... for update\nselect ... lock in share mode\n\n\n\n快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。\n\n当前读 （一致性锁定读）就是给行记录加 x 锁或 s 锁。 当前读的一些常见 sql 语句类型如下：\n\n# 对读的记录加一个x锁\nselect...for update\n# 对读的记录加一个s锁\nselect...lock in share mode\n# 对修改的记录加一个x锁\ninsert...\nupdate...\ndelete...\n\n\n\n\n# innodb有哪几类行锁\n\ninnodb 行锁是通过对索引数据页上的记录加锁实现的，mysql innodb 支持三种行锁定方式：\n\n * 记录锁（record lock） ：也被称为记录锁，属于单个行记录上的锁。\n * 间隙锁（gap lock） ：锁定一个范围，不包括记录本身。\n * 临键锁（next-key lock） ：record lock+gap lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（mysql 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。\n\n在 innodb 默认的隔离级别 repeatable-read 下，行锁默认使用的是 next-key lock。但是，如果操作的索引是唯一索引或主键，innodb 会对 next-key lock 进行优化，将其降级为 record lock，即仅锁住索引本身，而不是范围。\n\n\n# mysql索引\n\n\n# 何为索引？有什么作用？\n\n索引是一种帮助mysql高效获取数据的数据结构，由具体的存储引擎实现。索引相当于书的目录，有了目录就可以直接定位到我们要查找的数据，无须一页一页的进行查找。常见的索引结构有：b树、b+树、hash、红黑树。在mysql中，innodb和myisam都使用了b+树作为索引结构。\n\n\n# 索引的优缺点\n\n优点：\n\n * 索引可以提高查询效率，这是创建索引最主要的原因。\n * 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性\n\n缺点：\n\n * 创建和维护索引需要一定开销，当对表中的数据进行增删改操作时，索引也要动态的修改，会降低sql执行效率。\n * 索引需要使用物理文件存储，也会耗费一定空间。\n\n\n# 索引的底层数据结构（待完善）\n\n索引的底层数据结构：hash表、b树、b+树。\n\n\n# mysql的索引结构为什么使用b+树？\n\n * 二叉查找树(bst)：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表；\n * 平衡二叉树(avl)：通过旋转解决了平衡的问题，但是旋转操作效率太低；\n * 红黑树：通过舍弃严格的平衡和引入红黑节点，解决了avl旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，io次数太多；\n * b树：通过将二叉树改为多路平衡查找树，解决了树过高的问题；\n * b+树：在b树的基础上，将非叶节点改造为不存储数据的纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效。\n\n参考资料：https://www.cnblogs.com/kismetv/p/11582214.html\n\n\n# 主键索引和二级索引\n\n主键索引：数据表的主键列使用的就是主键索引。一张数据表只能有一个主键，并且不为null，不能重复。在mysql的innodb表中，如果没有显示的指定表的主键，innodb会自动检查表中是否有唯一索引并且不允许为null 值的字段，有的话，默认该字段未默认的主键，否则innodb将自动创建一个自增主键。 二级索引（辅助索引）：二级索引又称为辅助索引，因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。普通索引，唯一索引等都属于二级索引。\n\n\n# 聚簇索引和非聚簇索引\n\n**聚簇索引：聚簇索引即索引结构和数据一起存放的索引，并不是一种单独的索引类型。innodb 中的主键索引就属于聚簇索引。**聚簇索引的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。聚簇索引的查询速度非常快，因为数据是直接存储在叶子节点。 非聚簇索引：**非聚簇索引即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。mysql 的 myisam 引擎，不管主键还是非主键，使用的都是非聚簇索引。**非聚簇索叶子节点是不存放数据的。innodb使用非聚簇索引大部分情况下都需要进行回表操作，除非使用覆盖索引，才不用回表。\n\n\n# 覆盖索引\n\n非聚簇索引查询数据时，如果查询语句所用到字段包含在索引字段+主键，此时就无须进行回表操作，可以直接将数据返回。\n\n\n# 联合索引\n\n使用表中的多个字段创建索引，就是 联合索引，也叫 组合索引 或 复合索引。\n\n\n# 最左前缀匹配原则\n\n最左前缀匹配原则指的是，在使用联合索引时，mysql 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 >、<、between 和 以%开头的like查询 等条件，才会停止匹配。 所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。\n\n\n# 创建索引的注意事项有哪些\n\n * 选择合适的字段创建索引\n * 频繁更新的字段应该慎重建立索引\n * 尽可能的考虑建立联合索引而不是单列索引\n * 避免索引失效\n * 删除长期未使用的索引： 不用的索引的存在会造成不必要的性能损耗 mysql 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用\n\n\n# 哪些字段适合创建索引\n\n * 具有唯一特性的字段应当建立唯一索引\n * 频繁作为where查询条件的字段\n * 经常order by，group by的字段\n * 联合查询时连接条件用到的字段\n\n\n# 索引失效的情况\n\n * 创建了组合索引，但查询条件未准守最左匹配原则;\n * 在索引列上进行计算、函数、类型转换等操作;\n * 以 % 开头的 like 查询比如 like '%abc';\n * 查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到\n\n\n# 如何让唯一索引和逻辑删除兼容\n\n通过唯一索引和逻辑删除字段建立联合唯一索引。如果数据被删除，逻辑删除字段的值就是当前数据的id。\n\n参考：https://blog.csdn.net/park33/article/details/130015392\n\n\n# mysql日志\n\n\n# mysql常见的日志有哪些\n\nmysql中常见的日志类型主要有下面几类（针对的是innodb存储引擎）：\n\n * 错误日志（error log）：对mysql的启动、运行、关闭过程进行了记录。\n * 二进制日志（binary log，binlog）：主要记录的是更改数据库数据的sql语句\n * 一般查询日志（general query log）：已建立连接的客户端发送给mysql服务器的所有sql记录，因为sql的量比较大，默认是不开启的，也不建议开启。\n * 慢查询日志（show query log）：执行时间超过long_query_time秒钟的查询，解决sql慢查询问题会用到。\n * 事务日志（redo log 和undo log）：redo log是重做日志，undo log 是回滚日志。\n * 中继日志（relay log）：relay log 是复制过程中产生的日志，很多方面都跟binary log差不多。不过，relay log 针对的是主从复制中的从库。\n * ddl日志（metadata log）：ddl语句执行的元数据操作。\n\n\n# 慢查询日志有什么用\n\n慢查询日志记录了执行时间超过long_query_time（默认是10s，通常设置为1s）的所有查询语句，在解决sql慢查询（sql执行时间长）问题经常会用到。 找到慢sql是优化sql语句性能的第一步，然后使用explain命名对慢sql进行分析，获取执行计划。 可以通过show_query_log和long_query_time变量分别查看慢查询日志是否开启（默认关闭）和慢查询时间阈值。 在实际开发中，慢查询日志可能会比较大，直接分析不方便，可以借助mysql官方的慢查询分析调优工具mysqldumpslow进行分析。\n\n\n# binlog 主要记录了什么？有什么用\n\nmysql binlog（binary log 即二进制日志文件）主要记录了mysql数据库中数据的所有变化（数据库执行的所有ddl和dml语句）。binlog最主要的应用场景是主从复制，主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据的一致性。此外，binlog还能帮忙我们进行数据恢复，在启用binlog日志情况下（默认是开启的），当我们误删数据甚至是整个数据库的情况下，就可以使用binlog来帮忙我们恢复数据。\n\n\n# redo log 如何保证事务的持久性\n\nredo log 主要做的事情就是记录页的修改，比如某个页面某个偏移量处修改了几个字节的值以及具体被修改的内容是什么。在事务提交时，我们会将redo log按照刷盘策略刷到磁盘上去，这样即使 mysql 宕机了，重启之后也能恢复未能写入磁盘的数据，从而保证事务的持久性。\n\n> innodb存储引擎使用buffer pool（缓冲池）来提高读写性能。当一个事务提交之后，缓冲池的对应页的修改还未持久化到磁盘，这时，如果mysql突然宕机的话，事务的更改是不是直接就消失了?redo log就是来解决这个问题的\n\n\n# 页修改之后为什么不直接刷盘呢\n\n直接刷盘性能非常差！innodb页的大小一般为16kb，而页又是磁盘和内存交互的基本单位。这就导致即使我们只修改页中的几个字节数据，一次刷盘操作也就将16kb 大小的页整个都刷新到磁盘中。而且，这些修改的页可能并不相邻，也就是说这还是随机io。 采用redo log 的方式可以避免这种性能问题，因为redo log的刷盘性能很好。redo log的写入属于顺序io，并且一行redo log记录只占几十个字节。\n\n\n# binlog 和redolog有什么区别\n\n * 用途：binlog主要用于数据库还原，属于数据级别的数据恢复，主从复制是binlog最常见的一个应用场景。redolog主要用于保证事务的持久性，属于事务级别的数据恢复。\n * 是否是innodb引擎特有的：redolog属于innodb引擎特有的，binlog属于所有存储引擎共有的。因为binlog是mysql的server层实现的。\n * redolog属于物理日志，主要记录的某个页的修改。binlog属于逻辑日志，主要记录的是数据库执行的所有ddl和dml语句。\n * 写入方式：binlog通过追加的方式进行写入，大小没有限制。redo log 采用循环写的方式进行写入，大小固定，当写到结尾时，会回到开头循环写日志。\n\n\n# undo log 如何保证事务的原子性\n\n每一个事务对数据的修改都会被记录到undo log，当执行事务过程中出现错误或者需要执行回滚操作的话，mysql可以利用undo log将数据恢复到事务开始之前的状态。 undo log 属于逻辑日志，记录的是sql语句，比如说事务执行一条delete语句，那undo log就会记录一条相对于的insert语句。\n\n\n# 调优\n\n\n# sql优化\n\n 1.  **避免使用select ***：select * 会查询多余的数据，造成数据库资源浪费和数据传输消耗。而且select * 不会走覆盖索引，会出现大量的回表操作，降低查询sql的性能。\n 2.  用union all 代替union：union 需要排重，排重过程需要遍历、排序和比较，更耗时，也更消耗cpu资源。\n 3.  小表驱动大表：也就是说用小表的数据集驱动大表的数据集。 in 适用于左边大表，右边小表。exists 适用于左边小表，右边大表。这两个核心思想都是用小表驱动大表。使用left join 时左边应该是小表\n 4.  批量操作：一次性操作适度数据。如果操作的数据量较大时，可以分多批次处理。\n 5.  多用limit：当只需要数据中第一条时，使用limit 1，当数据库找到符合的条件的一条数据就直接返回结果，大大提高了提升了性能。\n 6.  用连接查询代替子查询：mysql 执行子查询时，需要创建临时表，查询完毕后，需要再删除这些临时表，有一些额外的性能消耗。\n 7.  join的表不宜过多：join 表的数量不应该超过3个，必要时表中可以存在冗余字段\n 8.  控制索引数量：优先使用联合索引，并且删除无用的单列索引。\n 9.  选择合理的字段类型：\n     1. 能用数字类型，就不用字符串，因为字符的处理往往比数字要慢。\n     2. 尽可能使用小的类型，比如：用bit存布尔值，用tinyint存枚举值等。\n     3. 长度固定的字符串字段，用char类型。\n     4. 长度可变的字符串字段，用varchar类型。\n     5. 金额字段用decimal，避免精度丢失问题。\n 10. 提高group by 效率：使用group by 分组时，优化在where 子句分组前进行过滤，而不是在having分组后进行过滤。\n 11. 索引优化：使用explian查看执行计划，看sql是否走了索引，如果没有走索引，看是否建立了索引或者索引是否失效并进行相应的处理。\n\n> 参考：\n> \n>  * https://cloud.tencent.com/developer/article/1899907\n>  * https://mp.weixin.qq.com/s?__biz=mzg2ota0njk0oa==&mid=2247488618&idx=1&sn=e70a31865b5eadcb151f439004a4dd72&chksm=cea25ba1f9d5d2b795222ba90e0326618d649e858ec23e9c7360f90fbfc23a7786c33bff9556&token=1647609083&lang=zh_cn#rd\n\n\n# mysql limit深度分页优化\n\n原因：mysql分页到后面越来越慢，其实是进行大量无用回表操作造成（前面数据都不需要，也进行了回表操作）。 解决方案：使用 join+覆盖索引 进行优化。使用覆盖索引查询对应数据主键，再join获取到完整数据，避免大量回表操作。\n\n> 参考：https://mp.weixin.qq.com/s/fnn77oxzbokcl7ax1tdzba\n\n\n# mysql 读写分离\n\n\n# 读写分离延迟如何解决\n\n技术上没想到方法。业务上如果要求强一致性，就都读主库，如果不要求强一致性，就读从库。",charsets:{cjk:!0},lastUpdated:"2023/11/02, 03:14:56",lastUpdatedTimestamp:1698894896e3},{title:"Spring 面试题",frontmatter:{title:"Spring 面试题",date:"2023-10-24T15:45:29.000Z",permalink:"/pages/330962/"},regularPath:"/02.Java%20%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%20%E5%85%AB%E8%82%A1%E6%96%87/08.Spring%20%E9%9D%A2%E8%AF%95%E9%A2%98.html",relativePath:"02.Java 面试宝典/02.Java 八股文/08.Spring 面试题.md",key:"v-23006aec",path:"/pages/330962/",headers:[{level:1,title:"Spring IoC",slug:"spring-ioc",normalizedTitle:"spring ioc",charIndex:2},{level:2,title:"谈谈自己对于Spring Ioc的了解",slug:"谈谈自己对于spring-ioc的了解",normalizedTitle:"谈谈自己对于spring ioc的了解",charIndex:17},{level:1,title:"Spring Aop",slug:"spring-aop",normalizedTitle:"spring aop",charIndex:437},{level:2,title:"谈谈自己对于AOP的了解",slug:"谈谈自己对于aop的了解",normalizedTitle:"谈谈自己对于aop的了解",charIndex:452}],headersStr:"Spring IoC 谈谈自己对于Spring Ioc的了解 Spring Aop 谈谈自己对于AOP的了解",content:"# Spring IoC\n\n\n# 谈谈自己对于Spring Ioc的了解\n\nIoC（Inversion of Control:控制反转） 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。\n为什么叫控制反转？\n\n * 控制 ：指的是对象创建（实例化、管理）的权力\n * 反转 ：控制权交给外部环境（Spring 框架、IoC 容器\n\n将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。 在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。\n\n\n# Spring Aop\n\n\n# 谈谈自己对于AOP的了解\n\nAOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。 Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理，如下图所示：",normalizedContent:"# spring ioc\n\n\n# 谈谈自己对于spring ioc的了解\n\nioc（inversion of control:控制反转） 是一种设计思想，而不是一个具体的技术实现。ioc 的思想就是将原本在程序中手动创建对象的控制权，交由 spring 框架来管理。\n为什么叫控制反转？\n\n * 控制 ：指的是对象创建（实例化、管理）的权力\n * 反转 ：控制权交给外部环境（spring 框架、ioc 容器\n\n将对象之间的相互依赖关系交给 ioc 容器来管理，并由 ioc 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 ioc 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。 在 spring 中， ioc 容器是 spring 用来实现 ioc 的载体， ioc 容器实际上就是个 map（key，value），map 中存放的是各种对象。\n\n\n# spring aop\n\n\n# 谈谈自己对于aop的了解\n\naop(aspect-oriented programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。 spring aop 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 spring aop 会使用 jdk proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 jdk proxy 去进行代理了，这时候 spring aop 会使用 cglib 生成一个被代理对象的子类来作为代理，如下图所示：",charsets:{cjk:!0},lastUpdated:"2023/11/02, 03:14:56",lastUpdatedTimestamp:1698894896e3},{title:"Mybatis&MybatisPlus 面试题",frontmatter:{title:"Mybatis&MybatisPlus 面试题",date:"2023-10-24T15:45:41.000Z",permalink:"/pages/e68641/"},regularPath:"/02.Java%20%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%20%E5%85%AB%E8%82%A1%E6%96%87/09.Mybatis&MybatisPlus%20%E9%9D%A2%E8%AF%95%E9%A2%98.html",relativePath:"02.Java 面试宝典/02.Java 八股文/09.Mybatis&MybatisPlus 面试题.md",key:"v-7550b988",path:"/pages/e68641/",headers:[{level:1,title:"Mybatis",slug:"mybatis",normalizedTitle:"mybatis",charIndex:2},{level:2,title:"#{} 和 ${} 的区别是什么？",slug:"和-的区别是什么",normalizedTitle:"#{} 和 ${} 的区别是什么？",charIndex:14},{level:2,title:"xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？",slug:"xml-映射文件中-除了常见的-select、insert、update、delete-标签之外-还有哪些标签",normalizedTitle:"xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？",charIndex:355},{level:2,title:"Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？",slug:"dao-接口的工作原理是什么-dao-接口里的方法-参数不同时-方法能重载吗",normalizedTitle:"dao 接口的工作原理是什么？dao 接口里的方法，参数不同时，方法能重载吗？",charIndex:557},{level:1,title:"MybatisPlus",slug:"mybatisplus",normalizedTitle:"mybatisplus",charIndex:1071}],headersStr:"Mybatis #{} 和 ${} 的区别是什么？ xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？ Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？ MybatisPlus",content:"# Mybatis\n\n\n# #{} 和 ${} 的区别是什么？\n\n * ${}是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc. Driver。\n * #{}是 sql 的参数占位符，MyBatis 会将 sql 中的#{}替换为? 号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的? 号占位符设置参数值，比如 ps.setInt(0, parameterValue)，#{item.name} 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 param.getItem().getName()。\n\n\n# xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？\n\n还有很多其他的标签， 、 、 、 、 ，加上动态 sql 的 9 个标签， trim|where|set|foreach|if|choose|when|otherwise|bind 等，其中 为 sql 片段标签，通过 标签引入 sql 片段， 为不支持自增的主键生成策略标签。\n\n\n# Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？\n\n通常一个 xml 映射文件，都会写一个 Dao 接口与之对应。Dao 接口就是人们常说的 Mapper 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 MappedStatement 的 id 值，接口方法内的参数，就是传递给 sql 的参数。 Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 MappedStatement ，举例： com.mybatis3.mappers. StudentDao.findStudentById ，可以唯一找到 namespace 为 com.mybatis3.mappers. StudentDao 下面 id = findStudentById 的 MappedStatement 。在 MyBatis 中，每一个 、 、 、 标签，都会被解析为一个 MappedStatement 对象。 Dao 接口里的方法可以重载，但是 Mybatis 的 xml 里面的 ID 不允许重复。\n\n\n# MybatisPlus",normalizedContent:"# mybatis\n\n\n# #{} 和 ${} 的区别是什么？\n\n * ${}是 properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc. driver。\n * #{}是 sql 的参数占位符，mybatis 会将 sql 中的#{}替换为? 号，在 sql 执行前会使用 preparedstatement 的参数设置方法，按序给 sql 的? 号占位符设置参数值，比如 ps.setint(0, parametervalue)，#{item.name} 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 param.getitem().getname()。\n\n\n# xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？\n\n还有很多其他的标签， 、 、 、 、 ，加上动态 sql 的 9 个标签， trim|where|set|foreach|if|choose|when|otherwise|bind 等，其中 为 sql 片段标签，通过 标签引入 sql 片段， 为不支持自增的主键生成策略标签。\n\n\n# dao 接口的工作原理是什么？dao 接口里的方法，参数不同时，方法能重载吗？\n\n通常一个 xml 映射文件，都会写一个 dao 接口与之对应。dao 接口就是人们常说的 mapper 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 mappedstatement 的 id 值，接口方法内的参数，就是传递给 sql 的参数。 mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 mappedstatement ，举例： com.mybatis3.mappers. studentdao.findstudentbyid ，可以唯一找到 namespace 为 com.mybatis3.mappers. studentdao 下面 id = findstudentbyid 的 mappedstatement 。在 mybatis 中，每一个 、 、 、 标签，都会被解析为一个 mappedstatement 对象。 dao 接口里的方法可以重载，但是 mybatis 的 xml 里面的 id 不允许重复。\n\n\n# mybatisplus",charsets:{cjk:!0},lastUpdated:"2023/11/02, 03:14:56",lastUpdatedTimestamp:1698894896e3},{title:"Redis 面试题",frontmatter:{title:"Redis 面试题",date:"2023-10-24T15:45:05.000Z",permalink:"/pages/b1ecc7/"},regularPath:"/02.Java%20%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%20%E5%85%AB%E8%82%A1%E6%96%87/07.Redis%20%E9%9D%A2%E8%AF%95%E9%A2%98.html",relativePath:"02.Java 面试宝典/02.Java 八股文/07.Redis 面试题.md",key:"v-4d5eaa9c",path:"/pages/b1ecc7/",headers:[{level:1,title:"Redis 基础",slug:"redis-基础",normalizedTitle:"redis 基础",charIndex:2},{level:2,title:"简单介绍下 Redis",slug:"简单介绍下-redis",normalizedTitle:"简单介绍下 redis",charIndex:15},{level:2,title:"缓存数据处理流程是怎么样的",slug:"缓存数据处理流程是怎么样的",normalizedTitle:"缓存数据处理流程是怎么样的",charIndex:193},{level:2,title:"为什么要使用 Redis（缓存）",slug:"为什么要使用-redis-缓存",normalizedTitle:"为什么要使用 redis（缓存）",charIndex:323},{level:2,title:"Redis 除了做缓存，还能做什么",slug:"redis-除了做缓存-还能做什么",normalizedTitle:"redis 除了做缓存，还能做什么",charIndex:366},{level:1,title:"Redis 数据结构",slug:"redis-数据结构",normalizedTitle:"redis 数据结构",charIndex:520},{level:2,title:"Redis 常用的数据结构有哪些",slug:"redis-常用的数据结构有哪些",normalizedTitle:"redis 常用的数据结构有哪些",charIndex:535},{level:2,title:"String 的应用场景有哪些",slug:"string-的应用场景有哪些",normalizedTitle:"string 的应用场景有哪些",charIndex:678},{level:2,title:"String 还是 Hash存储对象数据更好呢",slug:"string-还是-hash存储对象数据更好呢",normalizedTitle:"string 还是 hash存储对象数据更好呢",charIndex:813},{level:2,title:"使用 Redis 实现一个排行榜怎么做",slug:"使用-redis-实现一个排行榜怎么做",normalizedTitle:"使用 redis 实现一个排行榜怎么做",charIndex:913},{level:2,title:"使用 Set 实现抽奖系统",slug:"使用-set-实现抽奖系统",normalizedTitle:"使用 set 实现抽奖系统",charIndex:1060},{level:1,title:"Redis 内存管理",slug:"redis-内存管理",normalizedTitle:"redis 内存管理",charIndex:1186},{level:2,title:"Reids 给缓存数据设置过期时间有啥用",slug:"reids-给缓存数据设置过期时间有啥用",normalizedTitle:"reids 给缓存数据设置过期时间有啥用",charIndex:1201},{level:2,title:"Redis 是如何判断数据是否过期呢",slug:"redis-是如何判断数据是否过期呢",normalizedTitle:"redis 是如何判断数据是否过期呢",charIndex:1409},{level:2,title:"Redis 过期数据的删除策略了解吗",slug:"redis-过期数据的删除策略了解吗",normalizedTitle:"redis 过期数据的删除策略了解吗",charIndex:1556},{level:1,title:"Redis 持久化机制",slug:"redis-持久化机制",normalizedTitle:"redis 持久化机制",charIndex:1713},{level:2,title:"怎么保证 Redis 挂掉之后再重启数据可以进行恢复",slug:"怎么保证-redis-挂掉之后再重启数据可以进行恢复",normalizedTitle:"怎么保证 redis 挂掉之后再重启数据可以进行恢复",charIndex:1729},{level:2,title:"什么是 RDB 持久化",slug:"什么是-rdb-持久化",normalizedTitle:"什么是 rdb 持久化",charIndex:1867},{level:2,title:"RDB 创建快照时会阻塞主线程吗",slug:"rdb-创建快照时会阻塞主线程吗",normalizedTitle:"rdb 创建快照时会阻塞主线程吗",charIndex:2013},{level:2,title:"什么是 AOF 持久化",slug:"什么是-aof-持久化",normalizedTitle:"什么是 aof 持久化",charIndex:2137},{level:2,title:"AOF 日志是如何实现的",slug:"aof-日志是如何实现的",normalizedTitle:"aof 日志是如何实现的",charIndex:2682},{level:1,title:"Redis 事务",slug:"redis-事务",normalizedTitle:"redis 事务",charIndex:2839},{level:2,title:"如何使用 Reids 事务",slug:"如何使用-reids-事务",normalizedTitle:"如何使用 reids 事务",charIndex:2852},{level:2,title:"Redis 事务支持原子性吗",slug:"redis-事务支持原子性吗",normalizedTitle:"redis 事务支持原子性吗",charIndex:3090},{level:1,title:"Redis 分布式锁",slug:"redis-分布式锁",normalizedTitle:"redis 分布式锁",charIndex:3208},{level:2,title:"Redis 分布式锁的底层原理",slug:"redis-分布式锁的底层原理",normalizedTitle:"redis 分布式锁的底层原理",charIndex:3223},{level:1,title:"Redis 生产问题",slug:"redis-生产问题",normalizedTitle:"redis 生产问题",charIndex:3559},{level:2,title:"缓存穿透",slug:"缓存穿透",normalizedTitle:"缓存穿透",charIndex:3574},{level:3,title:"什么是缓存穿透",slug:"什么是缓存穿透",normalizedTitle:"什么是缓存穿透",charIndex:3583},{level:3,title:"缓存穿透的处理流程是怎样的",slug:"缓存穿透的处理流程是怎样的",normalizedTitle:"缓存穿透的处理流程是怎样的",charIndex:3648},{level:3,title:"有哪些解决办法",slug:"有哪些解决办法",normalizedTitle:"有哪些解决办法",charIndex:3726},{level:2,title:"缓存雪崩",slug:"缓存雪崩",normalizedTitle:"缓存雪崩",charIndex:3954},{level:2,title:"如何保证缓存和数据库数据的一致性",slug:"如何保证缓存和数据库数据的一致性",normalizedTitle:"如何保证缓存和数据库数据的一致性",charIndex:4166}],headersStr:"Redis 基础 简单介绍下 Redis 缓存数据处理流程是怎么样的 为什么要使用 Redis（缓存） Redis 除了做缓存，还能做什么 Redis 数据结构 Redis 常用的数据结构有哪些 String 的应用场景有哪些 String 还是 Hash存储对象数据更好呢 使用 Redis 实现一个排行榜怎么做 使用 Set 实现抽奖系统 Redis 内存管理 Reids 给缓存数据设置过期时间有啥用 Redis 是如何判断数据是否过期呢 Redis 过期数据的删除策略了解吗 Redis 持久化机制 怎么保证 Redis 挂掉之后再重启数据可以进行恢复 什么是 RDB 持久化 RDB 创建快照时会阻塞主线程吗 什么是 AOF 持久化 AOF 日志是如何实现的 Redis 事务 如何使用 Reids 事务 Redis 事务支持原子性吗 Redis 分布式锁 Redis 分布式锁的底层原理 Redis 生产问题 缓存穿透 什么是缓存穿透 缓存穿透的处理流程是怎样的 有哪些解决办法 缓存雪崩 如何保证缓存和数据库数据的一致性",content:"# Redis 基础\n\n\n# 简单介绍下 Redis\n\nRedis 是 C 语言开发的数据库，与传统数据库不同是 Redis 的数据是存在内存中的，所以读写非常快，因此Redis 被广泛应用在缓存方面。Redis 除了做缓存，也可以用来做分布式锁，甚至是消息队列。\n\nRedis 提供了多种数据类型来支持不同的业务场景。Redis还支持事务、持久化、Lua脚本和多种集群方案。\n\n\n# 缓存数据处理流程是怎么样的\n\n 1. 如果用户请求的数据在缓存中存在就直接返回数据\n 2. 如果缓存不存在就看数据库是否存在数据。\n 3. 数据库如果存在数据的话，就更新缓存的数据，并将数据返回给用户。\n 4. 如果数据库没有数据的话，就返回空数据。\n\n\n# 为什么要使用 Redis（缓存）\n\n使用缓存是为了提高性能进而提升用户体验。\n\n\n# Redis 除了做缓存，还能做什么\n\n * 分布式锁：Redis 做分布式锁是一种常见的方式。通常情况下，我们都是基于 Redisson  来实现分布式锁。\n * 限流：可以通过 Redis+Lua 脚本实现限流。\n * 消息队列：Redis 自带的 list 数据结构可以作为一个简单的队列使用。\n\n\n# Redis 数据结构\n\n\n# Redis 常用的数据结构有哪些\n\n * 5种基础数据结构：String（字符串）、List（列表）、Hash（散列）、Set（集合）、Zset（有序集合）\n * 3种特殊数据结构：HyperLogLogs（基数统计）、Bitmap（位存储）、Geospatial（地理位置）\n\n\n# String 的应用场景有哪些\n\n * 常规数据（比如 session、token、序列化后的对象）的缓存。\n * 计数：比如用户单位时间的请求数、页面单位时间的访问数。\n * 分布式锁（利用 SETNX key value 命令可以实现一个最简易的分布式锁）\n\n\n# String 还是 Hash存储对象数据更好呢\n\n绝大部分建议使用 String 存储对象数据，除非对象中的某个字段经常变动或者需要单独查询对象中的个别字段信息，这时就可以是 Hash存储。\n\n\n# 使用 Redis 实现一个排行榜怎么做\n\nRedis 中有一个叫做sorted set的数据结构经常被用在各种排行榜的场景。\n\n使用相关的 Redis 命令可以进行排行： ZRANGE (从小到大排序) 、 ZREVRANGE （从大到小排序）、 ZREVRANK (指定元素排名)。\n\n\n# 使用 Set 实现抽奖系统\n\n * SPOP key count：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。\n * SRANDMEMBER key count：随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。\n\n\n# Redis 内存管理\n\n\n# Reids 给缓存数据设置过期时间有啥用\n\n主要有两个方面：\n\n * 内存是有限的，如果缓存中的所有数据都一直保存的话，分分钟就内存溢出了。\n * 有些业务场景就是需要数据只在某一时间段内存在，比如短信验证码、用户登录的 token。\n\nRedis 中除了字符串类型有自己设置过期时间命令 setex外，其他方法都需要依靠 expire命令来设置过期时间。另外，persist命令可以移除一个键的过期时间。\n\n\n# Redis 是如何判断数据是否过期呢\n\nRedis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key（键），过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向数据库键的过期时间。\n\n\n# Redis 过期数据的删除策略了解吗\n\n常见的过期数据删除策略有两种：\n\n * 惰性删除：只会在取出 key 的时候才对数据进行过期检查。\n * 定期删除：每隔一段时间抽取一批 key 执行删除过期 key 操作。\n\n定期删除对内存更加友好，惰性删除对CPU比较友好。Redis采用的定期删除+惰性删除。\n\n\n# Redis 持久化机制\n\n\n# 怎么保证 Redis 挂掉之后再重启数据可以进行恢复\n\n通过持久化恢复数据。持久化数据就是将内存中的数据写入到硬盘里面，可以用来恢复数据。\n\nRedis 支持持久化数据，并且支持两种不同的持久化操作。一种持久化方式叫快照（RDB），另一种方式是只追加文件（AOF）。\n\n\n# 什么是 RDB 持久化\n\nRedis 可以通过创建快照来获得存储在内存中的数据在某个时间点的副本。创建快照后，可以对快照进行备份，也可以复制到其他服务器创建相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能）。快照持久化是 Redis 默认采用的持久化方式。\n\n\n# RDB 创建快照时会阻塞主线程吗\n\nRedis 提供了 save 和 bgsave 两个命令来生成 RDB 快照文件，默认选项是bgsave。\n\nsave命令是主线程执行的，会阻塞主线程。\n\nbgsave命令是子线程执行，不会阻塞主线程。\n\n\n# 什么是 AOF 持久化\n\n与快照持久化相比， AOF 持久化实时性更好，是现在主流的持久化方案。默认情况下 Redis 没有开启 AOF 持久化方式，可以通过 appendonly  参数开启。\n\nappendonly yes\n\n\nAOF 持久化每执行一条更改 Redis 数据的命令， Redis 就会将该命令写入到内存缓存 server.aof_buf，然后再根据 appendfsync配置决定何时同步到硬盘中的 AOF 文件。\n\nAOF 文件保存位置和 RDB 文件相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。\n\nRedis 配置文件存在三种不同的 AOF 持久化方式，分别是：\n\nappendfsync always\n#每次有数据修改发生时都会写入AOF文件，这样会严重降低Redis的速度\nappendfsync everysec\n#每秒钟同步一次，显式地将多个写命令同步到硬盘\nappendfsync no\n让操作系统决定何时进行同步\n\n\n可以考虑使用appendfsync everysec进行持久化，这样 Redis 每秒同步一次 AOF 文件，对 Redis 性能几乎没影响，而且即使系统崩溃，最多只会丢失一秒之内的数据。\n\n\n# AOF 日志是如何实现的\n\n关系型数据库（如 MySQL）通过都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化是在执行命令之后记录日志。\n\n在执行命令后记录日志可以避免额外的检查开销，并且不会阻塞当前命令的执行。但是如果刚执行完命令 Reids 就挂掉的话就会导致对应的修改丢失。\n\n\n# Redis 事务\n\n\n# 如何使用 Reids 事务\n\nRedis 可以通过 MULTI， EXEC，DISCARD，WATCH等命令来实现事务。\n\n使用 MULIT命令后可以输入多个命令。Redis 不会立刻执行这些命令，而是放入队列中，当调用 EXEC命令后将执行所有命令。\n\nDISCARD命令可以取消一个事务，会将事务队列中保存的所有命令清空。\n\nWATCH命令监听指定的键，当调用 EXEC命令执行事务时，如果一个被 WATCH命令监视的键被修改，整个事务都不会执行，直接返回失败。\n\n\n# Redis 事务支持原子性吗\n\nRedis 事务不支持原子性。Redis 事务在运行错误的情况下，除了处理执行过程中出现的错误命令外，其他命令都能正常执行。并且 Redis 不支持回滚操作。因此，Redis 事务不满足原子性。\n\n\n# Redis 分布式锁\n\n\n# Redis 分布式锁的底层原理\n\n不管是实现本地锁还是分布式锁，核心都在于“互斥”。 互斥：在 Redis 中， SETNX 命令是可以帮助我们实现互斥。SETNX 即 SET if Not eXists (对应 Java 中的 setIfAbsent 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， SETNX 啥也不做。释放锁的话，直接通过 DEL 命令删除对应的 key 即可。\n原子性：为了防止误删其他的锁，使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。\n\n\n# Redis 生产问题\n\n\n# 缓存穿透\n\n\n# 什么是缓存穿透\n\n缓存穿透就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。\n\n\n# 缓存穿透的处理流程是怎样的\n\n具体处理流程是：\n\n 1. 用户请求在缓存中找不到对应的数据\n 2. 在数据库也查询不到对应的数据，最终返回空数据。\n\n\n# 有哪些解决办法\n\n（1）缓存无效 key\n\n如果缓存和数据库都查不到某个key的数据，就写一个空数据到 Redis 并设置一个短暂的过期时间（过期时间尽量短一点）。这种方案只适用于请求的 key 变化不频繁的情况，并不能从根本上解决这问题。\n\n（2）布隆过滤器\n\n将所有可能存在的请求值都存在布隆过滤器中，当用户请求过来，先判断用户发来的请求是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走正常获取缓存的流程。\n\n\n# 缓存雪崩\n\n缓存雪崩就是缓存在同一时间大面积失效，后面的请求都直接落到数据库上，造成数据库短时间内承受大量请求。\n\n缓存雪崩可以出现原因：\n\n * Redis 服务不可用\n * 热点缓存失效\n\n针对 Redis 服务不可用的情况，可以搭建 Redis 集群，避免单机出现问题整个缓存服务都没法使用。还可以限流，避免同时处理大量的请求。\n\n针对热点缓存失效，可以设置热点缓存不同的失效时间，甚至可以设置缓存永不失效。\n\n\n# 如何保证缓存和数据库数据的一致性\n\n没法完全保证缓存数据与数据库的一致，但可以尽量让它们保持一致。可以使用旁路缓存模式，当遇到写请求时：先更新数据库，再删除缓存。\n\n如果更新数据库成功，删除缓存失败的话，就使用消息队列进行异步重试。",normalizedContent:"# redis 基础\n\n\n# 简单介绍下 redis\n\nredis 是 c 语言开发的数据库，与传统数据库不同是 redis 的数据是存在内存中的，所以读写非常快，因此redis 被广泛应用在缓存方面。redis 除了做缓存，也可以用来做分布式锁，甚至是消息队列。\n\nredis 提供了多种数据类型来支持不同的业务场景。redis还支持事务、持久化、lua脚本和多种集群方案。\n\n\n# 缓存数据处理流程是怎么样的\n\n 1. 如果用户请求的数据在缓存中存在就直接返回数据\n 2. 如果缓存不存在就看数据库是否存在数据。\n 3. 数据库如果存在数据的话，就更新缓存的数据，并将数据返回给用户。\n 4. 如果数据库没有数据的话，就返回空数据。\n\n\n# 为什么要使用 redis（缓存）\n\n使用缓存是为了提高性能进而提升用户体验。\n\n\n# redis 除了做缓存，还能做什么\n\n * 分布式锁：redis 做分布式锁是一种常见的方式。通常情况下，我们都是基于 redisson  来实现分布式锁。\n * 限流：可以通过 redis+lua 脚本实现限流。\n * 消息队列：redis 自带的 list 数据结构可以作为一个简单的队列使用。\n\n\n# redis 数据结构\n\n\n# redis 常用的数据结构有哪些\n\n * 5种基础数据结构：string（字符串）、list（列表）、hash（散列）、set（集合）、zset（有序集合）\n * 3种特殊数据结构：hyperloglogs（基数统计）、bitmap（位存储）、geospatial（地理位置）\n\n\n# string 的应用场景有哪些\n\n * 常规数据（比如 session、token、序列化后的对象）的缓存。\n * 计数：比如用户单位时间的请求数、页面单位时间的访问数。\n * 分布式锁（利用 setnx key value 命令可以实现一个最简易的分布式锁）\n\n\n# string 还是 hash存储对象数据更好呢\n\n绝大部分建议使用 string 存储对象数据，除非对象中的某个字段经常变动或者需要单独查询对象中的个别字段信息，这时就可以是 hash存储。\n\n\n# 使用 redis 实现一个排行榜怎么做\n\nredis 中有一个叫做sorted set的数据结构经常被用在各种排行榜的场景。\n\n使用相关的 redis 命令可以进行排行： zrange (从小到大排序) 、 zrevrange （从大到小排序）、 zrevrank (指定元素排名)。\n\n\n# 使用 set 实现抽奖系统\n\n * spop key count：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。\n * srandmember key count：随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。\n\n\n# redis 内存管理\n\n\n# reids 给缓存数据设置过期时间有啥用\n\n主要有两个方面：\n\n * 内存是有限的，如果缓存中的所有数据都一直保存的话，分分钟就内存溢出了。\n * 有些业务场景就是需要数据只在某一时间段内存在，比如短信验证码、用户登录的 token。\n\nredis 中除了字符串类型有自己设置过期时间命令 setex外，其他方法都需要依靠 expire命令来设置过期时间。另外，persist命令可以移除一个键的过期时间。\n\n\n# redis 是如何判断数据是否过期呢\n\nredis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 redis 数据库中的某个 key（键），过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向数据库键的过期时间。\n\n\n# redis 过期数据的删除策略了解吗\n\n常见的过期数据删除策略有两种：\n\n * 惰性删除：只会在取出 key 的时候才对数据进行过期检查。\n * 定期删除：每隔一段时间抽取一批 key 执行删除过期 key 操作。\n\n定期删除对内存更加友好，惰性删除对cpu比较友好。redis采用的定期删除+惰性删除。\n\n\n# redis 持久化机制\n\n\n# 怎么保证 redis 挂掉之后再重启数据可以进行恢复\n\n通过持久化恢复数据。持久化数据就是将内存中的数据写入到硬盘里面，可以用来恢复数据。\n\nredis 支持持久化数据，并且支持两种不同的持久化操作。一种持久化方式叫快照（rdb），另一种方式是只追加文件（aof）。\n\n\n# 什么是 rdb 持久化\n\nredis 可以通过创建快照来获得存储在内存中的数据在某个时间点的副本。创建快照后，可以对快照进行备份，也可以复制到其他服务器创建相同数据的服务器副本（redis 主从结构，主要用来提高 redis 性能）。快照持久化是 redis 默认采用的持久化方式。\n\n\n# rdb 创建快照时会阻塞主线程吗\n\nredis 提供了 save 和 bgsave 两个命令来生成 rdb 快照文件，默认选项是bgsave。\n\nsave命令是主线程执行的，会阻塞主线程。\n\nbgsave命令是子线程执行，不会阻塞主线程。\n\n\n# 什么是 aof 持久化\n\n与快照持久化相比， aof 持久化实时性更好，是现在主流的持久化方案。默认情况下 redis 没有开启 aof 持久化方式，可以通过 appendonly  参数开启。\n\nappendonly yes\n\n\naof 持久化每执行一条更改 redis 数据的命令， redis 就会将该命令写入到内存缓存 server.aof_buf，然后再根据 appendfsync配置决定何时同步到硬盘中的 aof 文件。\n\naof 文件保存位置和 rdb 文件相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。\n\nredis 配置文件存在三种不同的 aof 持久化方式，分别是：\n\nappendfsync always\n#每次有数据修改发生时都会写入aof文件，这样会严重降低redis的速度\nappendfsync everysec\n#每秒钟同步一次，显式地将多个写命令同步到硬盘\nappendfsync no\n让操作系统决定何时进行同步\n\n\n可以考虑使用appendfsync everysec进行持久化，这样 redis 每秒同步一次 aof 文件，对 redis 性能几乎没影响，而且即使系统崩溃，最多只会丢失一秒之内的数据。\n\n\n# aof 日志是如何实现的\n\n关系型数据库（如 mysql）通过都是执行命令之前记录日志（方便故障恢复），而 redis aof 持久化是在执行命令之后记录日志。\n\n在执行命令后记录日志可以避免额外的检查开销，并且不会阻塞当前命令的执行。但是如果刚执行完命令 reids 就挂掉的话就会导致对应的修改丢失。\n\n\n# redis 事务\n\n\n# 如何使用 reids 事务\n\nredis 可以通过 multi， exec，discard，watch等命令来实现事务。\n\n使用 mulit命令后可以输入多个命令。redis 不会立刻执行这些命令，而是放入队列中，当调用 exec命令后将执行所有命令。\n\ndiscard命令可以取消一个事务，会将事务队列中保存的所有命令清空。\n\nwatch命令监听指定的键，当调用 exec命令执行事务时，如果一个被 watch命令监视的键被修改，整个事务都不会执行，直接返回失败。\n\n\n# redis 事务支持原子性吗\n\nredis 事务不支持原子性。redis 事务在运行错误的情况下，除了处理执行过程中出现的错误命令外，其他命令都能正常执行。并且 redis 不支持回滚操作。因此，redis 事务不满足原子性。\n\n\n# redis 分布式锁\n\n\n# redis 分布式锁的底层原理\n\n不管是实现本地锁还是分布式锁，核心都在于“互斥”。 互斥：在 redis 中， setnx 命令是可以帮助我们实现互斥。setnx 即 set if not exists (对应 java 中的 setifabsent 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， setnx 啥也不做。释放锁的话，直接通过 del 命令删除对应的 key 即可。\n原子性：为了防止误删其他的锁，使用 lua 脚本通过 key 对应的 value（唯一值）来判断。选用 lua 脚本是为了保证解锁操作的原子性。因为 redis 在执行 lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。\n\n\n# redis 生产问题\n\n\n# 缓存穿透\n\n\n# 什么是缓存穿透\n\n缓存穿透就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。\n\n\n# 缓存穿透的处理流程是怎样的\n\n具体处理流程是：\n\n 1. 用户请求在缓存中找不到对应的数据\n 2. 在数据库也查询不到对应的数据，最终返回空数据。\n\n\n# 有哪些解决办法\n\n（1）缓存无效 key\n\n如果缓存和数据库都查不到某个key的数据，就写一个空数据到 redis 并设置一个短暂的过期时间（过期时间尽量短一点）。这种方案只适用于请求的 key 变化不频繁的情况，并不能从根本上解决这问题。\n\n（2）布隆过滤器\n\n将所有可能存在的请求值都存在布隆过滤器中，当用户请求过来，先判断用户发来的请求是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走正常获取缓存的流程。\n\n\n# 缓存雪崩\n\n缓存雪崩就是缓存在同一时间大面积失效，后面的请求都直接落到数据库上，造成数据库短时间内承受大量请求。\n\n缓存雪崩可以出现原因：\n\n * redis 服务不可用\n * 热点缓存失效\n\n针对 redis 服务不可用的情况，可以搭建 redis 集群，避免单机出现问题整个缓存服务都没法使用。还可以限流，避免同时处理大量的请求。\n\n针对热点缓存失效，可以设置热点缓存不同的失效时间，甚至可以设置缓存永不失效。\n\n\n# 如何保证缓存和数据库数据的一致性\n\n没法完全保证缓存数据与数据库的一致，但可以尽量让它们保持一致。可以使用旁路缓存模式，当遇到写请求时：先更新数据库，再删除缓存。\n\n如果更新数据库成功，删除缓存失败的话，就使用消息队列进行异步重试。",charsets:{cjk:!0},lastUpdated:"2023/11/02, 03:14:56",lastUpdatedTimestamp:1698894896e3},{title:"SpringBoot 面试题",frontmatter:{title:"SpringBoot 面试题",date:"2023-10-24T15:45:53.000Z",permalink:"/pages/663a49/"},regularPath:"/02.Java%20%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%20%E5%85%AB%E8%82%A1%E6%96%87/10.SpringBoot%20%E9%9D%A2%E8%AF%95%E9%A2%98.html",relativePath:"02.Java 面试宝典/02.Java 八股文/10.SpringBoot 面试题.md",key:"v-be1bac58",path:"/pages/663a49/",headers:[{level:1,title:"为什么要有 SpringBoot",slug:"为什么要有-springboot",normalizedTitle:"为什么要有 springboot",charIndex:2},{level:1,title:"说出使用SpringBoot的主要优点",slug:"说出使用springboot的主要优点",normalizedTitle:"说出使用springboot的主要优点",charIndex:92},{level:1,title:"什么是SpringBoot Starters",slug:"什么是springboot-starters",normalizedTitle:"什么是springboot starters",charIndex:641},{level:1,title:"Spring Boot 支持哪些内嵌Servlet容器",slug:"spring-boot-支持哪些内嵌servlet容器",normalizedTitle:"spring boot 支持哪些内嵌servlet容器",charIndex:1082},{level:1,title:"介绍一下@SpringBootApplication 注解",slug:"介绍一下-springbootapplication-注解",normalizedTitle:"介绍一下@springbootapplication 注解",charIndex:1243},{level:1,title:"SpringBoot的自动配置是如何实现的",slug:"springboot的自动配置是如何实现的",normalizedTitle:"springboot的自动配置是如何实现的",charIndex:1577},{level:1,title:"开发RESTful Web服务常用的注解有哪些",slug:"开发restful-web服务常用的注解有哪些",normalizedTitle:"开发restful web服务常用的注解有哪些",charIndex:2415},{level:1,title:"Spring Boot 常用的两种配置文件",slug:"spring-boot-常用的两种配置文件",normalizedTitle:"spring boot 常用的两种配置文件",charIndex:3305},{level:1,title:"什么是YAML？YAML配置的优势在哪里",slug:"什么是yaml-yaml配置的优势在哪里",normalizedTitle:"什么是yaml？yaml配置的优势在哪里",charIndex:3427},{level:1,title:"Spring Boot常用的读取配置的方法有哪些",slug:"spring-boot常用的读取配置的方法有哪些",normalizedTitle:"spring boot常用的读取配置的方法有哪些",charIndex:3663},{level:1,title:"Spring Boot 加载配置文件的优先级了解吗",slug:"spring-boot-加载配置文件的优先级了解吗",normalizedTitle:"spring boot 加载配置文件的优先级了解吗",charIndex:3840},{level:1,title:"常见的Bean映射工具有哪些",slug:"常见的bean映射工具有哪些",normalizedTitle:"常见的bean映射工具有哪些",charIndex:4030},{level:1,title:"Spring Boot 如何监控系统实际运行状况",slug:"spring-boot-如何监控系统实际运行状况",normalizedTitle:"spring boot 如何监控系统实际运行状况",charIndex:4326},{level:1,title:"SpringBoot如何做请求参数校验",slug:"springboot如何做请求参数校验",normalizedTitle:"springboot如何做请求参数校验",charIndex:4658},{level:2,title:"校验注解",slug:"校验注解",normalizedTitle:"校验注解",charIndex:4849},{level:2,title:"验证请求体(RequestBody)",slug:"验证请求体-requestbody",normalizedTitle:"验证请求体(requestbody)",charIndex:5591},{level:2,title:"验证请求参数(Path Variables 和 Request Parameters)",slug:"验证请求参数-path-variables-和-request-parameters",normalizedTitle:"验证请求参数(path variables 和 request parameters)",charIndex:5727},{level:1,title:"如何使用Spring Boot实现全局异常处理",slug:"如何使用spring-boot实现全局异常处理",normalizedTitle:"如何使用spring boot实现全局异常处理",charIndex:5829},{level:1,title:"Spring Boot 中如何实现定时任务",slug:"spring-boot-中如何实现定时任务",normalizedTitle:"spring boot 中如何实现定时任务",charIndex:5949}],headersStr:"为什么要有 SpringBoot 说出使用SpringBoot的主要优点 什么是SpringBoot Starters Spring Boot 支持哪些内嵌Servlet容器 介绍一下@SpringBootApplication 注解 SpringBoot的自动配置是如何实现的 开发RESTful Web服务常用的注解有哪些 Spring Boot 常用的两种配置文件 什么是YAML？YAML配置的优势在哪里 Spring Boot常用的读取配置的方法有哪些 Spring Boot 加载配置文件的优先级了解吗 常见的Bean映射工具有哪些 Spring Boot 如何监控系统实际运行状况 SpringBoot如何做请求参数校验 校验注解 验证请求体(RequestBody) 验证请求参数(Path Variables 和 Request Parameters) 如何使用Spring Boot实现全局异常处理 Spring Boot 中如何实现定时任务",content:"# 为什么要有 SpringBoot\n\nSpring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。\n\n\n# 说出使用SpringBoot的主要优点\n\n 1. 开发基于 Spring 的应用程序很容易。\n 2. Spring Boot 项目所需的开发或工程时间明显减少，通常会提高整体生产力。\n 3. Spring Boot 不需要编写大量样板代码、XML 配置和注\n 4. Spring 引导应用程序可以很容易地与 Spring 生态系统集成，如 Spring JDBC、Spring ORM、Spring Data、Spring Security 等。\n 5. Spring Boot 遵循“固执己见的默认配置”，以减少开发工作（默认配置可以修改）。\n 6. Spring Boot 应用程序提供嵌入式 HTTP 服务器，如 Tomcat 和 Jetty，可以轻松地开发和测试 web 应用程序。（这点很赞！普通运行 Java 程序的方式就能运行基于 Spring Boot web 项目，省事很多）\n 7. Spring Boot 提供命令行接口(CLI)工具，用于开发和测试 Spring Boot 应用程序，如 Java 或 Groovy。\n 8. Spring Boot 提供了多种插件，可以使用内置工具(如 Maven 和 Gradle)开发和测试 Spring Boot 应用程序。\n\n\n# 什么是SpringBoot Starters\n\nSpring Boot Starters 是一系列依赖关系的集合，因为它的存在，项目的依赖之间的关系对我们来说变的更加简单了。\n\n举个例子：在没有 Spring Boot Starters 之前，我们开发 REST 服务或 Web 应用程序时; 我们需要使用像 Spring MVC，Tomcat 和 Jackson 这样的库，这些依赖我们需要手动一个一个添加。但是，有了 Spring Boot Starters 我们只需要一个只需添加一个spring-boot-starter-web一个依赖就可以了，这个依赖包含的子依赖中包含了我们开发 REST 服务需要的所有依赖。\n\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n  <artifactId>spirng-boot-starter-web</artifactId>\n</dependency>\n\n\n\n# Spring Boot 支持哪些内嵌Servlet容器\n\nSpring Boot 支持以下嵌入式 Servlet 容器:\n\n| Name\n\n| Servlet Version\n\n\nTomcat 9.0\n\n| 4.0\n\n| | Jetty 9.4\n\n| 3.1\n\n| | Undertow 2.0\n\n| 4.0 |\n\n\n# 介绍一下@SpringBootApplication 注解\n\n@SpringBootApplication可以看作是 @Configuration。@EnableAutoConfiguration、@ComponentScan 注解的集合。根据 SpringBoot 官网，这三个注解的作用分别是：\n\n * @EnableAutoConfiguration：启用 SpringBoot 的自动配置机制\n * @ComponentScan： 扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描该类所在的包下所有的类。\n * @Configuration：允许在上下文中注册额外的 bean 或导入其他配置类\n\n\n# SpringBoot的自动配置是如何实现的\n\n这个是因为@SpringBootApplication注解的原因，在上一个问题中已经提到了这个注解。我们知道 @SpringBootApplication看作是 @Configuration、@EnableAutoConfiguration、@ComponentScan 注解的集合。 @EnableAutoConfiguration是启动自动配置的关键 @EnableAutoConfiguration 注解通过 Spring 提供的 @Import 注解导入了AutoConfigurationImportSelector类（@Import 注解可以导入配置类或者 Bean 到当前类中）。 AutoConfigurationImportSelector类中getCandidateConfigurations方法会将所有自动配置类的信息以 List 的形式返回。这些配置信息会被 Spring 容器作 bean 来管理。 自动配置信息有了，那么自动配置还差什么呢？ @Conditional 注解。@ConditionalOnClass(指定的类必须存在于类路径下),@ConditionalOnBean(容器中是否有指定的 Bean)等等都是对@Conditional注解的扩展。\n\n拿 Spring Security 的自动配置举个例子:SecurityAutoConfiguration中导入了WebSecurityEnablerConfiguration类，WebSecurityEnablerConfiguration类中使用@ConditionalOnBean指定了容器中必须还有WebSecurityConfigurerAdapter 类或其实现类。所以，一般情况下 Spring Security 配置类都会去实现 WebSecurityConfigurerAdapter，这样自动将配置就完成了。\n\n\n# 开发RESTful Web服务常用的注解有哪些\n\nSpring Bean 相关：\n\n * @Autowired : 自动导入对象到类中，被注入进的类同样要被 Spring 容器管理。\n * @RestController : @RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器 bean,并且是将函数的返回值直 接填入 HTTP 响应体中,是 REST 风格的控制器。\n * @Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。\n * @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。\n * @Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。\n * @Controller : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。\n\n处理常见的 HTTP 请求类型：\n\n * @GetMapping : GET 请求、\n * @PostMapping : POST 请求。\n * @PutMapping : PUT 请求。\n * @DeleteMapping : DELETE 请求。\n\n前后端传值：\n\n * @RequestParam以及@Pathvairable ：@PathVariable用于获取路径参数，@RequestParam用于获取查询参数。\n * @RequestBody ：用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且 Content-Type 为 application/json 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用HttpMessageConverter或者自定义的HttpMessageConverter将请求的 body 中的 json 字符串转换为 java 对象。\n\n\n# Spring Boot 常用的两种配置文件\n\n我们可以通过 application.properties或者 application.yml 对 Spring Boot 程序进行简单的配置。如果，你不进行配置的话，就是使用的默认配置。\n\n\n# 什么是YAML？YAML配置的优势在哪里\n\nYAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。\n\n相比于 Properties 配置的方式，YAML 配置的方式更加直观清晰，简介明了，有层次感。 但是，YAML 配置的方式有一个缺点，那就是不支持 @PropertySource 注解导入自定义的 YAML 配置。\n\n\n# Spring Boot常用的读取配置的方法有哪些\n\n 1. 通过@Value读取比较简单的配置信息（不推荐使用）\n 2. 通过@ConfigurationProperties读取并与bean绑定\n 3. 通过@ConfigurationProperties读取并校验\n 4. @PropertySource读取指定的 properties 文件\n\n\n# Spring Boot 加载配置文件的优先级了解吗\n\nSpring 读取配置文件也是有优先级的，直接上图：\n\n更对内容请查看官方文档：https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config\n\n\n# 常见的Bean映射工具有哪些\n\n我们经常在代码中会对一个数据结构封装成DO、SDO、DTO、VO等，而这些Bean中的大部分属性都是一样的，所以使用属性拷贝类工具可以帮助我们节省大量的 set 和 get 操作。\n\n常用的 Bean 映射工具有：Spring BeanUtils、Apache BeanUtils、MapStruct、ModelMapper、Dozer、Orika、JMapper 。\n\n由于 Apache BeanUtils 、Dozer 、ModelMapper 性能太差，所以不建议使用。MapStruct 性能更好而且使用起来比较灵活，是一个比较不错的选择。\n\n\n# Spring Boot 如何监控系统实际运行状况\n\n我们可以使用 Spring Boot Actuator 来对 Spring Boot 项目进行简单的监控。\n\n<dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n\n\n集成了这个模块之后，你的 Spring Boot 应用程序就自带了一些开箱即用的获取程序运行时的内部状态信息的 API。\n\n比如通过 GET 方法访问 /health 接口，你就可以获取应用程序的健康指标。\n\n\n# SpringBoot如何做请求参数校验\n\n数据的校验的重要性就不用说了，即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据。\n\nSpring Boot 程序做请求参数校验的话只需要spring-boot-starter-web 依赖就够了，它的子依赖包含了我们所需要的东西。\n\n\n# 校验注解\n\nJSR 提供的校验注解:\n\n * @Null 被注释的元素必须为 null\n * @NotNull 被注释的元素必须不为 null\n * @AssertTrue 被注释的元素必须为 true\n * @AssertFalse 被注释的元素必须为 false\n * @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值\n * @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值\n * @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值\n * @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值\n * @Size(max=, min=) 被注释的元素的大小必须在指定的范围内\n * @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内\n * @Past 被注释的元素必须是一个过去的日期\n * @Future 被注释的元素必须是一个将来的日期\n * @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式\n\nHibernate Validator 提供的校验注解：\n\n * @NotBlank(message =) 验证字符串非 null，且长度必须大于 0\n * @Email 被注释的元素必须是电子邮箱地址\n * @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内\n * @NotEmpty 被注释的字符串的必须非空\n * @Range(min=,max=,message=) 被注释的元素必须在合适的范围内\n\n\n# 验证请求体(RequestBody)\n\n我们在需要验证的参数上加上了@Valid 注解，如果验证失败，它将抛出MethodArgumentNotValidException。默认情况下，Spring 会将此异常转换为 HTTP Status 400（错误请求）。\n\n\n# 验证请求参数(Path Variables 和 Request Parameters)\n\n一定一定不要忘记在类上加上 Validated 注解了，这个参数可以告诉 Spring 去校验方法参数。\n\n\n# 如何使用Spring Boot实现全局异常处理\n\n可以使用 @ControllerAdvice 和 @ExceptionHandler 处理全局异常。\n\n更多内容请参考我的原创 ：Spring Boot 异常处理在实际项目中的应用\n\n\n# Spring Boot 中如何实现定时任务\n\n我们使用 @Scheduled 注解就能很方便地创建一个定时任务。\n\n单纯依靠 @Scheduled 注解 还不行，我们还需要在 SpringBoot 中我们只需要在启动类上加上@EnableScheduling 注解，这样才可以启动定时任务。@EnableScheduling 注解的作用是发现注解 @Scheduled 的任务并在后台执行该任务。",normalizedContent:"# 为什么要有 springboot\n\nspring 旨在简化 j2ee 企业应用程序开发。spring boot 旨在简化 spring 开发（减少配置文件，开箱即用！）。\n\n\n# 说出使用springboot的主要优点\n\n 1. 开发基于 spring 的应用程序很容易。\n 2. spring boot 项目所需的开发或工程时间明显减少，通常会提高整体生产力。\n 3. spring boot 不需要编写大量样板代码、xml 配置和注\n 4. spring 引导应用程序可以很容易地与 spring 生态系统集成，如 spring jdbc、spring orm、spring data、spring security 等。\n 5. spring boot 遵循“固执己见的默认配置”，以减少开发工作（默认配置可以修改）。\n 6. spring boot 应用程序提供嵌入式 http 服务器，如 tomcat 和 jetty，可以轻松地开发和测试 web 应用程序。（这点很赞！普通运行 java 程序的方式就能运行基于 spring boot web 项目，省事很多）\n 7. spring boot 提供命令行接口(cli)工具，用于开发和测试 spring boot 应用程序，如 java 或 groovy。\n 8. spring boot 提供了多种插件，可以使用内置工具(如 maven 和 gradle)开发和测试 spring boot 应用程序。\n\n\n# 什么是springboot starters\n\nspring boot starters 是一系列依赖关系的集合，因为它的存在，项目的依赖之间的关系对我们来说变的更加简单了。\n\n举个例子：在没有 spring boot starters 之前，我们开发 rest 服务或 web 应用程序时; 我们需要使用像 spring mvc，tomcat 和 jackson 这样的库，这些依赖我们需要手动一个一个添加。但是，有了 spring boot starters 我们只需要一个只需添加一个spring-boot-starter-web一个依赖就可以了，这个依赖包含的子依赖中包含了我们开发 rest 服务需要的所有依赖。\n\n<dependency>\n\t<groupid>org.springframework.boot</groupid>\n  <artifactid>spirng-boot-starter-web</artifactid>\n</dependency>\n\n\n\n# spring boot 支持哪些内嵌servlet容器\n\nspring boot 支持以下嵌入式 servlet 容器:\n\n| name\n\n| servlet version\n\n\ntomcat 9.0\n\n| 4.0\n\n| | jetty 9.4\n\n| 3.1\n\n| | undertow 2.0\n\n| 4.0 |\n\n\n# 介绍一下@springbootapplication 注解\n\n@springbootapplication可以看作是 @configuration。@enableautoconfiguration、@componentscan 注解的集合。根据 springboot 官网，这三个注解的作用分别是：\n\n * @enableautoconfiguration：启用 springboot 的自动配置机制\n * @componentscan： 扫描被@component (@service,@controller)注解的 bean，注解默认会扫描该类所在的包下所有的类。\n * @configuration：允许在上下文中注册额外的 bean 或导入其他配置类\n\n\n# springboot的自动配置是如何实现的\n\n这个是因为@springbootapplication注解的原因，在上一个问题中已经提到了这个注解。我们知道 @springbootapplication看作是 @configuration、@enableautoconfiguration、@componentscan 注解的集合。 @enableautoconfiguration是启动自动配置的关键 @enableautoconfiguration 注解通过 spring 提供的 @import 注解导入了autoconfigurationimportselector类（@import 注解可以导入配置类或者 bean 到当前类中）。 autoconfigurationimportselector类中getcandidateconfigurations方法会将所有自动配置类的信息以 list 的形式返回。这些配置信息会被 spring 容器作 bean 来管理。 自动配置信息有了，那么自动配置还差什么呢？ @conditional 注解。@conditionalonclass(指定的类必须存在于类路径下),@conditionalonbean(容器中是否有指定的 bean)等等都是对@conditional注解的扩展。\n\n拿 spring security 的自动配置举个例子:securityautoconfiguration中导入了websecurityenablerconfiguration类，websecurityenablerconfiguration类中使用@conditionalonbean指定了容器中必须还有websecurityconfigureradapter 类或其实现类。所以，一般情况下 spring security 配置类都会去实现 websecurityconfigureradapter，这样自动将配置就完成了。\n\n\n# 开发restful web服务常用的注解有哪些\n\nspring bean 相关：\n\n * @autowired : 自动导入对象到类中，被注入进的类同样要被 spring 容器管理。\n * @restcontroller : @restcontroller注解是@controller和@responsebody的合集,表示这是个控制器 bean,并且是将函数的返回值直 接填入 http 响应体中,是 rest 风格的控制器。\n * @component ：通用的注解，可标注任意类为 spring 组件。如果一个 bean 不知道属于哪个层，可以使用@component 注解标注。\n * @repository : 对应持久层即 dao 层，主要用于数据库相关操作。\n * @service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 dao 层。\n * @controller : 对应 spring mvc 控制层，主要用于接受用户请求并调用 service 层返回数据给前端页面。\n\n处理常见的 http 请求类型：\n\n * @getmapping : get 请求、\n * @postmapping : post 请求。\n * @putmapping : put 请求。\n * @deletemapping : delete 请求。\n\n前后端传值：\n\n * @requestparam以及@pathvairable ：@pathvariable用于获取路径参数，@requestparam用于获取查询参数。\n * @requestbody ：用于读取 request 请求（可能是 post,put,delete,get 请求）的 body 部分并且 content-type 为 application/json 格式的数据，接收到数据之后会自动将数据绑定到 java 对象上去。系统会使用httpmessageconverter或者自定义的httpmessageconverter将请求的 body 中的 json 字符串转换为 java 对象。\n\n\n# spring boot 常用的两种配置文件\n\n我们可以通过 application.properties或者 application.yml 对 spring boot 程序进行简单的配置。如果，你不进行配置的话，就是使用的默认配置。\n\n\n# 什么是yaml？yaml配置的优势在哪里\n\nyaml 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，yaml 文件就更加结构化，而且更少混淆。可以看出 yaml 具有分层配置数据。\n\n相比于 properties 配置的方式，yaml 配置的方式更加直观清晰，简介明了，有层次感。 但是，yaml 配置的方式有一个缺点，那就是不支持 @propertysource 注解导入自定义的 yaml 配置。\n\n\n# spring boot常用的读取配置的方法有哪些\n\n 1. 通过@value读取比较简单的配置信息（不推荐使用）\n 2. 通过@configurationproperties读取并与bean绑定\n 3. 通过@configurationproperties读取并校验\n 4. @propertysource读取指定的 properties 文件\n\n\n# spring boot 加载配置文件的优先级了解吗\n\nspring 读取配置文件也是有优先级的，直接上图：\n\n更对内容请查看官方文档：https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config\n\n\n# 常见的bean映射工具有哪些\n\n我们经常在代码中会对一个数据结构封装成do、sdo、dto、vo等，而这些bean中的大部分属性都是一样的，所以使用属性拷贝类工具可以帮助我们节省大量的 set 和 get 操作。\n\n常用的 bean 映射工具有：spring beanutils、apache beanutils、mapstruct、modelmapper、dozer、orika、jmapper 。\n\n由于 apache beanutils 、dozer 、modelmapper 性能太差，所以不建议使用。mapstruct 性能更好而且使用起来比较灵活，是一个比较不错的选择。\n\n\n# spring boot 如何监控系统实际运行状况\n\n我们可以使用 spring boot actuator 来对 spring boot 项目进行简单的监控。\n\n<dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-actuator</artifactid>\n</dependency>\n\n\n集成了这个模块之后，你的 spring boot 应用程序就自带了一些开箱即用的获取程序运行时的内部状态信息的 api。\n\n比如通过 get 方法访问 /health 接口，你就可以获取应用程序的健康指标。\n\n\n# springboot如何做请求参数校验\n\n数据的校验的重要性就不用说了，即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 http 工具直接向后端请求一些违法数据。\n\nspring boot 程序做请求参数校验的话只需要spring-boot-starter-web 依赖就够了，它的子依赖包含了我们所需要的东西。\n\n\n# 校验注解\n\njsr 提供的校验注解:\n\n * @null 被注释的元素必须为 null\n * @notnull 被注释的元素必须不为 null\n * @asserttrue 被注释的元素必须为 true\n * @assertfalse 被注释的元素必须为 false\n * @min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值\n * @max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值\n * @decimalmin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值\n * @decimalmax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值\n * @size(max=, min=) 被注释的元素的大小必须在指定的范围内\n * @digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内\n * @past 被注释的元素必须是一个过去的日期\n * @future 被注释的元素必须是一个将来的日期\n * @pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式\n\nhibernate validator 提供的校验注解：\n\n * @notblank(message =) 验证字符串非 null，且长度必须大于 0\n * @email 被注释的元素必须是电子邮箱地址\n * @length(min=,max=) 被注释的字符串的大小必须在指定的范围内\n * @notempty 被注释的字符串的必须非空\n * @range(min=,max=,message=) 被注释的元素必须在合适的范围内\n\n\n# 验证请求体(requestbody)\n\n我们在需要验证的参数上加上了@valid 注解，如果验证失败，它将抛出methodargumentnotvalidexception。默认情况下，spring 会将此异常转换为 http status 400（错误请求）。\n\n\n# 验证请求参数(path variables 和 request parameters)\n\n一定一定不要忘记在类上加上 validated 注解了，这个参数可以告诉 spring 去校验方法参数。\n\n\n# 如何使用spring boot实现全局异常处理\n\n可以使用 @controlleradvice 和 @exceptionhandler 处理全局异常。\n\n更多内容请参考我的原创 ：spring boot 异常处理在实际项目中的应用\n\n\n# spring boot 中如何实现定时任务\n\n我们使用 @scheduled 注解就能很方便地创建一个定时任务。\n\n单纯依靠 @scheduled 注解 还不行，我们还需要在 springboot 中我们只需要在启动类上加上@enablescheduling 注解，这样才可以启动定时任务。@enablescheduling 注解的作用是发现注解 @scheduled 的任务并在后台执行该任务。",charsets:{cjk:!0},lastUpdated:"2023/11/02, 03:14:56",lastUpdatedTimestamp:1698894896e3},{title:"SpringCloud 面试题",frontmatter:{title:"SpringCloud 面试题",date:"2023-10-24T15:46:16.000Z",permalink:"/pages/3c9abe/"},regularPath:"/02.Java%20%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%20%E5%85%AB%E8%82%A1%E6%96%87/11.SpringCloud%20%E9%9D%A2%E8%AF%95%E9%A2%98.html",relativePath:"02.Java 面试宝典/02.Java 八股文/11.SpringCloud 面试题.md",key:"v-7fbbb95c",path:"/pages/3c9abe/",headers:[{level:1,title:"SpringCloud 基础",slug:"springcloud-基础",normalizedTitle:"springcloud 基础",charIndex:2},{level:2,title:"什么是 SpringCloud？",slug:"什么是-springcloud",normalizedTitle:"什么是 springcloud？",charIndex:21},{level:2,title:"SpringCloud 的核心组件有哪些？",slug:"springcloud-的核心组件有哪些",normalizedTitle:"springcloud 的核心组件有哪些？",charIndex:301},{level:1,title:"Spring Cloud Eureka",slug:"spring-cloud-eureka",normalizedTitle:"spring cloud eureka",charIndex:327},{level:2,title:"什么是Eureka",slug:"什么是eureka",normalizedTitle:"什么是eureka",charIndex:853},{level:2,title:"SpringCloud 如何实现服务的注册",slug:"springcloud-如何实现服务的注册",normalizedTitle:"springcloud 如何实现服务的注册",charIndex:995},{level:2,title:"eureka自我保护机制是什么?",slug:"eureka自我保护机制是什么",normalizedTitle:"eureka自我保护机制是什么?",charIndex:1143},{level:2,title:"Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别",slug:"eureka和zookeeper都可以提供服务注册与发现的功能-请说说两个的区别",normalizedTitle:"eureka和zookeeper都可以提供服务注册与发现的功能,请说说两个的区别",charIndex:1312},{level:1,title:"Spring Cloud Ribbon",slug:"spring-cloud-ribbon",normalizedTitle:"spring cloud ribbon",charIndex:470},{level:2,title:"什么是Ribbon？",slug:"什么是ribbon",normalizedTitle:"什么是ribbon？",charIndex:1693},{level:2,title:"Ribbon底层实现原理",slug:"ribbon底层实现原理",normalizedTitle:"ribbon底层实现原理",charIndex:1886},{level:2,title:"@LoadBalanced注解的作用？",slug:"loadbalanced注解的作用",normalizedTitle:"@loadbalanced注解的作用？",charIndex:1985},{level:1,title:"Spring Cloud Fegin&&OpenFeign",slug:"spring-cloud-fegin-openfeign",normalizedTitle:"spring cloud fegin&amp;&amp;openfeign",charIndex:null},{level:2,title:"什么是Feign",slug:"什么是feign",normalizedTitle:"什么是feign",charIndex:2055},{level:2,title:"什么是OpenFeign",slug:"什么是openfeign",normalizedTitle:"什么是openfeign",charIndex:2227},{level:1,title:"Spring Cloud Hystrix",slug:"spring-cloud-hystrix",normalizedTitle:"spring cloud hystrix",charIndex:515},{level:2,title:"什么是断路器",slug:"什么是断路器",normalizedTitle:"什么是断路器",charIndex:2428},{level:2,title:"什么是Hystrix?",slug:"什么是hystrix",normalizedTitle:"什么是hystrix?",charIndex:2665},{level:2,title:"服务熔断与服务降级",slug:"服务熔断与服务降级",normalizedTitle:"服务熔断与服务降级",charIndex:2930},{level:2,title:"SpringCloud 断路器的作用是什么？",slug:"springcloud-断路器的作用是什么",normalizedTitle:"springcloud 断路器的作用是什么？",charIndex:3161},{level:1,title:"Spring Cloud Zuul",slug:"spring-cloud-zuul",normalizedTitle:"spring cloud zuul",charIndex:371},{level:2,title:"什么是网关",slug:"什么是网关",normalizedTitle:"什么是网关",charIndex:3344},{level:2,title:"网关的作用是什么",slug:"网关的作用是什么",normalizedTitle:"网关的作用是什么",charIndex:3394},{level:2,title:"什么是SpringCloud Zuul",slug:"什么是springcloud-zuul",normalizedTitle:"什么是springcloud zuul",charIndex:3479},{level:1,title:"SpringCloud Gateway",slug:"springcloud-gateway",normalizedTitle:"springcloud gateway",charIndex:3833},{level:2,title:"Spring Cloud Gateway几个必知的术语？",slug:"spring-cloud-gateway几个必知的术语",normalizedTitle:"spring cloud gateway几个必知的术语？",charIndex:3857},{level:2,title:"什么是Predict（断言）？",slug:"什么是predict-断言",normalizedTitle:"什么是predict（断言）？",charIndex:4073},{level:2,title:"什么是过滤器？",slug:"什么是过滤器",normalizedTitle:"什么是过滤器？",charIndex:5728},{level:3,title:"GatewayFilter（局部过滤器）",slug:"gatewayfilter-局部过滤器",normalizedTitle:"gatewayfilter（局部过滤器）",charIndex:6067},{level:4,title:"自定义局部过滤器",slug:"自定义局部过滤器",normalizedTitle:"自定义局部过滤器",charIndex:6763},{level:3,title:"GlobalFilter（全局过滤器）",slug:"globalfilter-全局过滤器",normalizedTitle:"globalfilter（全局过滤器）",charIndex:9850},{level:4,title:"自定义全局过滤器",slug:"自定义全局过滤器",normalizedTitle:"自定义全局过滤器",charIndex:10248},{level:2,title:"为什么要集成注册中心",slug:"为什么要集成注册中心",normalizedTitle:"为什么要集成注册中心",charIndex:11370},{level:2,title:"如何实现动态路由",slug:"如何实现动态路由",normalizedTitle:"如何实现动态路由",charIndex:11454},{level:2,title:"如何实现自定义全局异常处理",slug:"如何实现自定义全局异常处理",normalizedTitle:"如何实现自定义全局异常处理",charIndex:11540},{level:1,title:"Spring Cloud Config",slug:"spring-cloud-config",normalizedTitle:"spring cloud config",charIndex:412},{level:2,title:"什么是SpringCLoud Config",slug:"什么是springcloud-config",normalizedTitle:"什么是springcloud config",charIndex:11641},{level:2,title:"SpringCloud Config可以实现实时刷新吗",slug:"springcloud-config可以实现实时刷新吗",normalizedTitle:"springcloud config可以实现实时刷新吗",charIndex:11868},{level:1,title:"Spring Cloud Bus",slug:"spring-cloud-bus",normalizedTitle:"spring cloud bus",charIndex:712},{level:2,title:"什么是 Spring Cloud Bus",slug:"什么是-spring-cloud-bus",normalizedTitle:"什么是 spring cloud bus",charIndex:11967},{level:1,title:"Spring Cloud Sleuth",slug:"spring-cloud-sleuth",normalizedTitle:"spring cloud sleuth",charIndex:763},{level:2,title:"分布式链路追踪使用什么实现",slug:"分布式链路追踪使用什么实现",normalizedTitle:"分布式链路追踪使用什么实现",charIndex:12230}],headersStr:"SpringCloud 基础 什么是 SpringCloud？ SpringCloud 的核心组件有哪些？ Spring Cloud Eureka 什么是Eureka SpringCloud 如何实现服务的注册 eureka自我保护机制是什么? Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别 Spring Cloud Ribbon 什么是Ribbon？ Ribbon底层实现原理 @LoadBalanced注解的作用？ Spring Cloud Fegin&&OpenFeign 什么是Feign 什么是OpenFeign Spring Cloud Hystrix 什么是断路器 什么是Hystrix? 服务熔断与服务降级 SpringCloud 断路器的作用是什么？ Spring Cloud Zuul 什么是网关 网关的作用是什么 什么是SpringCloud Zuul SpringCloud Gateway Spring Cloud Gateway几个必知的术语？ 什么是Predict（断言）？ 什么是过滤器？ GatewayFilter（局部过滤器） 自定义局部过滤器 GlobalFilter（全局过滤器） 自定义全局过滤器 为什么要集成注册中心 如何实现动态路由 如何实现自定义全局异常处理 Spring Cloud Config 什么是SpringCLoud Config SpringCloud Config可以实现实时刷新吗 Spring Cloud Bus 什么是 Spring Cloud Bus Spring Cloud Sleuth 分布式链路追踪使用什么实现",content:'# SpringCloud 基础\n\n\n# 什么是 SpringCloud？\n\nSpring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。 Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。\n\n\n# SpringCloud 的核心组件有哪些？\n\n * Spring Cloud Eureka（服务注册中心）：特性有失效剔除、服务保护\n * Spring Cloud Zuul（API服务网关）：功能有路由分发和过滤\n * Spring Cloud Config（分布式配置中心）：支持本地仓库、SVN、Git、Jar包内配置等模式\n * Spring Cloud Ribbon（客户端负载均衡）：特性有区域亲和,重试机制\n * Spring Cloud Hystrix（服务断路器）：客户端容错保护,特性有服务降级、服务熔断、请求缓存、请求合并、依赖隔离\n * Spring Cloud Feign（服务接口调用）：声明式服务调用本质上就是Ribbon+Hystrix\n * Spring Cloud Stream（消息驱动）：有Sink、Source、Processor三种通道,特性有订阅发布、消费组、消息分区\n * Spring Cloud Bus（消息总线）：配合Config仓库修改的一种Stream实现，\n * Spring Cloud Sleuth（分布式服务追踪）：需要搞清楚TraceID和SpanID以及抽样,如何与ELK整合\n\n\n# Spring Cloud Eureka\n\n\n# 什么是Eureka\n\nEureka作为SpringCloud的服务注册功能服务器，他是服务注册中心，系统中的其他服务使用Eureka的客户端将其连接到Eureka Service中，并且保持心跳，这样工作人员可以通过Eureka Service来监控各个微服务是否运行正常。\n\n\n# SpringCloud 如何实现服务的注册\n\n 1. 服务发布时，指定对应的服务名,将服务注册到 注册中心 eureka\n 2. 注册中心加@EnableEurekaServer,服务用@EnableDiscoveryClient，然后用ribbon或feign进行服务直接的调用发现。\n\n\n# eureka自我保护机制是什么?\n\n默认情况下，如果Eureka Service在一定时间内没有接收到某个微服务的心跳，Eureka Service会进入自我保护模式，在该模式下Eureka Service会保护服务注册表中的信息，不再删除注册表中的数据，当网络故障恢复后，Eureka Servic 节点会自动退出自我保护模式\n\n\n# Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别\n\n 1. ZooKeeper中的节点服务挂了就要选举，在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的，选举就是该微服务做了集群，必须有一台主其他的都是从\n 2. Eureka各个节点是平等关系,服务器挂了没关系，只要有一台Eureka就可以保证服务可用，数据都是最新的。如果查询到的数据并不是最新的，就是因为Eureka的自我保护模式导致的\n 3. Eureka本质上是一个工程,而ZooKeeper只是一个进程\n 4. Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper 一样使得整个注册系统瘫痪\n 5. ZooKeeper保证的是CP，Eureka保证的是AP\n\n\n# Spring Cloud Ribbon\n\n\n# 什么是Ribbon？\n\nRibbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法 Ribbon客户端组件提供一系列完善的配置项，如连接超时，重试等。简单的说，就是在配置文件中列出后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。（有点类似Nginx）\n\n\n# Ribbon底层实现原理\n\nRibbon使用discoveryClient从注册中心读取目标服务信息，对同一接口请求进行计数，使用%取余算法获取目标服务集群索引，返回获取到的目标服务信息。\n\n\n# @LoadBalanced注解的作用？\n\n开启客户端负载均衡。\n\n\n# Spring Cloud Fegin&&OpenFeign\n\n\n# 什么是Feign\n\nFeign集成了Ribbon、RestTemplate实现了负载均衡的执行Http调用，只不过对原有的方式（Ribbon+RestTemplate）进行了封装，开发者不必手动使用RestTemplate调服务，而是定义一个接口，在这个接口中标注一个注解即可完成服务调用，这样更加符合面向接口编程的宗旨，简化了开发。\n\n\n# 什么是OpenFeign\n\nOpenFeign是springcloud在Feign的基础上支持了SpringMVC的注解，如@RequestMapping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。\n\n\n# Spring Cloud Hystrix\n\n\n# 什么是断路器\n\n当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应） 断路器有三种状态\n\n * 打开状态：一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务\n * 半开状态：短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭\n * 关闭状态：当服务一直处于正常状态 能正常调用\n\n\n# 什么是Hystrix?\n\n在分布式系统，我们一定会依赖各种服务，那么这些个服务一定会出现失败的情况，就会导致雪崩，Hystrix就是这样的一个工具，防雪崩利器，它具有服务降级，服务熔断，服务隔离，监控等一些防止雪崩的技术。 Hystrix有四种防雪崩方式:\n\n * 服务降级：接口调用失败就调用本地的方法返回一个空\n * 服务熔断：接口调用失败就会进入调用接口提前定义好的一个熔断的方法，返回错误信息\n * 服务隔离：隔离服务之间相互影响\n * 服务监控：在服务发生调用时,会将每秒请求数、成功请求数等运行指标记录下来。\n\n\n# 服务熔断与服务降级\n\n降级是从系统功能优先级的角度考虑如何应对系统故障。 服务降级指的是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。 服务熔断指的是某个服务故障或者异常，就直接熔断整个服务，而不是一直等到此服务超时。 熔断和降级是两个比较容易混淆的概念，两者的含义并不相同。 降级的目的在于应对系统自身的故障，而熔断的目的在于应对当前系统依赖的外部系统或者第三方系统的故障。\n\n\n# SpringCloud 断路器的作用是什么？\n\n在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。\n\n\n# Spring Cloud Zuul\n\n\n# 什么是网关\n\n网关相当于一个网络服务架构的入口，所有网络请求必须通过网关转发到具体的服务。\n\n\n# 网关的作用是什么\n\n网关是所有微服务的门户，路由转发仅仅是最基本的功能，除此之外还有其他的一些功能，比如：认证、鉴权、熔断、限流、日志监控等等.........\n\n\n# 什么是SpringCloud Zuul\n\nZuul是对SpringCloud提供的成熟对的路由方案，他会根据请求的路径不同，网关会定位到指定的微服务，并代理请求到不同的微服务接口，他对外隐蔽了微服务的真正接口地址。\n\n * 三个重要概念：动态路由表，路由定位，反向代理：\n   * 动态路由表：Zuul支持Eureka路由，手动配置路由，这俩种都支持自动更新\n   * 路由定位：根据请求路径，Zuul有自己的一套定位服务规则以及路由表达式匹配\n   * 反向代理：客户端请求到路由网关，网关受理之后，在对目标发送请求，拿到响应之后在 给客户端\n * 它可以和Eureka,Ribbon,Hystrix等组件配合使用，\n * Zuul的应用场景：\n   * 对外暴露，权限校验，服务聚合，日志审计等\n\n\n# SpringCloud Gateway\n\n\n# Spring Cloud Gateway几个必知的术语？\n\n 1. 路由（route）：gateway的基本构建模块。它由ID、目标URI、断言集合和过滤器集合组成。如果聚合断言结果为真，则匹配到该路由。\n 2. 断言（Predicate ）：参照Java8的新特性Predicate，允许开发人员匹配HTTP请求中的任何内容，比如头或参数。\n 3. 过滤器（filter）：可以在返回请求之前或之后修改请求和响应的内容。\n\n\n# 什么是Predict（断言）？\n\nPredicate来自于java8的接口。Predicate接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。 可以用于接口请求参数校验、判断新老数据是否有变化需要进行更新操作。 Spring Cloud Gateway内置了许多Predict，这些Predict的源码在org.springframework.cloud.gateway.handler.predicate包中。内置的一些断言如下图： 具体可以查看官方文档：https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/ 下面就以最后一种权重断言为例介绍一下如何配置。配置如下：\n\nspring:\n  cloud:\n    gateway:\n      ## 路由\n      routes:\n        ## id只要唯一即可，名称任意\n        - id: gateway-provider_1\n          uri: http://localhost:9024\n          ## 配置断言\n          predicates:\n            ## Path Route Predicate Factory断言，满足/gateway/provider/**这个请求路径的都会被路由到http://localhost:9024这个uri中\n            - Path=/gateway/provider/**\n            ## Weight Route Predicate Factory，同一分组按照权重进行分配流量，这里分配了80%\n            ## 第一个group1是分组名，第二个参数是权重\n            - Weight=group1, 8\n            \n        ## id必须唯一\n        - id: gateway-provider_2\n          ## 路由转发的uri\n          uri: http://localhost:9025\n          ## 配置断言\n          predicates:\n            ## Path Route Predicate Factory断言，满足/gateway/provider/**这个请求路径的都会被路由到http://localhost:9024这个uri中\n            - Path=/gateway/provider/**\n            ## Weight Route Predicate Factory，同一分组按照权重进行分配流量，这里分配了20%\n            ## 第一个group1是分组名，第二个参数是权重\n            - Weight=group1, 2\n\n\n\nroutes下就是配置的路由策略，各个组件如下：\n\n * id：路由的唯一id，名称任意\n * uri：路由转发的uri\n * predicates：断言配置，可以配置多个\n\nSpring Cloud Gateway中的断言命名都是有规范的，格式：xxxRoutePredicateFactory。 比如权重的断言：WeightRoutePredicateFactory，那么配置时直接取前面的Weight。 默认的路由转发如果路由到了两个，则是的按照配置先后顺序转发，上面都配置了路径：Path=/gateway/provider/**，如果没有配置权重，则肯定是转发到http://localhost:9024。 但是既然配置配置了权重并且相同的分组，则按照权重比例进行分配流量\n\n\n# 什么是过滤器？\n\n过滤器这个概念很熟悉，在Spring mvc 就接触过，Gateway的过滤器的作用以及生命周期都是类似的。 Gateway的生命周期：\n\n * PRE：这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择 请求的微服务、记录调试信息等。\n * POST：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。\n\nGateway 的Filter从作用范围可分为两种:\n\n * GatewayFilter：应用到单个路由或者一个分组的路由上（需要在配置文件中配置）。\n * GlobalFilter：应用到所有的路由上（无需配置，全局生效）\n\n\n# GatewayFilter（局部过滤器）\n\nSpring Cloud Gateway中内置了许多的局部过滤器，如下图： 局部过滤器需要在指定路由配置才能生效，默认是不生效的。 以AddResponseHeaderGatewayFilterFactory这个过滤器为例，为原始响应添加Header，配置如下：\n\nspring:\n  cloud:\n    gateway:\n      ## 路由\n      routes:\n        ## id只要唯一即可，名称任意\n        - id: gateway-provider_1\n          uri: http://localhost:9024\n          ## 配置断言\n          predicates:\n            ## Path Route Predicate Factory断言，满足/gateway/provider/**这个请求路径的都会被路由到http://localhost:9024这个uri中\n            - Path=/gateway/provider/**\n          ## 配置过滤器（局部）\n          filters:\n            - AddResponseHeader=X-Response-Foo, Bar\n\n\n\n浏览器请求，发现响应头中已经有了X-Response-Foo=Bar这个键值对，如下图：\n注意：过滤器的名称只需要写前缀，过滤器命名必须是xxxGatewayFilterFactory（包括自定义）。\n\n# 自定义局部过滤器\n\n场景：模拟一个授权验证的过程，如果请求头或者请求参数中携带token则放行，否则直接拦截返回401，代码如下：\n\n/**\n* 名称必须是xxxGatewayFilterFactory形式\n* todo：模拟授权的验证，具体逻辑根据业务完善\n*/\n@Component\n    @Slf4j\n    public class AuthorizeGatewayFilterFactory extends AbstractGatewayFilterFactory<AuthorizeGatewayFilterFactory.Config> {\n\n        private static final String AUTHORIZE_TOKEN = "token";\n\n        //构造函数，加载Config\n        public AuthorizeGatewayFilterFactory() {\n            //固定写法\n            super(AuthorizeGatewayFilterFactory.Config.class);\n            log.info("Loaded GatewayFilterFactory [Authorize]");\n        }\n\n        //读取配置文件中的参数 赋值到 配置类中\n        @Override\n        public List<String> shortcutFieldOrder() {\n            //Config.enabled\n            return Arrays.asList("enabled");\n        }\n\n        @Override\n        public GatewayFilter apply(AuthorizeGatewayFilterFactory.Config config) {\n            return (exchange, chain) -> {\n                //判断是否开启授权验证\n                if (!config.isEnabled()) {\n                    return chain.filter(exchange);\n                }\n\n                ServerHttpRequest request = exchange.getRequest();\n                HttpHeaders headers = request.getHeaders();\n                //从请求头中获取token\n                String token = headers.getFirst(AUTHORIZE_TOKEN);\n                if (token == null) {\n                    //从请求头参数中获取token\n                    token = request.getQueryParams().getFirst(AUTHORIZE_TOKEN);\n                }\n\n                ServerHttpResponse response = exchange.getResponse();\n                //如果token为空，直接返回401，未授权\n                if (StringUtils.isEmpty(token)) {\n                    response.setStatusCode(HttpStatus.UNAUTHORIZED);\n                    //处理完成，直接拦截，不再进行下去\n                    return response.setComplete();\n                }\n                /**\n* todo chain.filter(exchange) 之前的都是过滤器的前置处理\n*\n* chain.filter().then(\n*  过滤器的后置处理...........\n* )\n*/\n                //授权正常，继续下一个过滤器链的调用\n                return chain.filter(exchange);\n            };\n        }\n\n        @Data\n            @AllArgsConstructor\n            @NoArgsConstructor\n            public static class Config {\n                // 控制是否开启认证\n                private boolean enabled;\n            }\n    }\n\n\n\n局部过滤器需要在路由中配置才能生效，配置如下：\n\nspring:\n  cloud:\n    gateway:\n      ## 路由\n      routes:\n        ## id只要唯一即可，名称任意\n        - id: gateway-provider_1\n          uri: http://localhost:9024\n          ## 配置断言\n          predicates:\n            ## Path Route Predicate Factory断言，满足/gateway/provider/**这个请求路径的都会被路由到http://localhost:9024这个uri中\n            - Path=/gateway/provider/**\n          ## 配置过滤器（局部）\n          filters:\n            - AddResponseHeader=X-Response-Foo, Bar\n            ## AuthorizeGatewayFilterFactory自定义过滤器配置，值为true需要验证授权，false不需要\n            - Authorize=true\n\n\n\n此时直接访问：http://localhost:9023/gateway/provider/port，不携带token，返回如下图： 请求参数带上token：http://localhost:9023/gateway/provider/port?token=abcdcdecd-ddcdeicd12，成功返回，如下图： 上述的AuthorizeGatewayFilterFactory只是涉及到了过滤器的前置处理，后置处理是在chain.filter().then()中的then()方法中完成的，具体可以看下项目源码中的TimeGatewayFilterFactory，代码就不再贴出来了，如下图：\n\n\n\n# GlobalFilter（全局过滤器）\n\n全局过滤器应用到全部路由上，无需开发者配置，Spring Cloud Gateway也内置了一些全局过滤器，如下图： GlobalFilter的功能其实和GatewayFilter是相同的，只是GlobalFilter的作用域是所有的路由配置，而不是绑定在指定的路由配置上。多个GlobalFilter可以通过@Order或者getOrder()方法指定每个GlobalFilter的执行顺序，order值越小，GlobalFilter执行的优先级越高。 注意，由于过滤器有pre和post两种类型，pre类型过滤器如果order值越小，那么它就应该在pre过滤器链的顶层，post类型过滤器如果order值越小，那么它就应该在pre过滤器链的底层。示意图如下：\n\n当然除了内置的全局过滤器，实际工作中还需要定制过滤器，下面来介绍一下如何自定义。\n\n# 自定义全局过滤器\n\n场景：模拟Nginx的Access Log 功能，记录每次请求的相关信息。代码如下：\n\n/**\n* 实现GlobalFilter\n*/\n@Slf4j\n    @Component\n    @Order(value = Integer.MIN_VALUE)\n    public class AccessLogGlobalFilter implements GlobalFilter {\n\n        @Override\n        public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n            //filter的前置处理\n            ServerHttpRequest request = exchange.getRequest();\n            String path = request.getPath().pathWithinApplication().value();\n            InetSocketAddress remoteAddress = request.getRemoteAddress();\n            return chain\n                //继续调用filter\n                .filter(exchange)\n                //filter的后置处理\n                .then(Mono.fromRunnable(() -> {\n                    ServerHttpResponse response = exchange.getResponse();\n                    HttpStatus statusCode = response.getStatusCode();\n                    log.info("请求路径:{},远程IP地址:{},响应码:{}", path, remoteAddress, statusCode);\n                }));\n        }\n    }\n\n\n\n好了，全局过滤器不必在路由上配置，注入到IOC容器中即可全局生效。 此时发出一个请求，控制台打印信息如下：\n\n请求路径:/gateway/provider/port,远程IP地址:/0:0:0:0:0:0:0:1:64114,响应码:200 OK\n\n\n\n\n# 为什么要集成注册中心\n\n * 使得网关能够从注册中心自动获取uri ，防止服务的IP的地址一旦修改了，路由配置中的uri必须修改\n * 服务集群中实现负载均衡\n\n\n# 如何实现动态路由\n\n将网关的配置存放到 Nacos 配置中心中，这样由配置中心统一管理，一旦路由发生改变，只需要在配置中心修改，便能达到一处修改，多处生效的目的。\n\n\n# 如何实现自定义全局异常处理\n\n直接创建一个自定义全局异常处理类，实现ErrorWebExceptionHandler，重写其中的handle方法\n\n\n# Spring Cloud Config\n\n\n# 什么是SpringCLoud Config\n\nSpring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持，可以方便的对微服务各个环境下的配置进行集中式管理。 Spring Cloud Config分为Config Server和Config Client两部分。Config Server负责读取配置文件，并且暴露Http API接口，Config Client通过调用Config Server的接口来读取配置文件。\n\n\n# SpringCloud Config可以实现实时刷新吗\n\nspringcloud config实时刷新采用SpringCloud Bus消息总线。\n\n\n# Spring Cloud Bus\n\n\n# 什么是 Spring Cloud Bus\n\n * Spring Cloud Bus就像一个分布式执行器，用于扩展的Spring Boot应用程序的配置文件，但也可以用作应用程序之间的通信通道。\n * Spring Cloud Bus 不能单独完成通信，需要配合MQ支持\n * Spring Cloud Bus一般是配合Spring Cloud Config做配置中心的\n * Springcloud config实时刷新也必须采用SpringCloud Bus消息总线\n\n\n# Spring Cloud Sleuth\n\n\n# 分布式链路追踪使用什么实现\n\n分布式链路追踪使用 Spring Cloud Sleuth+ zipkin 实现的， Sleuth实现日志采集，zipkin实现可视化。 zipkin 修改默认http传输改为MQ传输，可以防止数据丢失和进行异步解耦提高性能。 zipkin 持久化方式是使用 Elasticsearch 进行存储的（默认为内存存储）。\n\nhttps://www.cnblogs.com/cbvlog/p/15571496.html',normalizedContent:'# springcloud 基础\n\n\n# 什么是 springcloud？\n\nspring cloud是一系列框架的有序集合。它利用spring boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用spring boot的开发风格做到一键启动和部署。 spring cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过spring boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。\n\n\n# springcloud 的核心组件有哪些？\n\n * spring cloud eureka（服务注册中心）：特性有失效剔除、服务保护\n * spring cloud zuul（api服务网关）：功能有路由分发和过滤\n * spring cloud config（分布式配置中心）：支持本地仓库、svn、git、jar包内配置等模式\n * spring cloud ribbon（客户端负载均衡）：特性有区域亲和,重试机制\n * spring cloud hystrix（服务断路器）：客户端容错保护,特性有服务降级、服务熔断、请求缓存、请求合并、依赖隔离\n * spring cloud feign（服务接口调用）：声明式服务调用本质上就是ribbon+hystrix\n * spring cloud stream（消息驱动）：有sink、source、processor三种通道,特性有订阅发布、消费组、消息分区\n * spring cloud bus（消息总线）：配合config仓库修改的一种stream实现，\n * spring cloud sleuth（分布式服务追踪）：需要搞清楚traceid和spanid以及抽样,如何与elk整合\n\n\n# spring cloud eureka\n\n\n# 什么是eureka\n\neureka作为springcloud的服务注册功能服务器，他是服务注册中心，系统中的其他服务使用eureka的客户端将其连接到eureka service中，并且保持心跳，这样工作人员可以通过eureka service来监控各个微服务是否运行正常。\n\n\n# springcloud 如何实现服务的注册\n\n 1. 服务发布时，指定对应的服务名,将服务注册到 注册中心 eureka\n 2. 注册中心加@enableeurekaserver,服务用@enablediscoveryclient，然后用ribbon或feign进行服务直接的调用发现。\n\n\n# eureka自我保护机制是什么?\n\n默认情况下，如果eureka service在一定时间内没有接收到某个微服务的心跳，eureka service会进入自我保护模式，在该模式下eureka service会保护服务注册表中的信息，不再删除注册表中的数据，当网络故障恢复后，eureka servic 节点会自动退出自我保护模式\n\n\n# eureka和zookeeper都可以提供服务注册与发现的功能,请说说两个的区别\n\n 1. zookeeper中的节点服务挂了就要选举，在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的，选举就是该微服务做了集群，必须有一台主其他的都是从\n 2. eureka各个节点是平等关系,服务器挂了没关系，只要有一台eureka就可以保证服务可用，数据都是最新的。如果查询到的数据并不是最新的，就是因为eureka的自我保护模式导致的\n 3. eureka本质上是一个工程,而zookeeper只是一个进程\n 4. eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像zookeeper 一样使得整个注册系统瘫痪\n 5. zookeeper保证的是cp，eureka保证的是ap\n\n\n# spring cloud ribbon\n\n\n# 什么是ribbon？\n\nribbon是netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法 ribbon客户端组件提供一系列完善的配置项，如连接超时，重试等。简单的说，就是在配置文件中列出后面所有的机器，ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用ribbon实现自定义的负载均衡算法。（有点类似nginx）\n\n\n# ribbon底层实现原理\n\nribbon使用discoveryclient从注册中心读取目标服务信息，对同一接口请求进行计数，使用%取余算法获取目标服务集群索引，返回获取到的目标服务信息。\n\n\n# @loadbalanced注解的作用？\n\n开启客户端负载均衡。\n\n\n# spring cloud fegin&&openfeign\n\n\n# 什么是feign\n\nfeign集成了ribbon、resttemplate实现了负载均衡的执行http调用，只不过对原有的方式（ribbon+resttemplate）进行了封装，开发者不必手动使用resttemplate调服务，而是定义一个接口，在这个接口中标注一个注解即可完成服务调用，这样更加符合面向接口编程的宗旨，简化了开发。\n\n\n# 什么是openfeign\n\nopenfeign是springcloud在feign的基础上支持了springmvc的注解，如@requestmapping等等。openfeign的@feignclient可以解析springmvc的@requestmapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。\n\n\n# spring cloud hystrix\n\n\n# 什么是断路器\n\n当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应） 断路器有三种状态\n\n * 打开状态：一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务\n * 半开状态：短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭\n * 关闭状态：当服务一直处于正常状态 能正常调用\n\n\n# 什么是hystrix?\n\n在分布式系统，我们一定会依赖各种服务，那么这些个服务一定会出现失败的情况，就会导致雪崩，hystrix就是这样的一个工具，防雪崩利器，它具有服务降级，服务熔断，服务隔离，监控等一些防止雪崩的技术。 hystrix有四种防雪崩方式:\n\n * 服务降级：接口调用失败就调用本地的方法返回一个空\n * 服务熔断：接口调用失败就会进入调用接口提前定义好的一个熔断的方法，返回错误信息\n * 服务隔离：隔离服务之间相互影响\n * 服务监控：在服务发生调用时,会将每秒请求数、成功请求数等运行指标记录下来。\n\n\n# 服务熔断与服务降级\n\n降级是从系统功能优先级的角度考虑如何应对系统故障。 服务降级指的是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。 服务熔断指的是某个服务故障或者异常，就直接熔断整个服务，而不是一直等到此服务超时。 熔断和降级是两个比较容易混淆的概念，两者的含义并不相同。 降级的目的在于应对系统自身的故障，而熔断的目的在于应对当前系统依赖的外部系统或者第三方系统的故障。\n\n\n# springcloud 断路器的作用是什么？\n\n在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。\n\n\n# spring cloud zuul\n\n\n# 什么是网关\n\n网关相当于一个网络服务架构的入口，所有网络请求必须通过网关转发到具体的服务。\n\n\n# 网关的作用是什么\n\n网关是所有微服务的门户，路由转发仅仅是最基本的功能，除此之外还有其他的一些功能，比如：认证、鉴权、熔断、限流、日志监控等等.........\n\n\n# 什么是springcloud zuul\n\nzuul是对springcloud提供的成熟对的路由方案，他会根据请求的路径不同，网关会定位到指定的微服务，并代理请求到不同的微服务接口，他对外隐蔽了微服务的真正接口地址。\n\n * 三个重要概念：动态路由表，路由定位，反向代理：\n   * 动态路由表：zuul支持eureka路由，手动配置路由，这俩种都支持自动更新\n   * 路由定位：根据请求路径，zuul有自己的一套定位服务规则以及路由表达式匹配\n   * 反向代理：客户端请求到路由网关，网关受理之后，在对目标发送请求，拿到响应之后在 给客户端\n * 它可以和eureka,ribbon,hystrix等组件配合使用，\n * zuul的应用场景：\n   * 对外暴露，权限校验，服务聚合，日志审计等\n\n\n# springcloud gateway\n\n\n# spring cloud gateway几个必知的术语？\n\n 1. 路由（route）：gateway的基本构建模块。它由id、目标uri、断言集合和过滤器集合组成。如果聚合断言结果为真，则匹配到该路由。\n 2. 断言（predicate ）：参照java8的新特性predicate，允许开发人员匹配http请求中的任何内容，比如头或参数。\n 3. 过滤器（filter）：可以在返回请求之前或之后修改请求和响应的内容。\n\n\n# 什么是predict（断言）？\n\npredicate来自于java8的接口。predicate接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将predicate组合成其他复杂的逻辑（比如：与，或，非）。 可以用于接口请求参数校验、判断新老数据是否有变化需要进行更新操作。 spring cloud gateway内置了许多predict，这些predict的源码在org.springframework.cloud.gateway.handler.predicate包中。内置的一些断言如下图： 具体可以查看官方文档：https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.release/reference/html/ 下面就以最后一种权重断言为例介绍一下如何配置。配置如下：\n\nspring:\n  cloud:\n    gateway:\n      ## 路由\n      routes:\n        ## id只要唯一即可，名称任意\n        - id: gateway-provider_1\n          uri: http://localhost:9024\n          ## 配置断言\n          predicates:\n            ## path route predicate factory断言，满足/gateway/provider/**这个请求路径的都会被路由到http://localhost:9024这个uri中\n            - path=/gateway/provider/**\n            ## weight route predicate factory，同一分组按照权重进行分配流量，这里分配了80%\n            ## 第一个group1是分组名，第二个参数是权重\n            - weight=group1, 8\n            \n        ## id必须唯一\n        - id: gateway-provider_2\n          ## 路由转发的uri\n          uri: http://localhost:9025\n          ## 配置断言\n          predicates:\n            ## path route predicate factory断言，满足/gateway/provider/**这个请求路径的都会被路由到http://localhost:9024这个uri中\n            - path=/gateway/provider/**\n            ## weight route predicate factory，同一分组按照权重进行分配流量，这里分配了20%\n            ## 第一个group1是分组名，第二个参数是权重\n            - weight=group1, 2\n\n\n\nroutes下就是配置的路由策略，各个组件如下：\n\n * id：路由的唯一id，名称任意\n * uri：路由转发的uri\n * predicates：断言配置，可以配置多个\n\nspring cloud gateway中的断言命名都是有规范的，格式：xxxroutepredicatefactory。 比如权重的断言：weightroutepredicatefactory，那么配置时直接取前面的weight。 默认的路由转发如果路由到了两个，则是的按照配置先后顺序转发，上面都配置了路径：path=/gateway/provider/**，如果没有配置权重，则肯定是转发到http://localhost:9024。 但是既然配置配置了权重并且相同的分组，则按照权重比例进行分配流量\n\n\n# 什么是过滤器？\n\n过滤器这个概念很熟悉，在spring mvc 就接触过，gateway的过滤器的作用以及生命周期都是类似的。 gateway的生命周期：\n\n * pre：这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择 请求的微服务、记录调试信息等。\n * post：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的http header、收集统计信息和指标、将响应从微服务发送给客户端等。\n\ngateway 的filter从作用范围可分为两种:\n\n * gatewayfilter：应用到单个路由或者一个分组的路由上（需要在配置文件中配置）。\n * globalfilter：应用到所有的路由上（无需配置，全局生效）\n\n\n# gatewayfilter（局部过滤器）\n\nspring cloud gateway中内置了许多的局部过滤器，如下图： 局部过滤器需要在指定路由配置才能生效，默认是不生效的。 以addresponseheadergatewayfilterfactory这个过滤器为例，为原始响应添加header，配置如下：\n\nspring:\n  cloud:\n    gateway:\n      ## 路由\n      routes:\n        ## id只要唯一即可，名称任意\n        - id: gateway-provider_1\n          uri: http://localhost:9024\n          ## 配置断言\n          predicates:\n            ## path route predicate factory断言，满足/gateway/provider/**这个请求路径的都会被路由到http://localhost:9024这个uri中\n            - path=/gateway/provider/**\n          ## 配置过滤器（局部）\n          filters:\n            - addresponseheader=x-response-foo, bar\n\n\n\n浏览器请求，发现响应头中已经有了x-response-foo=bar这个键值对，如下图：\n注意：过滤器的名称只需要写前缀，过滤器命名必须是xxxgatewayfilterfactory（包括自定义）。\n\n# 自定义局部过滤器\n\n场景：模拟一个授权验证的过程，如果请求头或者请求参数中携带token则放行，否则直接拦截返回401，代码如下：\n\n/**\n* 名称必须是xxxgatewayfilterfactory形式\n* todo：模拟授权的验证，具体逻辑根据业务完善\n*/\n@component\n    @slf4j\n    public class authorizegatewayfilterfactory extends abstractgatewayfilterfactory<authorizegatewayfilterfactory.config> {\n\n        private static final string authorize_token = "token";\n\n        //构造函数，加载config\n        public authorizegatewayfilterfactory() {\n            //固定写法\n            super(authorizegatewayfilterfactory.config.class);\n            log.info("loaded gatewayfilterfactory [authorize]");\n        }\n\n        //读取配置文件中的参数 赋值到 配置类中\n        @override\n        public list<string> shortcutfieldorder() {\n            //config.enabled\n            return arrays.aslist("enabled");\n        }\n\n        @override\n        public gatewayfilter apply(authorizegatewayfilterfactory.config config) {\n            return (exchange, chain) -> {\n                //判断是否开启授权验证\n                if (!config.isenabled()) {\n                    return chain.filter(exchange);\n                }\n\n                serverhttprequest request = exchange.getrequest();\n                httpheaders headers = request.getheaders();\n                //从请求头中获取token\n                string token = headers.getfirst(authorize_token);\n                if (token == null) {\n                    //从请求头参数中获取token\n                    token = request.getqueryparams().getfirst(authorize_token);\n                }\n\n                serverhttpresponse response = exchange.getresponse();\n                //如果token为空，直接返回401，未授权\n                if (stringutils.isempty(token)) {\n                    response.setstatuscode(httpstatus.unauthorized);\n                    //处理完成，直接拦截，不再进行下去\n                    return response.setcomplete();\n                }\n                /**\n* todo chain.filter(exchange) 之前的都是过滤器的前置处理\n*\n* chain.filter().then(\n*  过滤器的后置处理...........\n* )\n*/\n                //授权正常，继续下一个过滤器链的调用\n                return chain.filter(exchange);\n            };\n        }\n\n        @data\n            @allargsconstructor\n            @noargsconstructor\n            public static class config {\n                // 控制是否开启认证\n                private boolean enabled;\n            }\n    }\n\n\n\n局部过滤器需要在路由中配置才能生效，配置如下：\n\nspring:\n  cloud:\n    gateway:\n      ## 路由\n      routes:\n        ## id只要唯一即可，名称任意\n        - id: gateway-provider_1\n          uri: http://localhost:9024\n          ## 配置断言\n          predicates:\n            ## path route predicate factory断言，满足/gateway/provider/**这个请求路径的都会被路由到http://localhost:9024这个uri中\n            - path=/gateway/provider/**\n          ## 配置过滤器（局部）\n          filters:\n            - addresponseheader=x-response-foo, bar\n            ## authorizegatewayfilterfactory自定义过滤器配置，值为true需要验证授权，false不需要\n            - authorize=true\n\n\n\n此时直接访问：http://localhost:9023/gateway/provider/port，不携带token，返回如下图： 请求参数带上token：http://localhost:9023/gateway/provider/port?token=abcdcdecd-ddcdeicd12，成功返回，如下图： 上述的authorizegatewayfilterfactory只是涉及到了过滤器的前置处理，后置处理是在chain.filter().then()中的then()方法中完成的，具体可以看下项目源码中的timegatewayfilterfactory，代码就不再贴出来了，如下图：\n\n\n\n# globalfilter（全局过滤器）\n\n全局过滤器应用到全部路由上，无需开发者配置，spring cloud gateway也内置了一些全局过滤器，如下图： globalfilter的功能其实和gatewayfilter是相同的，只是globalfilter的作用域是所有的路由配置，而不是绑定在指定的路由配置上。多个globalfilter可以通过@order或者getorder()方法指定每个globalfilter的执行顺序，order值越小，globalfilter执行的优先级越高。 注意，由于过滤器有pre和post两种类型，pre类型过滤器如果order值越小，那么它就应该在pre过滤器链的顶层，post类型过滤器如果order值越小，那么它就应该在pre过滤器链的底层。示意图如下：\n\n当然除了内置的全局过滤器，实际工作中还需要定制过滤器，下面来介绍一下如何自定义。\n\n# 自定义全局过滤器\n\n场景：模拟nginx的access log 功能，记录每次请求的相关信息。代码如下：\n\n/**\n* 实现globalfilter\n*/\n@slf4j\n    @component\n    @order(value = integer.min_value)\n    public class accesslogglobalfilter implements globalfilter {\n\n        @override\n        public mono<void> filter(serverwebexchange exchange, gatewayfilterchain chain) {\n            //filter的前置处理\n            serverhttprequest request = exchange.getrequest();\n            string path = request.getpath().pathwithinapplication().value();\n            inetsocketaddress remoteaddress = request.getremoteaddress();\n            return chain\n                //继续调用filter\n                .filter(exchange)\n                //filter的后置处理\n                .then(mono.fromrunnable(() -> {\n                    serverhttpresponse response = exchange.getresponse();\n                    httpstatus statuscode = response.getstatuscode();\n                    log.info("请求路径:{},远程ip地址:{},响应码:{}", path, remoteaddress, statuscode);\n                }));\n        }\n    }\n\n\n\n好了，全局过滤器不必在路由上配置，注入到ioc容器中即可全局生效。 此时发出一个请求，控制台打印信息如下：\n\n请求路径:/gateway/provider/port,远程ip地址:/0:0:0:0:0:0:0:1:64114,响应码:200 ok\n\n\n\n\n# 为什么要集成注册中心\n\n * 使得网关能够从注册中心自动获取uri ，防止服务的ip的地址一旦修改了，路由配置中的uri必须修改\n * 服务集群中实现负载均衡\n\n\n# 如何实现动态路由\n\n将网关的配置存放到 nacos 配置中心中，这样由配置中心统一管理，一旦路由发生改变，只需要在配置中心修改，便能达到一处修改，多处生效的目的。\n\n\n# 如何实现自定义全局异常处理\n\n直接创建一个自定义全局异常处理类，实现errorwebexceptionhandler，重写其中的handle方法\n\n\n# spring cloud config\n\n\n# 什么是springcloud config\n\nspring cloud config为分布式系统中的外部配置提供服务器和客户端支持，可以方便的对微服务各个环境下的配置进行集中式管理。 spring cloud config分为config server和config client两部分。config server负责读取配置文件，并且暴露http api接口，config client通过调用config server的接口来读取配置文件。\n\n\n# springcloud config可以实现实时刷新吗\n\nspringcloud config实时刷新采用springcloud bus消息总线。\n\n\n# spring cloud bus\n\n\n# 什么是 spring cloud bus\n\n * spring cloud bus就像一个分布式执行器，用于扩展的spring boot应用程序的配置文件，但也可以用作应用程序之间的通信通道。\n * spring cloud bus 不能单独完成通信，需要配合mq支持\n * spring cloud bus一般是配合spring cloud config做配置中心的\n * springcloud config实时刷新也必须采用springcloud bus消息总线\n\n\n# spring cloud sleuth\n\n\n# 分布式链路追踪使用什么实现\n\n分布式链路追踪使用 spring cloud sleuth+ zipkin 实现的， sleuth实现日志采集，zipkin实现可视化。 zipkin 修改默认http传输改为mq传输，可以防止数据丢失和进行异步解耦提高性能。 zipkin 持久化方式是使用 elasticsearch 进行存储的（默认为内存存储）。\n\nhttps://www.cnblogs.com/cbvlog/p/15571496.html',charsets:{cjk:!0},lastUpdated:"2023/11/02, 03:14:56",lastUpdatedTimestamp:1698894896e3},{title:"SpringCloudAlibaba 面试题",frontmatter:{title:"SpringCloudAlibaba 面试题",date:"2023-10-24T15:46:26.000Z",permalink:"/pages/4a2429/"},regularPath:"/02.Java%20%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%20%E5%85%AB%E8%82%A1%E6%96%87/12.SpringCloudAlibaba%20%E9%9D%A2%E8%AF%95%E9%A2%98.html",relativePath:"02.Java 面试宝典/02.Java 八股文/12.SpringCloudAlibaba 面试题.md",key:"v-9499db24",path:"/pages/4a2429/",headers:[{level:1,title:"SpringCloud Alibaba Nacos",slug:"springcloud-alibaba-nacos",normalizedTitle:"springcloud alibaba nacos",charIndex:2},{level:1,title:"SpringCloud Alibaba Sentinel",slug:"springcloud-alibaba-sentinel",normalizedTitle:"springcloud alibaba sentinel",charIndex:32},{level:1,title:"SpringCloud Alibaba Seata",slug:"springcloud-alibaba-seata",normalizedTitle:"springcloud alibaba seata",charIndex:65},{level:2,title:"分布式事务怎么实现",slug:"分布式事务怎么实现",normalizedTitle:"分布式事务怎么实现",charIndex:95}],headersStr:"SpringCloud Alibaba Nacos SpringCloud Alibaba Sentinel SpringCloud Alibaba Seata 分布式事务怎么实现",content:"# SpringCloud Alibaba Nacos\n\n\n# SpringCloud Alibaba Sentinel\n\n\n# SpringCloud Alibaba Seata\n\n\n# 分布式事务怎么实现\n\n通过阿里巴巴的开源组件Seata，使用 @GlobalTransactional 注解， 就可以高效并且对业务零侵入地解决分布式事务问题。",normalizedContent:"# springcloud alibaba nacos\n\n\n# springcloud alibaba sentinel\n\n\n# springcloud alibaba seata\n\n\n# 分布式事务怎么实现\n\n通过阿里巴巴的开源组件seata，使用 @globaltransactional 注解， 就可以高效并且对业务零侵入地解决分布式事务问题。",charsets:{cjk:!0},lastUpdated:"2023/11/02, 03:14:56",lastUpdatedTimestamp:1698894896e3},{title:"分布式",frontmatter:{title:"分布式",date:"2023-10-24T15:50:17.000Z",permalink:"/pages/0d16b1/"},regularPath:"/02.Java%20%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%20%E5%85%AB%E8%82%A1%E6%96%87/13.%E5%88%86%E5%B8%83%E5%BC%8F.html",relativePath:"02.Java 面试宝典/02.Java 八股文/13.分布式.md",key:"v-4d6aaf62",path:"/pages/0d16b1/",headers:[{level:1,title:"分布式基础",slug:"分布式基础",normalizedTitle:"分布式基础",charIndex:2},{level:2,title:"什么是分布式",slug:"什么是分布式",normalizedTitle:"什么是分布式",charIndex:12},{level:2,title:"为什么要使用分布式",slug:"为什么要使用分布式",normalizedTitle:"为什么要使用分布式",charIndex:194},{level:1,title:"分布式理论",slug:"分布式理论",normalizedTitle:"分布式理论",charIndex:312},{level:2,title:"CAP 理论",slug:"cap-理论",normalizedTitle:"cap 理论",charIndex:322},{level:3,title:"分布式一致性的 3 种级别",slug:"分布式一致性的-3-种级别",normalizedTitle:"分布式一致性的 3 种级别",charIndex:883},{level:2,title:"BASE 理论",slug:"base-理论",normalizedTitle:"base 理论",charIndex:1088},{level:1,title:"分布式事务",slug:"分布式事务",normalizedTitle:"分布式事务",charIndex:1786},{level:2,title:"什么是分布式事务？",slug:"什么是分布式事务",normalizedTitle:"什么是分布式事务？",charIndex:1796},{level:2,title:"柔性事务和刚性事务",slug:"柔性事务和刚性事务",normalizedTitle:"柔性事务和刚性事务",charIndex:1836},{level:2,title:"分布式事务解决方案",slug:"分布式事务解决方案",normalizedTitle:"分布式事务解决方案",charIndex:1987},{level:3,title:"XA 规范的角色组成",slug:"xa-规范的角色组成",normalizedTitle:"xa 规范的角色组成",charIndex:2156},{level:3,title:"2PC（两阶段提交协议）",slug:"_2pc-两阶段提交协议",normalizedTitle:"2pc（两阶段提交协议）",charIndex:2407},{level:3,title:"3PC（三阶段提交协议）",slug:"_3pc-三阶段提交协议",normalizedTitle:"3pc（三阶段提交协议）",charIndex:2655},{level:3,title:"TCC（补偿事务）",slug:"tcc-补偿事务",normalizedTitle:"tcc（补偿事务）",charIndex:3358},{level:3,title:"MQ事务",slug:"mq事务",normalizedTitle:"mq事务",charIndex:1932},{level:1,title:"分布式日志管理",slug:"分布式日志管理",normalizedTitle:"分布式日志管理",charIndex:3946},{level:2,title:"日志系统需要做哪些事情",slug:"日志系统需要做哪些事情",normalizedTitle:"日志系统需要做哪些事情",charIndex:3958},{level:2,title:"项目中怎么管理日志的",slug:"项目中怎么管理日志的",normalizedTitle:"项目中怎么管理日志的",charIndex:4085}],headersStr:"分布式基础 什么是分布式 为什么要使用分布式 分布式理论 CAP 理论 分布式一致性的 3 种级别 BASE 理论 分布式事务 什么是分布式事务？ 柔性事务和刚性事务 分布式事务解决方案 XA 规范的角色组成 2PC（两阶段提交协议） 3PC（三阶段提交协议） TCC（补偿事务） MQ事务 分布式日志管理 日志系统需要做哪些事情 项目中怎么管理日志的",content:"# 分布式基础\n\n\n# 什么是分布式\n\n分布式或者说 SOA 分布式重要的就是面向服务，说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。比如电商系统可以简单地拆分成订单系统、商品系统、登录系统等等，拆分之后的每个服务可以部署在不同的机器上，如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上。\n\n\n# 为什么要使用分布式\n\n从开发角度来讲单体应用的代码都集中在一起，而分布式系统的代码根据业务被拆分。所以，每个团队可以负责一个服务的开发，这样提升了开发效率。另外，代码根据业务拆分之后更加便于维护和扩展，也能提高整个系统的性能。\n\n\n# 分布式理论\n\n\n# CAP 理论\n\nCAP 也就是 Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性） 这三个单词首字母组合 ：\n\n * 一致性（Consistency） : 所有节点访问同一份最新的数据副本\n * 可用性（Availability）: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。\n * 分区容错性（Partition tolerance） : 分布式系统出现网络分区的时候，仍然能够对外提供服务。\n\n当发生网络分区时，只能保证CP或者AP。 比如 ZooKeeper 就是 CP 架构，Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。\n\n什么是网络分区?\n\n> 分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。\n\n参考：https://javaguide.cn/distributed-system/%E7%90%86%E8%AE%BA&%E7%AE%97%E6%B3%95/cap&base%E7%90%86%E8%AE%BA/#cap%E7%90%86%E8%AE%BA\n\n\n# 分布式一致性的 3 种级别\n\n * 强一致性 ：系统写入了什么，读出来的就是什么。\n * 弱一致性 ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。\n * 最终一致性 ：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。\n\n业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。\n\n\n# BASE 理论\n\nBASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。 BASE理论的核心思想是即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。\nBASE 是 Basically Available（基本可用） 、Soft-state（软状态） 和 Eventually Consistent（最终一致性） 三个短语的缩写。\n\n * 基本可用：是指分布式系统在出现不可预知故障的时候，允许损失部分可用性（响应时间上的损失和系统非核心功能上的损失）。但是，这绝不等价于系统不可用。\n * **软状态：**指允许系统中的数据存在中间状态（CAP 理论中的数据不一致），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。\n * 最终一致性：强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。\n\n参考：https://javaguide.cn/distributed-system/%E7%90%86%E8%AE%BA&%E7%AE%97%E6%B3%95/cap&base%E7%90%86%E8%AE%BA/#base-%E7%90%86%E8%AE%BA\n\n\n# 分布式事务\n\n\n# 什么是分布式事务？\n\n分布式事务就是为了保证不同数据库的数据一致性 。\n\n\n# 柔性事务和刚性事务\n\n * 柔性事务追求的是最终一致性。柔性事务就是BASE理论+业务实际。柔性事务追求的目标是：根据自身业务特性，通过适当的方式保证系统数据的最终一致性。像TCC、Saga、MQ事务、本地消息表都是柔性事务。\n * 刚性事务追求的是强一致性。像2PC、3PC就属于刚性事务。\n\n\n# 分布式事务解决方案\n\n分布式事务的解决方案有很多，比如：2PC、3PC、TCC、本地消息表、MQ事务（Kafka和RocketMQ都提供了事务相关共）、Saga等等。 2PC、3PC属于业务代码无侵入方案，都是基于XA规范衍生出来的实现。TCC、Saga属于业务侵入方案，MQ事务依赖于使用消息队列的场景，本地消息表不支持回滚。\n\n\n# XA 规范的角色组成\n\n2PC 和 3PC 涉及到的一些角色（XA 规范的角色组成）\n\n * AP（Application Program）：应用程序本身\n * RM（Resource Manager） ：资源管理器，也就是事务的参与者，绝大部分情况下就是指数据库（后文会以关系型数据库为例），一个分布式事务往往涉及到多个 RM。\n * TM（Transaction Manager） ：事务管理器，负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等。\n\n\n# 2PC（两阶段提交协议）\n\n2PC（Two-Phase Commit）这三个字母的含义:\n\n * 2 -> 指代事务提交的 2 个阶段\n * P-> Prepare (准备阶段)\n * C ->Commit（提交阶段）\n\n2PC 将事务的提交过程分为 2 个阶段：\n\n * 准备阶段：主要是为了测试 RM 能否执行 本地数据库事务 操作，并不会提交事务\n * 提交阶段： TM 会根据 准备阶段 中 RM 的消息来决定是执行事务提交还是回滚操作。提交阶段 之后一定会结束当前的分布式事务\n\n\n# 3PC（三阶段提交协议）\n\n3PC 把 2PC 中的 准备阶段(Prepare) 做了进一步细化分为了准备阶段(CanCommit)和预提交阶段(PreCommit)。分为三个阶段：\n\n * 准备阶段：这一步不会执行事务操作，只是向 RM 发送 准备请求 ，顺便询问一些信息比如事务参与者能否执行本地数据库事务操作。RM 回复“Yes”、“No”或者直接超时。如果任一 RM 回复“No”或者直接超时的话，就中断事务（向所有参与者发送“Abort”消息），否则进入 预提交阶段(PreCommit) 。\n * 预提交阶段：TM 向所有涉及到的 RM 发送 预提交请求 ，RM 收到消息之后会执行本地数据库事务预操作比如写 redo log/undo log 日志。如果 RM 成功的执行了事务预操作，就返回 “ACK”。否则，返回“No”（最后的反悔机会）或者直接超时。如果任一 RM 回复“No”或者直接超时的话，就中断事务（向所有事务参与者发送“Abort”消息），否则进入 执行事务提交阶段（DoCommit）\n * 执行事务提交阶段：执行事务提交（DoCommit） 阶段就开始进行真正的事务提交。TM 向所有涉及到的 RM 发送 执行事务提交请求 ，RM 收到消息后开始正式提交事务，并在完成事务提交后释放占用的资源。 如果 TM 收到所有 RM 正确提交事务的消息的话，表示事务正常完成。如果任一 RM 没有正确提交事务或者超时的话，就中断事务，TM 向所有 RM 发送“Abort”消息。RM 接收到 Abort 请求后，执行本地数据库事务回滚，后面的步骤就和 2PC 中的类似了。\n\n\n# TCC（补偿事务）\n\nTCC 是 Try、Confirm、Cancel 三个词的缩写，它分为三个阶段：\n\n 1. Try（尝试）阶段 : 尝试执行。完成业务检查，并预留好必需的业务资源。\n 2. Confirm（确认）阶段 ：确认执行。当所有事务参与者的 Try 阶段执行成功就会执行 Confirm ，Confirm 阶段会处理 Try 阶段预留的业务资源。否则，就会执行 Cancel 。\n 3. Cancel（取消）阶段 ：取消执行，释放 Try 阶段预留的业务资源。\n\n每个阶段由业务代码控制，这样可以避免长事务，性能更好。 我们拿转账场景来说：\n\n 1. Try（尝试）阶段 : 在转账场景下，Try 要做的事情是就是检查账户余额是否充足，预留的资源就是转账资金。\n 2. Confirm（确认）阶段 ： 如果 Try 阶段执行成功的话，Confirm 阶段就会执行真正的扣钱操作。\n 3. Cancel（取消）阶段 ：释放 Try 阶段预留的转账资金。\n\n一般情况下，当我们使用TCC模式的时候，需要自己实现 try, confirm, cancel 这三个方法，来达到最终一致性。\n\n\n# MQ事务\n\nRocketMQ 、 Kafka、Pulsar 、QMQ 都提供了事务相关的功能。事务允许事件流应用将消费，处理，生产消息整个过程定义为一个原子操作。\n\n\n# 分布式日志管理\n\n\n# 日志系统需要做哪些事情\n\n 1. 采集日志\n 2. 日志数据清洗/处理\n 3. 存储：比如 ElasticSearch存储\n 4. 展示与搜索：支持可视化日志展示，能够根据关键词快速定位到日志并查看上下文。\n 5. 告警：支持对接常见的监控系统\n\n\n# 项目中怎么管理日志的\n\n项目中使用 Loki 管理日志的，相对于ELK来说，Loki更为轻量级，资源成本更低，并且简单易用。",normalizedContent:"# 分布式基础\n\n\n# 什么是分布式\n\n分布式或者说 soa 分布式重要的就是面向服务，说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。比如电商系统可以简单地拆分成订单系统、商品系统、登录系统等等，拆分之后的每个服务可以部署在不同的机器上，如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上。\n\n\n# 为什么要使用分布式\n\n从开发角度来讲单体应用的代码都集中在一起，而分布式系统的代码根据业务被拆分。所以，每个团队可以负责一个服务的开发，这样提升了开发效率。另外，代码根据业务拆分之后更加便于维护和扩展，也能提高整个系统的性能。\n\n\n# 分布式理论\n\n\n# cap 理论\n\ncap 也就是 consistency（一致性）、availability（可用性）、partition tolerance（分区容错性） 这三个单词首字母组合 ：\n\n * 一致性（consistency） : 所有节点访问同一份最新的数据副本\n * 可用性（availability）: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。\n * 分区容错性（partition tolerance） : 分布式系统出现网络分区的时候，仍然能够对外提供服务。\n\n当发生网络分区时，只能保证cp或者ap。 比如 zookeeper 就是 cp 架构，eureka 就是 ap 架构，nacos 不仅支持 cp 架构也支持 ap 架构。\n\n什么是网络分区?\n\n> 分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。\n\n参考：https://javaguide.cn/distributed-system/%e7%90%86%e8%ae%ba&%e7%ae%97%e6%b3%95/cap&base%e7%90%86%e8%ae%ba/#cap%e7%90%86%e8%ae%ba\n\n\n# 分布式一致性的 3 种级别\n\n * 强一致性 ：系统写入了什么，读出来的就是什么。\n * 弱一致性 ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。\n * 最终一致性 ：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。\n\n业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。\n\n\n# base 理论\n\nbase 理论本质上是对 cap 的延伸和补充，更具体地说，是对 cap 中 ap 方案的一个补充。 base理论的核心思想是即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 ap 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 base 理论延伸的地方。\nbase 是 basically available（基本可用） 、soft-state（软状态） 和 eventually consistent（最终一致性） 三个短语的缩写。\n\n * 基本可用：是指分布式系统在出现不可预知故障的时候，允许损失部分可用性（响应时间上的损失和系统非核心功能上的损失）。但是，这绝不等价于系统不可用。\n * **软状态：**指允许系统中的数据存在中间状态（cap 理论中的数据不一致），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。\n * 最终一致性：强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。\n\n参考：https://javaguide.cn/distributed-system/%e7%90%86%e8%ae%ba&%e7%ae%97%e6%b3%95/cap&base%e7%90%86%e8%ae%ba/#base-%e7%90%86%e8%ae%ba\n\n\n# 分布式事务\n\n\n# 什么是分布式事务？\n\n分布式事务就是为了保证不同数据库的数据一致性 。\n\n\n# 柔性事务和刚性事务\n\n * 柔性事务追求的是最终一致性。柔性事务就是base理论+业务实际。柔性事务追求的目标是：根据自身业务特性，通过适当的方式保证系统数据的最终一致性。像tcc、saga、mq事务、本地消息表都是柔性事务。\n * 刚性事务追求的是强一致性。像2pc、3pc就属于刚性事务。\n\n\n# 分布式事务解决方案\n\n分布式事务的解决方案有很多，比如：2pc、3pc、tcc、本地消息表、mq事务（kafka和rocketmq都提供了事务相关共）、saga等等。 2pc、3pc属于业务代码无侵入方案，都是基于xa规范衍生出来的实现。tcc、saga属于业务侵入方案，mq事务依赖于使用消息队列的场景，本地消息表不支持回滚。\n\n\n# xa 规范的角色组成\n\n2pc 和 3pc 涉及到的一些角色（xa 规范的角色组成）\n\n * ap（application program）：应用程序本身\n * rm（resource manager） ：资源管理器，也就是事务的参与者，绝大部分情况下就是指数据库（后文会以关系型数据库为例），一个分布式事务往往涉及到多个 rm。\n * tm（transaction manager） ：事务管理器，负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等。\n\n\n# 2pc（两阶段提交协议）\n\n2pc（two-phase commit）这三个字母的含义:\n\n * 2 -> 指代事务提交的 2 个阶段\n * p-> prepare (准备阶段)\n * c ->commit（提交阶段）\n\n2pc 将事务的提交过程分为 2 个阶段：\n\n * 准备阶段：主要是为了测试 rm 能否执行 本地数据库事务 操作，并不会提交事务\n * 提交阶段： tm 会根据 准备阶段 中 rm 的消息来决定是执行事务提交还是回滚操作。提交阶段 之后一定会结束当前的分布式事务\n\n\n# 3pc（三阶段提交协议）\n\n3pc 把 2pc 中的 准备阶段(prepare) 做了进一步细化分为了准备阶段(cancommit)和预提交阶段(precommit)。分为三个阶段：\n\n * 准备阶段：这一步不会执行事务操作，只是向 rm 发送 准备请求 ，顺便询问一些信息比如事务参与者能否执行本地数据库事务操作。rm 回复“yes”、“no”或者直接超时。如果任一 rm 回复“no”或者直接超时的话，就中断事务（向所有参与者发送“abort”消息），否则进入 预提交阶段(precommit) 。\n * 预提交阶段：tm 向所有涉及到的 rm 发送 预提交请求 ，rm 收到消息之后会执行本地数据库事务预操作比如写 redo log/undo log 日志。如果 rm 成功的执行了事务预操作，就返回 “ack”。否则，返回“no”（最后的反悔机会）或者直接超时。如果任一 rm 回复“no”或者直接超时的话，就中断事务（向所有事务参与者发送“abort”消息），否则进入 执行事务提交阶段（docommit）\n * 执行事务提交阶段：执行事务提交（docommit） 阶段就开始进行真正的事务提交。tm 向所有涉及到的 rm 发送 执行事务提交请求 ，rm 收到消息后开始正式提交事务，并在完成事务提交后释放占用的资源。 如果 tm 收到所有 rm 正确提交事务的消息的话，表示事务正常完成。如果任一 rm 没有正确提交事务或者超时的话，就中断事务，tm 向所有 rm 发送“abort”消息。rm 接收到 abort 请求后，执行本地数据库事务回滚，后面的步骤就和 2pc 中的类似了。\n\n\n# tcc（补偿事务）\n\ntcc 是 try、confirm、cancel 三个词的缩写，它分为三个阶段：\n\n 1. try（尝试）阶段 : 尝试执行。完成业务检查，并预留好必需的业务资源。\n 2. confirm（确认）阶段 ：确认执行。当所有事务参与者的 try 阶段执行成功就会执行 confirm ，confirm 阶段会处理 try 阶段预留的业务资源。否则，就会执行 cancel 。\n 3. cancel（取消）阶段 ：取消执行，释放 try 阶段预留的业务资源。\n\n每个阶段由业务代码控制，这样可以避免长事务，性能更好。 我们拿转账场景来说：\n\n 1. try（尝试）阶段 : 在转账场景下，try 要做的事情是就是检查账户余额是否充足，预留的资源就是转账资金。\n 2. confirm（确认）阶段 ： 如果 try 阶段执行成功的话，confirm 阶段就会执行真正的扣钱操作。\n 3. cancel（取消）阶段 ：释放 try 阶段预留的转账资金。\n\n一般情况下，当我们使用tcc模式的时候，需要自己实现 try, confirm, cancel 这三个方法，来达到最终一致性。\n\n\n# mq事务\n\nrocketmq 、 kafka、pulsar 、qmq 都提供了事务相关的功能。事务允许事件流应用将消费，处理，生产消息整个过程定义为一个原子操作。\n\n\n# 分布式日志管理\n\n\n# 日志系统需要做哪些事情\n\n 1. 采集日志\n 2. 日志数据清洗/处理\n 3. 存储：比如 elasticsearch存储\n 4. 展示与搜索：支持可视化日志展示，能够根据关键词快速定位到日志并查看上下文。\n 5. 告警：支持对接常见的监控系统\n\n\n# 项目中怎么管理日志的\n\n项目中使用 loki 管理日志的，相对于elk来说，loki更为轻量级，资源成本更低，并且简单易用。",charsets:{cjk:!0},lastUpdated:"2023/11/02, 03:14:56",lastUpdatedTimestamp:1698894896e3},{title:"Nginx 面试题",frontmatter:{title:"Nginx 面试题",date:"2023-10-24T15:51:01.000Z",permalink:"/pages/d4abbd/"},regularPath:"/02.Java%20%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/02.Java%20%E5%85%AB%E8%82%A1%E6%96%87/14.Nginx%20%E9%9D%A2%E8%AF%95%E9%A2%98.html",relativePath:"02.Java 面试宝典/02.Java 八股文/14.Nginx 面试题.md",key:"v-9e602488",path:"/pages/d4abbd/",headers:[{level:1,title:"什么是Nginx",slug:"什么是nginx",normalizedTitle:"什么是nginx",charIndex:2},{level:1,title:"Nginx 的特点有哪些",slug:"nginx-的特点有哪些",normalizedTitle:"nginx 的特点有哪些",charIndex:136},{level:1,title:"Nginx能用来做啥",slug:"nginx能用来做啥",normalizedTitle:"nginx能用来做啥",charIndex:441},{level:1,title:"Nginx 有哪些负载均衡策略",slug:"nginx-有哪些负载均衡策略",normalizedTitle:"nginx 有哪些负载均衡策略",charIndex:492},{level:1,title:"Nginx 常用命令有哪些",slug:"nginx-常用命令有哪些",normalizedTitle:"nginx 常用命令有哪些",charIndex:818},{level:1,title:"Nginx性能优化的常见方式",slug:"nginx性能优化的常见方式",normalizedTitle:"nginx性能优化的常见方式",charIndex:1080}],headersStr:"什么是Nginx Nginx 的特点有哪些 Nginx能用来做啥 Nginx 有哪些负载均衡策略 Nginx 常用命令有哪些 Nginx性能优化的常见方式",content:"# 什么是Nginx\n\nNginx 同 Apache 一样都是 WEB 服务器，不过，Nginx 更加轻量级，它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。并且，Nginx 可以作为反向代理服务器使用，支持 IMAP/POP3/SMTP 服务。\n\n\n# Nginx 的特点有哪些\n\n 1. 内存占用非常少 ：一般情况下，10000 个非活跃的 HTTP Keep-Alive 连接在 Nginx 中仅消耗 2.5MB 的内存，这是 Nginx 支持高并发连接的基础。\n 2. 高并发 : 单机支持 10 万以上的并发连接\n 3. 跨平台 :可以运行在 Linux，Windows，FreeBSD，Solaris，AIX，Mac OS 等操作系统上。\n 4. 扩展性好 ：第三方插件非常多！\n 5. 安装使用简单 ：对于简单的应用场景，我们很快就能够上手使用。\n 6. 稳定性好 ：bug 少，不会遇到各种奇葩的问题。\n 7. 免费 ：开源软件，免费使用。\n\n\n# Nginx能用来做啥\n\n * 静态资源服务器\n * 反向代理\n * 正向代理\n * 负载均衡\n\n\n# Nginx 有哪些负载均衡策略\n\nNginx常见的负载均衡策略有：\n\n * 轮询（Round Robin，默认）：如果没有配置权重的话，每个请求按时间顺序逐一分配到不同的服务器处理。如果配置权重的话，权重越高的服务器被访问的概率就越大。\n * IP 哈希：根据发出请求的和客户端 ip 的 hash 值来分配服务器，可以保证同 IP 发出的请求映射到同一服务器，或者具有相同 hash 值的不同 IP 映射到同一服务器。该算法在一定程度上解决了集群部署环境下 Session 不共享的问题。\n * 最小连接数：当有新的请求出现时，遍历服务器节点列表并选取其中活动连接数最小的一台服务器来响应当前请求。活动连接数可以理解为当前正在处理的请求数。\n\n\n# Nginx 常用命令有哪些\n\n * 启动 nginx 。\n * 停止 nginx -s stop 或 nginx -s quit 。\n * 重载配置 ./sbin/nginx -s reload(平滑重启) 或 service nginx reload 。\n * 重载指定配置文件 .nginx -c /usr/local/nginx/conf/nginx.conf 。\n * 查看 nginx 版本 nginx -v 。\n * 检查配置文件是否正确 nginx -t 。\n * 显示帮助信息 nginx -h 。\n\n\n# Nginx性能优化的常见方式\n\n * 设置 Nginx 运行工作进程个数 ：一般设置 CPU 的核心数或者核心数 x2；\n * 开启 Gzip 压缩 ：这样可以使网站的图片、CSS、JS 等文件在传输时进行压缩，提高访问速度, 优化 Nginx 性能。详细介绍可以参考Nginx 性能优化功能- Gzip 压缩(大幅度提高页面加载速度)这篇文章；\n * 设置单个 worker 进程允许客户端最大连接数 ：一般设置为 65535 就足够了；\n * 连接超时时间设置 ：避免在建立无用连接上消耗太多资源；\n * 设置缓存 ：像图片、CSS、JS 等这类一般不会经常修改的文件，我们完全可以设置图片在浏览器本地缓存，提高访问速度，优化 Nginx 性能。",normalizedContent:"# 什么是nginx\n\nnginx 同 apache 一样都是 web 服务器，不过，nginx 更加轻量级，它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。并且，nginx 可以作为反向代理服务器使用，支持 imap/pop3/smtp 服务。\n\n\n# nginx 的特点有哪些\n\n 1. 内存占用非常少 ：一般情况下，10000 个非活跃的 http keep-alive 连接在 nginx 中仅消耗 2.5mb 的内存，这是 nginx 支持高并发连接的基础。\n 2. 高并发 : 单机支持 10 万以上的并发连接\n 3. 跨平台 :可以运行在 linux，windows，freebsd，solaris，aix，mac os 等操作系统上。\n 4. 扩展性好 ：第三方插件非常多！\n 5. 安装使用简单 ：对于简单的应用场景，我们很快就能够上手使用。\n 6. 稳定性好 ：bug 少，不会遇到各种奇葩的问题。\n 7. 免费 ：开源软件，免费使用。\n\n\n# nginx能用来做啥\n\n * 静态资源服务器\n * 反向代理\n * 正向代理\n * 负载均衡\n\n\n# nginx 有哪些负载均衡策略\n\nnginx常见的负载均衡策略有：\n\n * 轮询（round robin，默认）：如果没有配置权重的话，每个请求按时间顺序逐一分配到不同的服务器处理。如果配置权重的话，权重越高的服务器被访问的概率就越大。\n * ip 哈希：根据发出请求的和客户端 ip 的 hash 值来分配服务器，可以保证同 ip 发出的请求映射到同一服务器，或者具有相同 hash 值的不同 ip 映射到同一服务器。该算法在一定程度上解决了集群部署环境下 session 不共享的问题。\n * 最小连接数：当有新的请求出现时，遍历服务器节点列表并选取其中活动连接数最小的一台服务器来响应当前请求。活动连接数可以理解为当前正在处理的请求数。\n\n\n# nginx 常用命令有哪些\n\n * 启动 nginx 。\n * 停止 nginx -s stop 或 nginx -s quit 。\n * 重载配置 ./sbin/nginx -s reload(平滑重启) 或 service nginx reload 。\n * 重载指定配置文件 .nginx -c /usr/local/nginx/conf/nginx.conf 。\n * 查看 nginx 版本 nginx -v 。\n * 检查配置文件是否正确 nginx -t 。\n * 显示帮助信息 nginx -h 。\n\n\n# nginx性能优化的常见方式\n\n * 设置 nginx 运行工作进程个数 ：一般设置 cpu 的核心数或者核心数 x2；\n * 开启 gzip 压缩 ：这样可以使网站的图片、css、js 等文件在传输时进行压缩，提高访问速度, 优化 nginx 性能。详细介绍可以参考nginx 性能优化功能- gzip 压缩(大幅度提高页面加载速度)这篇文章；\n * 设置单个 worker 进程允许客户端最大连接数 ：一般设置为 65535 就足够了；\n * 连接超时时间设置 ：避免在建立无用连接上消耗太多资源；\n * 设置缓存 ：像图片、css、js 等这类一般不会经常修改的文件，我们完全可以设置图片在浏览器本地缓存，提高访问速度，优化 nginx 性能。",charsets:{cjk:!0},lastUpdated:"2023/11/02, 03:14:56",lastUpdatedTimestamp:1698894896e3},{title:"思考框架",frontmatter:{title:"思考框架",date:"2023-10-25T14:10:59.000Z",permalink:"/pages/1eb629/"},regularPath:"/03.%E8%BD%AF%E6%8A%80%E8%83%BD/01.%E6%96%B9%E6%B3%95%E8%AE%BA/01.%E6%80%9D%E8%80%83%E6%A1%86%E6%9E%B6.html",relativePath:"03.软技能/01.方法论/01.思考框架.md",key:"v-48671418",path:"/pages/1eb629/",headers:[{level:1,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1112}],headersStr:"参考资料",content:"STAR\n\n情景（Situation）=> 任务（Task）=> 行动（Action）=> 结果（Result）。 在什么情景下产生了什么任务做了什么事完成了什么结果。简明扼要地阐述工作贡献。可用于面试、工作汇报、转正或晋升答辩。\n\nSWOT\n\n优势（Strengths）、劣势（Weakness）、机会（Opportunities）、威胁（Threats） 。用于个体或企业的竞争力分析和定位行动方向。\n\n * SO：利用自身已有优势，借助外部环境发力，形成杠杆效应。增长型策略。比如研发能力强，逢信息化浪潮正酣，可进一步专业深化，打造特定方向的深化专业和行业能力。\n * ST：转移优势，转型或多元化发展，规避威胁。转型或多元化策略。比如开发能力强，但所处行业进入衰退期，则需要转行，在其它行业发挥优势。\n * WO：抓住机会，弥补短板。扭转型策略。比如沟通能力较弱，但给予了团队管理机会，则可借势锻炼沟通与管理能力。\n * WT：在减少内部劣势的的同时还需要回避外部环境威胁，不去正面应对威胁。防御型策略。比如身体较弱，又逢疫情，宜加强运动，提升身体和心理免疫力\n\nKISS\n\n保持（Keep）、提升（Improve）、开始 （Start）、停止（Stop）。哪些做得好要保持，哪些做得不够好要提升，哪些很重要却没起色需要有个开始，哪些是很不好的习惯需要停止。 常用于持续行动力规划。\n\n * Keep：阅读（原理/艺术类书籍）、认真工作、热爱生活；\n * Improve：沟通、艺术感受力；\n * Start：运动、团队管理\n * Stop：熬夜刷手机\n\nKISS 是行动力方向，需要具体详细的行动计划来支撑，更需要有节有序的执行来实现哦\n\nSMART\n\n具体确定的（Specific）、Measurable（可测）、Attainable（可达成）、Relevant（适宜的有价值的）、Time-based（有时限的）。制定目标和任务的基本准则。目标和任务的意义/时限/范围/方向/量化且可实现。\n\n3W\n\nWhat 是什么， How 如何做， Why 为什么。 可用于理解知识，转化技能。\n\n5Why\n\n连续追问五次为什么。用于定位深层原因，从根本上解决问题。\n\nPDCA\n\nPlan-DO-Check-Action。“计划-执行-检查-纠正”循环。可用于项目任务实施和审查、业务与任务管理。\n\nOKRA\n\n目标（Objective)、关键结果(Key Result)、行动(Action)。目标、事项、产出。可用于工作规划和回顾。\n\n金字塔法则\n\n先说进展和结论，再陈述依据和细节。用于清晰表达和汇报。\n\n\n# 参考资料\n\n * 让工作事半功倍的常用思考框架及关于方法论的思考 - 琴水玉 - 博客园",normalizedContent:"star\n\n情景（situation）=> 任务（task）=> 行动（action）=> 结果（result）。 在什么情景下产生了什么任务做了什么事完成了什么结果。简明扼要地阐述工作贡献。可用于面试、工作汇报、转正或晋升答辩。\n\nswot\n\n优势（strengths）、劣势（weakness）、机会（opportunities）、威胁（threats） 。用于个体或企业的竞争力分析和定位行动方向。\n\n * so：利用自身已有优势，借助外部环境发力，形成杠杆效应。增长型策略。比如研发能力强，逢信息化浪潮正酣，可进一步专业深化，打造特定方向的深化专业和行业能力。\n * st：转移优势，转型或多元化发展，规避威胁。转型或多元化策略。比如开发能力强，但所处行业进入衰退期，则需要转行，在其它行业发挥优势。\n * wo：抓住机会，弥补短板。扭转型策略。比如沟通能力较弱，但给予了团队管理机会，则可借势锻炼沟通与管理能力。\n * wt：在减少内部劣势的的同时还需要回避外部环境威胁，不去正面应对威胁。防御型策略。比如身体较弱，又逢疫情，宜加强运动，提升身体和心理免疫力\n\nkiss\n\n保持（keep）、提升（improve）、开始 （start）、停止（stop）。哪些做得好要保持，哪些做得不够好要提升，哪些很重要却没起色需要有个开始，哪些是很不好的习惯需要停止。 常用于持续行动力规划。\n\n * keep：阅读（原理/艺术类书籍）、认真工作、热爱生活；\n * improve：沟通、艺术感受力；\n * start：运动、团队管理\n * stop：熬夜刷手机\n\nkiss 是行动力方向，需要具体详细的行动计划来支撑，更需要有节有序的执行来实现哦\n\nsmart\n\n具体确定的（specific）、measurable（可测）、attainable（可达成）、relevant（适宜的有价值的）、time-based（有时限的）。制定目标和任务的基本准则。目标和任务的意义/时限/范围/方向/量化且可实现。\n\n3w\n\nwhat 是什么， how 如何做， why 为什么。 可用于理解知识，转化技能。\n\n5why\n\n连续追问五次为什么。用于定位深层原因，从根本上解决问题。\n\npdca\n\nplan-do-check-action。“计划-执行-检查-纠正”循环。可用于项目任务实施和审查、业务与任务管理。\n\nokra\n\n目标（objective)、关键结果(key result)、行动(action)。目标、事项、产出。可用于工作规划和回顾。\n\n金字塔法则\n\n先说进展和结论，再陈述依据和细节。用于清晰表达和汇报。\n\n\n# 参考资料\n\n * 让工作事半功倍的常用思考框架及关于方法论的思考 - 琴水玉 - 博客园",charsets:{cjk:!0},lastUpdated:"2023/10/26, 06:15:28",lastUpdatedTimestamp:1698300928e3},{title:"时间管理GTD",frontmatter:{title:"时间管理GTD",date:"2023-10-26T10:35:53.000Z",permalink:"/pages/6fff61/"},regularPath:"/03.%E8%BD%AF%E6%8A%80%E8%83%BD/01.%E6%96%B9%E6%B3%95%E8%AE%BA/02.%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86GTD.html",relativePath:"03.软技能/01.方法论/02.时间管理GTD.md",key:"v-c049eb16",path:"/pages/6fff61/",headers:[{level:1,title:"明晰的处理流程",slug:"明晰的处理流程",normalizedTitle:"明晰的处理流程",charIndex:481},{level:2,title:"参考资料的意义和标准",slug:"参考资料的意义和标准",normalizedTitle:"参考资料的意义和标准",charIndex:763},{level:1,title:"回顾的关键",slug:"回顾的关键",normalizedTitle:"回顾的关键",charIndex:946},{level:1,title:"执行清单的处理",slug:"执行清单的处理",normalizedTitle:"执行清单的处理",charIndex:1183},{level:1,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:453}],headersStr:"明晰的处理流程 参考资料的意义和标准 回顾的关键 执行清单的处理 参考资料",content:"时间管理的真正目的不是时间，也不是事，而是完成。\n\nGTD 与其说是时间管理的方法，不如说是对事务的管理，通过分类事务明确下一步要执行的事务。\n\nGTD 目的：\n\n * 大脑清空不混乱\n * 明确知道下一步应该做什么\n\nGTD 具体流程：\n\n * 捕获（Capture）：捕获所有事情装进收集箱（Inbox）\n * 明晰（Clarify）：就是通过特定的处理流程对事情进行分区。\n * 组织（Organize）：将事情进行分区放置\n * 回顾（Reflect）：回顾你的清单是否有错漏以及安排是否科学\n * 执行（Engage）：根据制定好的安排去做，执行关注的是结果而不是仅仅去做。\n\nGTD 组织分区：\n\n * 执行清单\n * 等待清单：针对等待清单，不止要写下等待事项，还要明确等待的下一步是什么，主动拿结果\n * 项目清单：针对项目清单，问自己下一步是什么，并把下一步放进执行清单；如果步骤复杂，你的下一步就是专门写计划、做方案，然后再下一步应该做什么，就你的计划或方案中；\n * 可能清单\n * 参考资料\n * 回收箱\n * 日历/相关应用。\n\n\n# 明晰的处理流程\n\n处理流程（5个问题）：\n\n 1. **这件事可行动吗？**可以行动进入下一步，不可行动进行分区\n    * 参考资料：今后要查阅的参考资料\n    * 可能清单：今后可能要做的事情\n    * 回收箱：不用做的事情\n 2. 这件事可以一步搞定吗？需要分步骤执行，为它制作一个执行方案，分区到项目清单\n 3. **这件事能在2分钟内搞定吗？**能，就立即做\n 4. 这件事该我做吗？可以分配给其他人，但你需要跟进，分区到等待清单。\n 5. 这件事有特定的时间吗？有特定时间，放进日历/日程应用。没有特定时间，放入执行清单并安排时间执行\n\n\n\n\n# 参考资料的意义和标准\n\n参考资料可以是网络搜索引擎+个人知识库的集合\n\n如何准备参考资料：\n\n * 回归常识，避免追新、奇、怪，而忽略最基本的万物运作规律\n * 提高信息的检索、辨别能力\n * 提高参考资料的存档标准\n   * 搜索引擎能够找到的，对你来说浅显而平常的知识，不用专门存档\n   * 一些出现的新概念，但旧瓶装新酒、换汤不换药的，不用专门存档\n\n\n# 回顾的关键\n\n * 从收集箱出去的项目永远不要再放回收集箱\n * 项目清单中事项需要拆解，制定执行方案并分解到其他清单中\n * 要特别保障等待清单、可能清单、回收箱三个分区当中的回顾，主动确定等待清单是否被完成、回收箱和可能清单中的事项是否有变动（变成可执行或其他）\n * 日历或提醒事项应用中的提醒是否恰当，比如下个月末要完成论文是 Deadline，但是否应该这个月就提醒自己，并且分解开来？\n * 为第四步（回顾）腾出专门的时间，比如每天、每三天或每周、每月\n\n\n# 执行清单的处理\n\n我们基于两个原则对执行清单中的事情进行排序：一是，你不可能完成所有的事情；二是尽可能做距离你目标更近的事情。\n\n在这种情况下，我们仍然要注意四点**。第一，能被放进执行清单的，都是对你来说可以一步搞定的事情；第二，做计划、做方案是每个人的必修课；第三，为每件事情做好时间预估；第四，为特别事件预留时间。**\n\n为了处理执行清单的质量和效率，我们可以有至少三种方法：一是，一次只处理一件事情；二是利用番茄时钟让自己更专注；三是打破负罪感幻觉。\n\n\n# 参考资料\n\n * GTD_百度百科\n * GTD 自我管理、时间管理教程【全 10 集】 | 远离瞎忙迷茫懒癌拖延症 | 从零开始，科学地认识和使用 GTD 时间管理法则。_哔哩哔哩_bilibili",normalizedContent:"时间管理的真正目的不是时间，也不是事，而是完成。\n\ngtd 与其说是时间管理的方法，不如说是对事务的管理，通过分类事务明确下一步要执行的事务。\n\ngtd 目的：\n\n * 大脑清空不混乱\n * 明确知道下一步应该做什么\n\ngtd 具体流程：\n\n * 捕获（capture）：捕获所有事情装进收集箱（inbox）\n * 明晰（clarify）：就是通过特定的处理流程对事情进行分区。\n * 组织（organize）：将事情进行分区放置\n * 回顾（reflect）：回顾你的清单是否有错漏以及安排是否科学\n * 执行（engage）：根据制定好的安排去做，执行关注的是结果而不是仅仅去做。\n\ngtd 组织分区：\n\n * 执行清单\n * 等待清单：针对等待清单，不止要写下等待事项，还要明确等待的下一步是什么，主动拿结果\n * 项目清单：针对项目清单，问自己下一步是什么，并把下一步放进执行清单；如果步骤复杂，你的下一步就是专门写计划、做方案，然后再下一步应该做什么，就你的计划或方案中；\n * 可能清单\n * 参考资料\n * 回收箱\n * 日历/相关应用。\n\n\n# 明晰的处理流程\n\n处理流程（5个问题）：\n\n 1. **这件事可行动吗？**可以行动进入下一步，不可行动进行分区\n    * 参考资料：今后要查阅的参考资料\n    * 可能清单：今后可能要做的事情\n    * 回收箱：不用做的事情\n 2. 这件事可以一步搞定吗？需要分步骤执行，为它制作一个执行方案，分区到项目清单\n 3. **这件事能在2分钟内搞定吗？**能，就立即做\n 4. 这件事该我做吗？可以分配给其他人，但你需要跟进，分区到等待清单。\n 5. 这件事有特定的时间吗？有特定时间，放进日历/日程应用。没有特定时间，放入执行清单并安排时间执行\n\n\n\n\n# 参考资料的意义和标准\n\n参考资料可以是网络搜索引擎+个人知识库的集合\n\n如何准备参考资料：\n\n * 回归常识，避免追新、奇、怪，而忽略最基本的万物运作规律\n * 提高信息的检索、辨别能力\n * 提高参考资料的存档标准\n   * 搜索引擎能够找到的，对你来说浅显而平常的知识，不用专门存档\n   * 一些出现的新概念，但旧瓶装新酒、换汤不换药的，不用专门存档\n\n\n# 回顾的关键\n\n * 从收集箱出去的项目永远不要再放回收集箱\n * 项目清单中事项需要拆解，制定执行方案并分解到其他清单中\n * 要特别保障等待清单、可能清单、回收箱三个分区当中的回顾，主动确定等待清单是否被完成、回收箱和可能清单中的事项是否有变动（变成可执行或其他）\n * 日历或提醒事项应用中的提醒是否恰当，比如下个月末要完成论文是 deadline，但是否应该这个月就提醒自己，并且分解开来？\n * 为第四步（回顾）腾出专门的时间，比如每天、每三天或每周、每月\n\n\n# 执行清单的处理\n\n我们基于两个原则对执行清单中的事情进行排序：一是，你不可能完成所有的事情；二是尽可能做距离你目标更近的事情。\n\n在这种情况下，我们仍然要注意四点**。第一，能被放进执行清单的，都是对你来说可以一步搞定的事情；第二，做计划、做方案是每个人的必修课；第三，为每件事情做好时间预估；第四，为特别事件预留时间。**\n\n为了处理执行清单的质量和效率，我们可以有至少三种方法：一是，一次只处理一件事情；二是利用番茄时钟让自己更专注；三是打破负罪感幻觉。\n\n\n# 参考资料\n\n * gtd_百度百科\n * gtd 自我管理、时间管理教程【全 10 集】 | 远离瞎忙迷茫懒癌拖延症 | 从零开始，科学地认识和使用 gtd 时间管理法则。_哔哩哔哩_bilibili",charsets:{cjk:!0},lastUpdated:"2023/10/26, 16:07:22",lastUpdatedTimestamp:1698336442e3},{title:"搭建个人知识库",frontmatter:{title:"搭建个人知识库",date:"2023-11-01T13:36:52.000Z",permalink:"/pages/15a2bc/"},regularPath:"/03.%E8%BD%AF%E6%8A%80%E8%83%BD/02.%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/01.%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93.html",relativePath:"03.软技能/02.知识管理/01.搭建个人知识库.md",key:"v-1f3e78d6",path:"/pages/15a2bc/",headers:[{level:1,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:117}],headersStr:"参考资料",content:"个人知识库是持续支撑职业生涯的重要基础，最终目标是为工作、生活和创作提供持续动力，解决实际问题。\n\n知识库建设，基本步骤包括：搜集、归类、整理和提纯。其中知识提纯是核心。\n\n知识库需要达到工作所需触手可达，避免重复搜索。\n\n\n\n\n# 参考资料\n\n * 打造适合自己的知识库 - 琴水玉 - 博客园\n * 编程知识提纯之法 - 琴水玉 - 博客园\n * 如何做编程知识投资及减少知识失效的影响 - 琴水玉 - 博客园",normalizedContent:"个人知识库是持续支撑职业生涯的重要基础，最终目标是为工作、生活和创作提供持续动力，解决实际问题。\n\n知识库建设，基本步骤包括：搜集、归类、整理和提纯。其中知识提纯是核心。\n\n知识库需要达到工作所需触手可达，避免重复搜索。\n\n\n\n\n# 参考资料\n\n * 打造适合自己的知识库 - 琴水玉 - 博客园\n * 编程知识提纯之法 - 琴水玉 - 博客园\n * 如何做编程知识投资及减少知识失效的影响 - 琴水玉 - 博客园",charsets:{cjk:!0},lastUpdated:"2023/11/01, 06:52:24",lastUpdatedTimestamp:1698821544e3},{title:"如何高效的学习技术",frontmatter:{title:"如何高效的学习技术",date:"2023-11-01T14:46:36.000Z",permalink:"/pages/11d0b0/"},regularPath:"/03.%E8%BD%AF%E6%8A%80%E8%83%BD/02.%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/03.%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF.html",relativePath:"03.软技能/02.知识管理/03.如何高效的学习技术.md",key:"v-43b3065b",path:"/pages/11d0b0/",headers:[{level:3,title:"学什么",slug:"学什么",normalizedTitle:"学什么",charIndex:3},{level:4,title:"基础与应用",slug:"基础与应用",normalizedTitle:"基础与应用",charIndex:12},{level:4,title:"广度与深度",slug:"广度与深度",normalizedTitle:"广度与深度",charIndex:23},{level:4,title:"哲学",slug:"哲学",normalizedTitle:"哲学",charIndex:34},{level:4,title:"英语",slug:"英语",normalizedTitle:"英语",charIndex:42},{level:3,title:"怎么学",slug:"怎么学",normalizedTitle:"怎么学",charIndex:48},{level:4,title:"知识体系",slug:"知识体系",normalizedTitle:"知识体系",charIndex:57},{level:4,title:"克服遗忘",slug:"克服遗忘",normalizedTitle:"克服遗忘",charIndex:67},{level:4,title:"碎片时间",slug:"碎片时间",normalizedTitle:"碎片时间",charIndex:77},{level:3,title:"用起来",slug:"用起来",normalizedTitle:"用起来",charIndex:85},{level:3,title:"技术分享",slug:"技术分享",normalizedTitle:"技术分享",charIndex:94},{level:3,title:"造个轮子",slug:"造个轮子",normalizedTitle:"造个轮子",charIndex:104}],headersStr:"学什么 基础与应用 广度与深度 哲学 英语 怎么学 知识体系 克服遗忘 碎片时间 用起来 技术分享 造个轮子",content:' * 学什么\n   * 基础与应用\n   * 广度与深度\n   * 哲学\n   * 英语\n * 怎么学\n   * 知识体系\n   * 克服遗忘\n   * 碎片时间\n * 用起来\n   * 技术分享\n   * 造个轮子\n\n我们相信努力学习一定会有收获，但是方法不当，既让人身心疲惫，也没有切实的回报。高中时代，我的同桌是个漂亮女同学。她的物理成绩很差，虽然她非常勤奋的学习，但成绩总是不理想。为了巩固纯洁的同学关系，我亲密无间地辅导她的物理，发现她不知道题目考什么。我们的教科书与试题都围绕着考试大纲展开，看到一道题，应该先想想它在考哪些定理和公式的运用。\n  不少朋友每天都阅读技术文章，但是第二天就忘干净了。工作中领导和同事都认可你的沟通和技术能力，但是跳槽面试却屡屡碰壁。面试官问技术方案，明明心里清楚，用嘴说出来却前言不搭后语。面试官再问底层算法，你说看过但是忘记了。他不在乎你看没看过，答不上就是零分。正如男女相亲，男方谈吐潇洒才能吸引姑娘。可是男方紧张了，平时挺能说，关键时候却支支吾吾，姑娘必然认为他不行。人生充满了许多考试，有形的和无形的，每次考试的机会只有一次。\n  工作五年十年后，别人成了架构师，自己还在基层打滚，原因是什么？职场上无法成功升迁的原因有很多，没有持续学习、学习效果不好、无法通过心仪公司的的面试，一定是很重要的原因。\n  把自己当成一台计算机，既有输入，也要有输出，用输出倒逼输入。\n\n\n# 学什么\n\n# 基础与应用\n\n近些年诞生了许多新技术，比如最时髦的AI(目前还在智障阶段)，数学基础是初中就接触过的概率统计。万丈高楼从地起，不要被新工具或者中间件迷住双眼，一味地追新求快。基础知识是所有技术的基石，在未来很长的时间都不会变化，应该花费足够的时间巩固基础。\n  以数据结构和算法为例，大家阅读一下Java的BitSet的源码，里面有大量的移位操作，移位运算掌握的好，看这份源码就没问题。Java同步工具类AQS用到了双向链表，链表知识不过关，肯定搞不懂它的原理。互联网大厂都喜欢考算法，为了通过面试也要精通算法。\n  以Java工程师应该掌握的知识为例，按重要程度排出六个梯度：\n\n * 第一梯度：计算机组成原理、数据结构和算法、网络通信原理、操作系统原理；\n * 第二梯度：Java基础、JVM内存模型和GC算法、JVM性能调优、JDK工具、设计模式；\n * 第三梯度：Spring系列、Mybatis、Dubbo等主流框架的运用和原理；\n * 第四梯度：MySQL(含SQL编程)、Redis、RabbitMQ/RocketMQ/Kafka、ZooKeeper等数据库或者中间件的运用和原理；\n * 第五梯度：CAP理论、BASE理论、Paxos和Raft算法等其他分布式理论；\n * 第六梯度：容器化、大数据、AI、区块链等等前沿技术理论；\n\n有同学认为第五梯度应该在移到第一梯度。其实很多小公司的日活犹如古天乐一样平平无奇，离大型分布式架构还远得很。学习框架和中间件的时候，顺手掌握分布式理论，效果更好。\n\n# 广度与深度\n\n许多公司的招聘JD没有设定技术人员年龄门槛，但是会加上一句“具备与年龄相当的知识的广度与深度”。多广才算广，多深才算深？这是很主观的话题，这里不展开讨论。\n  如何变得更广更深呢？突破收入上升的瓶颈，发掘自己真正的兴趣。\n  大多数人只是公司的普通职员，收入上升的瓶颈就是升职加薪。许多IT公司会对技术人员有个评级，如果你的评级不高，那就依照晋级章程努力升级。如果你在一个小公司，收入一般，发展前景不明，准备大厂的面试就是最好的学习过程。在这些过程中，你必然学习更多知识，变得更广更深。\n  个人兴趣是前进的动力之一，许多知名开源项目都源于作者的兴趣。个人兴趣并不局限技术领域，可以是其他学科。我有个朋友喜欢玩山地自行车，还给一些做自行车话题的自媒体投稿。久而久之，居然能够写一手好文章了，我相信他也能写好技术文档。\n\n# 哲学\n\n哲学不是故作高深的学科，它的现实意义就是解决问题。年轻小伙是怎么泡妞的？三天两头花不断，大庭广众跪求爱。这类套路为什么总是能成功呢？礼物满足女人的物欲，当众求爱满足女人的虚荣心，投其所好。食堂大妈打菜的手越来越抖，辣子鸡丁变成辣子辣丁，为什么呢？食堂要控制成本，直接提价会惹众怒。\n  科学上的哲学，一般指研究事物发展的规律，归纳终极的解决方案。软件行业充满哲学味道的作品非常多，比如《人月神话》。举个例子，当软件系统遇到性能问题，尝试下面两种哲学思想提升性能：\n\n * 空间换时间：比如引入缓存，消耗额外的存储提高响应速度。\n * 时间换空间：比如大文件的分片处理，分段处理后再汇总结果。\n\n设计稳健高可用的系统，尝试从三个方面考虑问题：\n\n * 存储：数据会丢失吗，数据一致性怎么解决。\n * 计算：计算怎么扩容，应用允许任意增加节点吗。\n * 传输：网络中断或拥塞怎么办。\n\n从无数的失败或者成功的经验中，总结出高度概括性的方案，让我们下一步做的更好。\n\n# 英语\n\n英语是重要的基础，学好英语与掌握编程一样重要。许多知名博客就是把英文翻译成中文，只是知识的搬运工。如果英语足够好，直接阅读一手资料，避免他人翻译存在的谬误。\n\n如果纯粹为了日常技术工作，可以不练习英语口语，提高文档阅读能力即可。首先，要突破单词关，至少达到六级的5500个词汇量。其次，必须掌握专业英语的词汇，推荐采用机械工业出版社的《计算机专业英语》这本书。最后，坚持阅读一份有质量的技术文档，做到可以用英语表达技术意图，Spring的技术文档就是很好的学习材料。如果到处去搜罗各种英语文献，往往只收藏不阅读。\n\n\n# 怎么学\n\n# 知识体系\n\n体系化的知识比零散的更容易记忆和理解，这正如一部好的电视剧，剧情环环相扣才能吸引观众。建议大家使用思维导图罗列知识点，构建体系结构，如下图所示：\n\n\n\n# 克服遗忘\n\n高中是我们知识的巅峰时刻，每周小考每月大考，教辅资料堆成山，地狱式的反复操练强化记忆。复习是对抗遗忘的唯一办法。大脑的遗忘是有规律的，先快后慢。一天后，学到的知识只剩下原来的25%，甚至更低。随着时间的推移，遗忘的速度减慢，遗忘的数量也就减少。\n\n时间间隔    记忆量\n刚看完     100%\n20分钟后   60%\n1小时后    40%\n1天后     30%\n2天后     27%\n\n每个人的遗忘程度都不一样，建议第二天复习前一天的内容，七天后复习这段时间的所有内容。\n\n# 碎片时间\n\n不少朋友利用碎片时间学习，比如在公交上看公众号的推送。其实我们都高估了自己的抗干扰能力，如果处在嘈杂的环境，注意力容易被打断，记忆留存度也很低。碎片时间适合学习简单孤立的知识点，比如链表的定义与实现。\n  学习复杂的知识，需要大段的连续时间。图书馆是个好地方，安静氛围好。手机放一边，不要理会QQ微信，最好阅读纸质书，泡上一整天。有些城市出现了付费自习室，提供格子间、茶水等等，也是非常好的选择。\n\n\n# 用起来\n\n\n# 技术分享\n\n从下面这张图我们可以看到，教授他人是知识留存率最高的方式。\n\n\n准备PPT和演讲内容，给同事来一场技术分享。不光复习知识，还锻炼口才。曾经有个同事说话又快又急，口头禅也多，比如"对吧、是不是”，别人经常听不清，但是他本人不以为然。领导让他做了几次技术分享，听众的反应可想而知，他才彻底认清缺点。\n  坚持写技术博客，别在意你写的东西在网上已经重复千百遍。当自己动手的时候，才会意识到眼高手低。让文章读起来流畅清晰，需要呕心沥血的删改。写作是对大脑的长期考验，想不到肯定写不出，想不清楚肯定写不清楚。\n\n\n# 造个轮子\n\n我们经常说不要重复造轮子。为了开发效率，可以不造轮子，但是必须具备造轮子的能力。优秀开源项目的作者通常具备极高的工程能力，从工程的实际需求出发，用代码实现一个通用的解决方案。造轮子的目的，首先是巩固编程知识，其次是锤炼工程能力。\n\n建议造一个简单的MQ，会用到通信协议、设计模式、队列等许多知识。在造轮子的过程中，又要翻阅大量的技术资料或者博客，这就是用输出倒逼输入。\n\n本文转自 https://www.cnblogs.com/xiaoyangjia/p/11535486.html，如有侵权，请联系删除。',normalizedContent:' * 学什么\n   * 基础与应用\n   * 广度与深度\n   * 哲学\n   * 英语\n * 怎么学\n   * 知识体系\n   * 克服遗忘\n   * 碎片时间\n * 用起来\n   * 技术分享\n   * 造个轮子\n\n我们相信努力学习一定会有收获，但是方法不当，既让人身心疲惫，也没有切实的回报。高中时代，我的同桌是个漂亮女同学。她的物理成绩很差，虽然她非常勤奋的学习，但成绩总是不理想。为了巩固纯洁的同学关系，我亲密无间地辅导她的物理，发现她不知道题目考什么。我们的教科书与试题都围绕着考试大纲展开，看到一道题，应该先想想它在考哪些定理和公式的运用。\n  不少朋友每天都阅读技术文章，但是第二天就忘干净了。工作中领导和同事都认可你的沟通和技术能力，但是跳槽面试却屡屡碰壁。面试官问技术方案，明明心里清楚，用嘴说出来却前言不搭后语。面试官再问底层算法，你说看过但是忘记了。他不在乎你看没看过，答不上就是零分。正如男女相亲，男方谈吐潇洒才能吸引姑娘。可是男方紧张了，平时挺能说，关键时候却支支吾吾，姑娘必然认为他不行。人生充满了许多考试，有形的和无形的，每次考试的机会只有一次。\n  工作五年十年后，别人成了架构师，自己还在基层打滚，原因是什么？职场上无法成功升迁的原因有很多，没有持续学习、学习效果不好、无法通过心仪公司的的面试，一定是很重要的原因。\n  把自己当成一台计算机，既有输入，也要有输出，用输出倒逼输入。\n\n\n# 学什么\n\n# 基础与应用\n\n近些年诞生了许多新技术，比如最时髦的ai(目前还在智障阶段)，数学基础是初中就接触过的概率统计。万丈高楼从地起，不要被新工具或者中间件迷住双眼，一味地追新求快。基础知识是所有技术的基石，在未来很长的时间都不会变化，应该花费足够的时间巩固基础。\n  以数据结构和算法为例，大家阅读一下java的bitset的源码，里面有大量的移位操作，移位运算掌握的好，看这份源码就没问题。java同步工具类aqs用到了双向链表，链表知识不过关，肯定搞不懂它的原理。互联网大厂都喜欢考算法，为了通过面试也要精通算法。\n  以java工程师应该掌握的知识为例，按重要程度排出六个梯度：\n\n * 第一梯度：计算机组成原理、数据结构和算法、网络通信原理、操作系统原理；\n * 第二梯度：java基础、jvm内存模型和gc算法、jvm性能调优、jdk工具、设计模式；\n * 第三梯度：spring系列、mybatis、dubbo等主流框架的运用和原理；\n * 第四梯度：mysql(含sql编程)、redis、rabbitmq/rocketmq/kafka、zookeeper等数据库或者中间件的运用和原理；\n * 第五梯度：cap理论、base理论、paxos和raft算法等其他分布式理论；\n * 第六梯度：容器化、大数据、ai、区块链等等前沿技术理论；\n\n有同学认为第五梯度应该在移到第一梯度。其实很多小公司的日活犹如古天乐一样平平无奇，离大型分布式架构还远得很。学习框架和中间件的时候，顺手掌握分布式理论，效果更好。\n\n# 广度与深度\n\n许多公司的招聘jd没有设定技术人员年龄门槛，但是会加上一句“具备与年龄相当的知识的广度与深度”。多广才算广，多深才算深？这是很主观的话题，这里不展开讨论。\n  如何变得更广更深呢？突破收入上升的瓶颈，发掘自己真正的兴趣。\n  大多数人只是公司的普通职员，收入上升的瓶颈就是升职加薪。许多it公司会对技术人员有个评级，如果你的评级不高，那就依照晋级章程努力升级。如果你在一个小公司，收入一般，发展前景不明，准备大厂的面试就是最好的学习过程。在这些过程中，你必然学习更多知识，变得更广更深。\n  个人兴趣是前进的动力之一，许多知名开源项目都源于作者的兴趣。个人兴趣并不局限技术领域，可以是其他学科。我有个朋友喜欢玩山地自行车，还给一些做自行车话题的自媒体投稿。久而久之，居然能够写一手好文章了，我相信他也能写好技术文档。\n\n# 哲学\n\n哲学不是故作高深的学科，它的现实意义就是解决问题。年轻小伙是怎么泡妞的？三天两头花不断，大庭广众跪求爱。这类套路为什么总是能成功呢？礼物满足女人的物欲，当众求爱满足女人的虚荣心，投其所好。食堂大妈打菜的手越来越抖，辣子鸡丁变成辣子辣丁，为什么呢？食堂要控制成本，直接提价会惹众怒。\n  科学上的哲学，一般指研究事物发展的规律，归纳终极的解决方案。软件行业充满哲学味道的作品非常多，比如《人月神话》。举个例子，当软件系统遇到性能问题，尝试下面两种哲学思想提升性能：\n\n * 空间换时间：比如引入缓存，消耗额外的存储提高响应速度。\n * 时间换空间：比如大文件的分片处理，分段处理后再汇总结果。\n\n设计稳健高可用的系统，尝试从三个方面考虑问题：\n\n * 存储：数据会丢失吗，数据一致性怎么解决。\n * 计算：计算怎么扩容，应用允许任意增加节点吗。\n * 传输：网络中断或拥塞怎么办。\n\n从无数的失败或者成功的经验中，总结出高度概括性的方案，让我们下一步做的更好。\n\n# 英语\n\n英语是重要的基础，学好英语与掌握编程一样重要。许多知名博客就是把英文翻译成中文，只是知识的搬运工。如果英语足够好，直接阅读一手资料，避免他人翻译存在的谬误。\n\n如果纯粹为了日常技术工作，可以不练习英语口语，提高文档阅读能力即可。首先，要突破单词关，至少达到六级的5500个词汇量。其次，必须掌握专业英语的词汇，推荐采用机械工业出版社的《计算机专业英语》这本书。最后，坚持阅读一份有质量的技术文档，做到可以用英语表达技术意图，spring的技术文档就是很好的学习材料。如果到处去搜罗各种英语文献，往往只收藏不阅读。\n\n\n# 怎么学\n\n# 知识体系\n\n体系化的知识比零散的更容易记忆和理解，这正如一部好的电视剧，剧情环环相扣才能吸引观众。建议大家使用思维导图罗列知识点，构建体系结构，如下图所示：\n\n\n\n# 克服遗忘\n\n高中是我们知识的巅峰时刻，每周小考每月大考，教辅资料堆成山，地狱式的反复操练强化记忆。复习是对抗遗忘的唯一办法。大脑的遗忘是有规律的，先快后慢。一天后，学到的知识只剩下原来的25%，甚至更低。随着时间的推移，遗忘的速度减慢，遗忘的数量也就减少。\n\n时间间隔    记忆量\n刚看完     100%\n20分钟后   60%\n1小时后    40%\n1天后     30%\n2天后     27%\n\n每个人的遗忘程度都不一样，建议第二天复习前一天的内容，七天后复习这段时间的所有内容。\n\n# 碎片时间\n\n不少朋友利用碎片时间学习，比如在公交上看公众号的推送。其实我们都高估了自己的抗干扰能力，如果处在嘈杂的环境，注意力容易被打断，记忆留存度也很低。碎片时间适合学习简单孤立的知识点，比如链表的定义与实现。\n  学习复杂的知识，需要大段的连续时间。图书馆是个好地方，安静氛围好。手机放一边，不要理会qq微信，最好阅读纸质书，泡上一整天。有些城市出现了付费自习室，提供格子间、茶水等等，也是非常好的选择。\n\n\n# 用起来\n\n\n# 技术分享\n\n从下面这张图我们可以看到，教授他人是知识留存率最高的方式。\n\n\n准备ppt和演讲内容，给同事来一场技术分享。不光复习知识，还锻炼口才。曾经有个同事说话又快又急，口头禅也多，比如"对吧、是不是”，别人经常听不清，但是他本人不以为然。领导让他做了几次技术分享，听众的反应可想而知，他才彻底认清缺点。\n  坚持写技术博客，别在意你写的东西在网上已经重复千百遍。当自己动手的时候，才会意识到眼高手低。让文章读起来流畅清晰，需要呕心沥血的删改。写作是对大脑的长期考验，想不到肯定写不出，想不清楚肯定写不清楚。\n\n\n# 造个轮子\n\n我们经常说不要重复造轮子。为了开发效率，可以不造轮子，但是必须具备造轮子的能力。优秀开源项目的作者通常具备极高的工程能力，从工程的实际需求出发，用代码实现一个通用的解决方案。造轮子的目的，首先是巩固编程知识，其次是锤炼工程能力。\n\n建议造一个简单的mq，会用到通信协议、设计模式、队列等许多知识。在造轮子的过程中，又要翻阅大量的技术资料或者博客，这就是用输出倒逼输入。\n\n本文转自 https://www.cnblogs.com/xiaoyangjia/p/11535486.html，如有侵权，请联系删除。',charsets:{cjk:!0},lastUpdated:"2023/11/01, 06:52:24",lastUpdatedTimestamp:1698821544e3},{title:"初次走上技术管理岗位的思考总结 - 编码砖家",frontmatter:{title:"初次走上技术管理岗位的思考总结 - 编码砖家",date:"2023-11-01T15:06:06.000Z",permalink:"/pages/b7e1f4/"},regularPath:"/03.%E8%BD%AF%E6%8A%80%E8%83%BD/04.%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/01.%E5%88%9D%E6%AC%A1%E8%B5%B0%E4%B8%8A%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E5%B2%97%E4%BD%8D%E7%9A%84%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93%20-%20%E7%BC%96%E7%A0%81%E7%A0%96%E5%AE%B6%20.html",relativePath:"03.软技能/04.项目管理/01.初次走上技术管理岗位的思考总结 - 编码砖家 .md",key:"v-1d50b52b",path:"/pages/b7e1f4/",headers:[{level:3,title:"角色认知",slug:"角色认知",normalizedTitle:"角色认知",charIndex:158},{level:3,title:"自我管理",slug:"自我管理",normalizedTitle:"自我管理",charIndex:650},{level:4,title:"谨言慎行",slug:"谨言慎行",normalizedTitle:"谨言慎行",charIndex:658},{level:4,title:"时间管理",slug:"时间管理",normalizedTitle:"时间管理",charIndex:929},{level:4,title:"沟通四化",slug:"沟通四化",normalizedTitle:"沟通四化",charIndex:1228},{level:3,title:"对下管理",slug:"对下管理",normalizedTitle:"对下管理",charIndex:1408},{level:4,title:"奖惩严明",slug:"奖惩严明",normalizedTitle:"奖惩严明",charIndex:1416},{level:4,title:"亲疏得当",slug:"亲疏得当",normalizedTitle:"亲疏得当",charIndex:1579},{level:3,title:"对上管理",slug:"对上管理",normalizedTitle:"对上管理",charIndex:1833},{level:4,title:"主动汇报",slug:"主动汇报",normalizedTitle:"主动汇报",charIndex:1892},{level:4,title:"争取资源",slug:"争取资源",normalizedTitle:"争取资源",charIndex:2131},{level:3,title:"局限性",slug:"局限性",normalizedTitle:"局限性",charIndex:2308}],headersStr:"角色认知 自我管理 谨言慎行 时间管理 沟通四化 对下管理 奖惩严明 亲疏得当 对上管理 主动汇报 争取资源 局限性",content:"初次走上管理岗位的技术骨干，总是有很多困惑。为什么比以前写代码还累？怎么让任务安排更合理？为什么总有下属不愿意进步，每天得过且过？诸如此类的问题，本文并不能都给出解决方法。本文的目的是抛砖引玉，如果诸位能从中获得一点点启发，那就是博主的一点点贡献。由于从事管理工作时间并不长，才疏学浅，如有错误请批评指正。\n\n\n# 角色认知\n\n从技术转向管理，关注点发生转变，沟通对象也发生变化，沟通方法变得非常必要，需要时间去磨炼和积累。最关键的是对自身角色要有准确的认知。\n  我们做程序员的时候，工作内容是服从经理的任务分工，实现产品经理的需求。沟通对象是技术经理(直接上级)、产品经理、测试人员，有时候也会跨部门沟通，一般其他前后端开发同事。大家看看下表：\n\n分类     开发工程师           技术经理\n岗位作用   实现业务需求、故障处理     分配任务、把控项目进度、解决技术难点、确定技术方案、故障处理第一责任人\n沟通对象   主要是技术经理         所有下级、直接上级以及其他部门领导\n工作特点   接触面窄，任务单一       承上启下沟通和协调、承受业绩压力、更大的责任\n考核指标   完成需求及时性，BUG级别   项目按时上线、响应故障及时性、下级能力提升\n\n技术经理这个角色的是承上启下的最小决策单元，只是代码写的少，其他的工作都变得更加复杂，而且责任还大了。大家可能也见过整天喝茶刷抖音的技术经理，我觉得他要么管理水平真的很高，要么是凭资历当的水货领导。\n\n\n# 自我管理\n\n# 谨言慎行\n\n畅销书《影响力》提到，因为影响力的巨大差异，娱乐明星比科学家收入高几万倍。技术经理管理了N个人，影响力就是N倍，如果言行不端，造成的影响是基层人员的N倍。博主有过一个上级，把粗鲁当成豪迈，各种JB、CAO啊脏话挂在嘴边，时不时来个荤段子，有女同事在场也是如此。有些涉世未深的同事有样学样，导致其他部门说我们太黄。某些管理者喜欢享受信息不对称的优越感，传播未经证实的消息(比如要裁员)，可能造成基层人员军心不稳。\n  有一个比喻很恰当：公司是一棵大树，领导是树上面的猴子，树下面的猴子都能看到他的红屁股，但是他自己却看不到。\n\n# 时间管理\n\n走上了管理岗位，沟通工作多了，会议也多了，自己亲手做事的时间少了。如果总是觉得时间不够用，但是又不知道时间花到哪儿去了，这就需要时间管理。越是任务繁杂，时间管理就越重要，分享几点经验：\n\n * 每日都列任务清单：根据事情轻重缓急，列出今日必做清单、明日待办清单。今日必做的事情加班都要完成。\n * 自己做还是授权做：有效的授权是管理者必须掌握的技能，它不但可以节省管理者的时间，更重要的是可以培养员工，使他们承担责任和压力，快速成长起来。\n * 预估事情完成时间和资源：很多事情不是孤立存在的，需要外部资源支持。预估完成时间和资源，可以提取安排，当一部分卡住就切换到另外一部分。\n\n# 沟通四化\n\n有效沟通的技巧总结起来，就是四化：信息量化、问题具体化、成果期限化、事情责任化。\n\n 1. 信息量化指的是沟通目标或任务具体明确，可以清晰度量。\n 2. 问题具体化是将对事物的认知与描述明确化，具体化。\n 3. 成果期限化指交待任务时要明确完成期限、交付具体时间点。\n 4. 事情责任化是把事情具体到责任人，在规定的期限内向责任人要结果。\n\n\n# 对下管理\n\n# 奖惩严明\n\n每个人都是愿意被奖励不愿意被惩罚，利用奖惩严明的规则来激励团队。奖励的方式多种多样，但是大多数公司给不了实物奖励，当面表扬就是最好的方式，就是动动嘴皮子。表扬他人，内容要详细清楚，有以点带面的号召力，避免“你干的还不错”这类混沌的说法。批评他人应该清楚的指出为什么受到批评，造成的后果，最后提出改正的建议。\n\n# 亲疏得当\n\n由于权力的威慑或者某些利益，下属不会毫无顾忌的和上级说心里话，管理者几乎不可能和下属成为亲密朋友。从亲疏关系上看，“离得远”就无法管理，“离得近”又不太可能，那怎么了解下属的真实想法和诉求呢？方法是多请吃饭多喝酒。饭局文化是我们中国人特有的文化，很多正经事都是饭桌上谈的。酒过三巡，胆变大了话变多了，谈谈理想谈谈人生，聊聊各自的家庭情况。其实大家都是明白人，上班的时候客客气气叫你领导，也只是为了赚点钱养家糊口。平时就不要装逼玩高冷，或者刻意套近乎称兄道弟，只要是假的，别人都看得出来。\n\n\n# 对上管理\n\n谁敢管理上级呢？不要误解管理这个词，管理的本质是借助他人达成目的，借助上级达成自己的目的也是管理。\n\n# 主动汇报\n\n因为缺乏对上管理能力，跟上级相处的时候，我们可能会采取三种方式：\n\n * 猜，通过各种蛛丝马迹、胡思乱想来猜测上级到底要什么。\n * 等，什么也不做，等着哪天遇到一个完美上级来赏识自己。\n * 拍，试图另辟蹊径，通过顺着上级说话、拍马屁来取悦。\n\n我们应该主动汇报工作，不做无谓的揣测，但是汇报要注意以下几点：\n\n * 立足公司发展重点和战略谈问题提建议。\n * 了解部门计划，汇报实际工作成果和不足之处。\n * 换位思考理解上级的压力，询问上级对你的期望。\n\n# 争取资源\n\n资源可以是用人名额、奖金或者团建费、项目时间、外部协作等等。资源永远是紧张的，你不去争取就会落到别人的口袋。如果项目做的好，一定要找领导邀功，争取奖金或者其他福利。如果预感到项目工期紧张，要提前争取用人名额。有的领导喜欢压开发周期，汇报的时候，把上线时间拉长，这样他砍一点也无妨。别当佛系经理，让你的下属加最多的班，喝最冷的西北风。\n\n\n# 局限性\n\n无论是职场还是生活中，有很多事情是怎么努力都做不到的。比如，你有个不省心的上级，做决策东一榔头西一棒子，部门经常高强度加班配合他，大家怨声载道。再比如，得力的下属找了薪资更高的槽位，你去找上级争取调薪挽留他，上级说公司欠一屁股债没钱。怎么办？只好给下属画饼了，画饼的结果大家都知道。\n  公司是个游泳池，管理者游的最远距离只能是池子的宽度。搞不定的时候就要认输。\n\n本文转自 https://www.cnblogs.com/xiaoyangjia/p/11338959.html，如有侵权，请联系删除。",normalizedContent:"初次走上管理岗位的技术骨干，总是有很多困惑。为什么比以前写代码还累？怎么让任务安排更合理？为什么总有下属不愿意进步，每天得过且过？诸如此类的问题，本文并不能都给出解决方法。本文的目的是抛砖引玉，如果诸位能从中获得一点点启发，那就是博主的一点点贡献。由于从事管理工作时间并不长，才疏学浅，如有错误请批评指正。\n\n\n# 角色认知\n\n从技术转向管理，关注点发生转变，沟通对象也发生变化，沟通方法变得非常必要，需要时间去磨炼和积累。最关键的是对自身角色要有准确的认知。\n  我们做程序员的时候，工作内容是服从经理的任务分工，实现产品经理的需求。沟通对象是技术经理(直接上级)、产品经理、测试人员，有时候也会跨部门沟通，一般其他前后端开发同事。大家看看下表：\n\n分类     开发工程师           技术经理\n岗位作用   实现业务需求、故障处理     分配任务、把控项目进度、解决技术难点、确定技术方案、故障处理第一责任人\n沟通对象   主要是技术经理         所有下级、直接上级以及其他部门领导\n工作特点   接触面窄，任务单一       承上启下沟通和协调、承受业绩压力、更大的责任\n考核指标   完成需求及时性，bug级别   项目按时上线、响应故障及时性、下级能力提升\n\n技术经理这个角色的是承上启下的最小决策单元，只是代码写的少，其他的工作都变得更加复杂，而且责任还大了。大家可能也见过整天喝茶刷抖音的技术经理，我觉得他要么管理水平真的很高，要么是凭资历当的水货领导。\n\n\n# 自我管理\n\n# 谨言慎行\n\n畅销书《影响力》提到，因为影响力的巨大差异，娱乐明星比科学家收入高几万倍。技术经理管理了n个人，影响力就是n倍，如果言行不端，造成的影响是基层人员的n倍。博主有过一个上级，把粗鲁当成豪迈，各种jb、cao啊脏话挂在嘴边，时不时来个荤段子，有女同事在场也是如此。有些涉世未深的同事有样学样，导致其他部门说我们太黄。某些管理者喜欢享受信息不对称的优越感，传播未经证实的消息(比如要裁员)，可能造成基层人员军心不稳。\n  有一个比喻很恰当：公司是一棵大树，领导是树上面的猴子，树下面的猴子都能看到他的红屁股，但是他自己却看不到。\n\n# 时间管理\n\n走上了管理岗位，沟通工作多了，会议也多了，自己亲手做事的时间少了。如果总是觉得时间不够用，但是又不知道时间花到哪儿去了，这就需要时间管理。越是任务繁杂，时间管理就越重要，分享几点经验：\n\n * 每日都列任务清单：根据事情轻重缓急，列出今日必做清单、明日待办清单。今日必做的事情加班都要完成。\n * 自己做还是授权做：有效的授权是管理者必须掌握的技能，它不但可以节省管理者的时间，更重要的是可以培养员工，使他们承担责任和压力，快速成长起来。\n * 预估事情完成时间和资源：很多事情不是孤立存在的，需要外部资源支持。预估完成时间和资源，可以提取安排，当一部分卡住就切换到另外一部分。\n\n# 沟通四化\n\n有效沟通的技巧总结起来，就是四化：信息量化、问题具体化、成果期限化、事情责任化。\n\n 1. 信息量化指的是沟通目标或任务具体明确，可以清晰度量。\n 2. 问题具体化是将对事物的认知与描述明确化，具体化。\n 3. 成果期限化指交待任务时要明确完成期限、交付具体时间点。\n 4. 事情责任化是把事情具体到责任人，在规定的期限内向责任人要结果。\n\n\n# 对下管理\n\n# 奖惩严明\n\n每个人都是愿意被奖励不愿意被惩罚，利用奖惩严明的规则来激励团队。奖励的方式多种多样，但是大多数公司给不了实物奖励，当面表扬就是最好的方式，就是动动嘴皮子。表扬他人，内容要详细清楚，有以点带面的号召力，避免“你干的还不错”这类混沌的说法。批评他人应该清楚的指出为什么受到批评，造成的后果，最后提出改正的建议。\n\n# 亲疏得当\n\n由于权力的威慑或者某些利益，下属不会毫无顾忌的和上级说心里话，管理者几乎不可能和下属成为亲密朋友。从亲疏关系上看，“离得远”就无法管理，“离得近”又不太可能，那怎么了解下属的真实想法和诉求呢？方法是多请吃饭多喝酒。饭局文化是我们中国人特有的文化，很多正经事都是饭桌上谈的。酒过三巡，胆变大了话变多了，谈谈理想谈谈人生，聊聊各自的家庭情况。其实大家都是明白人，上班的时候客客气气叫你领导，也只是为了赚点钱养家糊口。平时就不要装逼玩高冷，或者刻意套近乎称兄道弟，只要是假的，别人都看得出来。\n\n\n# 对上管理\n\n谁敢管理上级呢？不要误解管理这个词，管理的本质是借助他人达成目的，借助上级达成自己的目的也是管理。\n\n# 主动汇报\n\n因为缺乏对上管理能力，跟上级相处的时候，我们可能会采取三种方式：\n\n * 猜，通过各种蛛丝马迹、胡思乱想来猜测上级到底要什么。\n * 等，什么也不做，等着哪天遇到一个完美上级来赏识自己。\n * 拍，试图另辟蹊径，通过顺着上级说话、拍马屁来取悦。\n\n我们应该主动汇报工作，不做无谓的揣测，但是汇报要注意以下几点：\n\n * 立足公司发展重点和战略谈问题提建议。\n * 了解部门计划，汇报实际工作成果和不足之处。\n * 换位思考理解上级的压力，询问上级对你的期望。\n\n# 争取资源\n\n资源可以是用人名额、奖金或者团建费、项目时间、外部协作等等。资源永远是紧张的，你不去争取就会落到别人的口袋。如果项目做的好，一定要找领导邀功，争取奖金或者其他福利。如果预感到项目工期紧张，要提前争取用人名额。有的领导喜欢压开发周期，汇报的时候，把上线时间拉长，这样他砍一点也无妨。别当佛系经理，让你的下属加最多的班，喝最冷的西北风。\n\n\n# 局限性\n\n无论是职场还是生活中，有很多事情是怎么努力都做不到的。比如，你有个不省心的上级，做决策东一榔头西一棒子，部门经常高强度加班配合他，大家怨声载道。再比如，得力的下属找了薪资更高的槽位，你去找上级争取调薪挽留他，上级说公司欠一屁股债没钱。怎么办？只好给下属画饼了，画饼的结果大家都知道。\n  公司是个游泳池，管理者游的最远距离只能是池子的宽度。搞不定的时候就要认输。\n\n本文转自 https://www.cnblogs.com/xiaoyangjia/p/11338959.html，如有侵权，请联系删除。",charsets:{cjk:!0},lastUpdated:"2023/11/01, 07:11:45",lastUpdatedTimestamp:1698822705e3},{title:"如何写一篇好的技术博客",frontmatter:{title:"如何写一篇好的技术博客",date:"2023-11-01T14:18:24.000Z",permalink:"/pages/feb22d/"},regularPath:"/03.%E8%BD%AF%E6%8A%80%E8%83%BD/02.%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/02.%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E7%AF%87%E5%A5%BD%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2.html",relativePath:"03.软技能/02.知识管理/02.如何写一篇好的技术博客.md",key:"v-0c243284",path:"/pages/feb22d/",headers:[{level:1,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:78}],headersStr:"参考资料",content:" 1. 带着明确目的写博客。通常是学习一项技术或者解决一个技术问题。\n 2. 不要轻易转载别人的帖子，写自己的博客。\n 3. 博客是总结不是过程。\n\n\n# 参考资料\n\n * 如何写一篇好的技术博客_知识库_博客园",normalizedContent:" 1. 带着明确目的写博客。通常是学习一项技术或者解决一个技术问题。\n 2. 不要轻易转载别人的帖子，写自己的博客。\n 3. 博客是总结不是过程。\n\n\n# 参考资料\n\n * 如何写一篇好的技术博客_知识库_博客园",charsets:{cjk:!0},lastUpdated:"2023/11/01, 06:52:24",lastUpdatedTimestamp:1698821544e3},{title:"博客文章",frontmatter:{archivesPage:!0,title:"博客文章",permalink:"/blog/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-20089476",path:"/blog/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/10/24, 00:19:02",lastUpdatedTimestamp:1698106742e3},{title:"生活管理实用技能",frontmatter:{title:"生活管理实用技能",date:"2023-11-01T14:01:16.000Z",permalink:"/pages/f28926/"},regularPath:"/03.%E8%BD%AF%E6%8A%80%E8%83%BD/03.%E7%94%9F%E6%B4%BB%E7%AE%A1%E7%90%86%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD.html",relativePath:"03.软技能/03.生活管理实用技能.md",key:"v-1ea7fe80",path:"/pages/f28926/",headersStr:null,content:"这是通过阅读《时间管理——给系统管理员》（Thomas A.Limoncelli 著）一书后提炼出来的四个实用技能。非常简单，但仍需要多加练习，才能牢固掌握和使用，享受其带来的益处。生活不需要复杂的技巧，只需要持之以恒地去执行，就能获得令人惊喜的成效。\n\n技能之一：制定明确的、可量化可检验的、切实可行的目标。\n\n① 要完成什么？（目标内容）\n\n② 何时完成？（检验期限）\n\n③ 如何去做？（方法与步骤）\n\n④ 什么时候去做？（时间安排）\n\n目标一定要满足上述三个条件：\n\n① 明确而不含糊： 比如，想做IT行业互联网开发，而不是什么都行；\n\n② 可量化可检验的： 比如，完成3000米中程跑，而不是拥有较好的耐力；\n\n③ 切实可行的： 比如，要日挣100元，而不是要当CTO。\n\n通过练习制定目标使之切实可行可检验，可以提高对目标的感知度，更清晰地贴近想要实现的目标，而不是浮于空中楼阁。\n\n目标种类：\n\n微目标：每日必做，比如，身体锻炼，百科知识了解；\n\n时目标：每小时要完成的事情，比如，要完成的具体事情；\n\n日目标：当前日要完成的事宜，比如，要完成的工作任务；\n\n周目标：当前周要完成的事项，比如，要完成的项目进度；\n\n月目标：当前月要完成的子目标，比如，要学会一种新语言或框架；\n\n年目标：当前年要完成的宏观子目标，比如，月薪涨XXX，掌握XXX；\n\n\n中期目标： 3-5年内想要实现的跨越，比如，从软件开发向产品开发的转型；\n\n长远目标： 5-8年内想要达到的境况，比如，事业上XXX，家庭上XXX；\n\n终极目标：人生的追求和价值观，没有比如。\n\n通过制定大大小小的目标，并且切实地实现和完成，充实生活，也使自己获得人生的满足感。可以称之为“目标驱动的人生与生活”。\n\n技能之二： 划分阶段， 分段完成\n\n生活中常常会一下子面对很多事情，总有一些事情是特别重要的，一些事情是紧要的，一些是重要的，一些是无关紧要的。那么，怎么才能有条理有效率地完成这些事情呢？ 这就需要使用第二个技能： 划分阶段，分段完成。它可以使紊乱的生活事项变得更清晰而易于管理。\n\n首先，写下想要做和需要做的事情列表；然后，根据需要和价值观理清哪些是特别重要的，紧要的，重要的，或无关紧要的，并进行标记； 接着，就可以划分阶段，每一阶段都指定当前的重心和辅助事项。一次只专注一件最最重要的事情。\n\n另外一种更具挑战性的方式是， 邀请别人帮忙。 在空闲的时候去帮助别人完成一些事情， 在忙碌的时候让别人帮忙完成一些事情， 互助互利， 这不是更好的方式么？ 当很多事情同时都是非常重要非常紧急，一个人实在忙不过来的时候， 这就派上用场了。\n\n技能之三：集中大脑的全部能量，让大脑专注于一件事项。\n\n大脑是人所拥有的最强大的武器。要充分利用大脑的“锋刃”，就不要用各种各样的事情填塞进大脑。有两种方法：\n\n ①    准备一个信息数据库，将各种信息填入该数据库以备用，这类似于“磁盘”；\n\n ②    集中大脑的能量，一次仅专注于一件事项，这类似于“内存与CPU”。\n\n\n使大脑专注于一件事项，从而大幅度提升做事的效率，腾出更多时间来完成其他的目标或追求。\n\n技能之四： 开发子例程，养成良好的习惯。\n\n开发子例程，养成良好的习惯，使得日常事项可以无意识地完成，这进一步减轻大脑的思考负担。\n\n开发子例程的示例：\n\n①   早起例程： 7:00起床 --- 漱口 --- 洗脸 --- 洗发 --- 剃须 --- 出门例程。\n\n②   出门例程： 检查衣饰是否整洁干净 --- 检查身上是否干净清爽 --- 整理着装 --- 出门。\n\n③   一日之初例程： 每天来到办公室或实验室，先花15-25分钟规划全天要完成的任务及时间安排。\n\n通过初步练习上述四个技能，我发现自己的生活确实变得更有序更清晰更踏实了，不会再花费多余的时间在无益的事情上，并且将更多的时间放在了我认为值得去做的事情。如果你也希望使生活变得更充实更有序一些，不妨试试上述技巧。\n\n\n本文转自 https://www.cnblogs.com/lovesqcc/p/4038512.html，如有侵权，请联系删除。",normalizedContent:"这是通过阅读《时间管理——给系统管理员》（thomas a.limoncelli 著）一书后提炼出来的四个实用技能。非常简单，但仍需要多加练习，才能牢固掌握和使用，享受其带来的益处。生活不需要复杂的技巧，只需要持之以恒地去执行，就能获得令人惊喜的成效。\n\n技能之一：制定明确的、可量化可检验的、切实可行的目标。\n\n① 要完成什么？（目标内容）\n\n② 何时完成？（检验期限）\n\n③ 如何去做？（方法与步骤）\n\n④ 什么时候去做？（时间安排）\n\n目标一定要满足上述三个条件：\n\n① 明确而不含糊： 比如，想做it行业互联网开发，而不是什么都行；\n\n② 可量化可检验的： 比如，完成3000米中程跑，而不是拥有较好的耐力；\n\n③ 切实可行的： 比如，要日挣100元，而不是要当cto。\n\n通过练习制定目标使之切实可行可检验，可以提高对目标的感知度，更清晰地贴近想要实现的目标，而不是浮于空中楼阁。\n\n目标种类：\n\n微目标：每日必做，比如，身体锻炼，百科知识了解；\n\n时目标：每小时要完成的事情，比如，要完成的具体事情；\n\n日目标：当前日要完成的事宜，比如，要完成的工作任务；\n\n周目标：当前周要完成的事项，比如，要完成的项目进度；\n\n月目标：当前月要完成的子目标，比如，要学会一种新语言或框架；\n\n年目标：当前年要完成的宏观子目标，比如，月薪涨xxx，掌握xxx；\n\n\n中期目标： 3-5年内想要实现的跨越，比如，从软件开发向产品开发的转型；\n\n长远目标： 5-8年内想要达到的境况，比如，事业上xxx，家庭上xxx；\n\n终极目标：人生的追求和价值观，没有比如。\n\n通过制定大大小小的目标，并且切实地实现和完成，充实生活，也使自己获得人生的满足感。可以称之为“目标驱动的人生与生活”。\n\n技能之二： 划分阶段， 分段完成\n\n生活中常常会一下子面对很多事情，总有一些事情是特别重要的，一些事情是紧要的，一些是重要的，一些是无关紧要的。那么，怎么才能有条理有效率地完成这些事情呢？ 这就需要使用第二个技能： 划分阶段，分段完成。它可以使紊乱的生活事项变得更清晰而易于管理。\n\n首先，写下想要做和需要做的事情列表；然后，根据需要和价值观理清哪些是特别重要的，紧要的，重要的，或无关紧要的，并进行标记； 接着，就可以划分阶段，每一阶段都指定当前的重心和辅助事项。一次只专注一件最最重要的事情。\n\n另外一种更具挑战性的方式是， 邀请别人帮忙。 在空闲的时候去帮助别人完成一些事情， 在忙碌的时候让别人帮忙完成一些事情， 互助互利， 这不是更好的方式么？ 当很多事情同时都是非常重要非常紧急，一个人实在忙不过来的时候， 这就派上用场了。\n\n技能之三：集中大脑的全部能量，让大脑专注于一件事项。\n\n大脑是人所拥有的最强大的武器。要充分利用大脑的“锋刃”，就不要用各种各样的事情填塞进大脑。有两种方法：\n\n ①    准备一个信息数据库，将各种信息填入该数据库以备用，这类似于“磁盘”；\n\n ②    集中大脑的能量，一次仅专注于一件事项，这类似于“内存与cpu”。\n\n\n使大脑专注于一件事项，从而大幅度提升做事的效率，腾出更多时间来完成其他的目标或追求。\n\n技能之四： 开发子例程，养成良好的习惯。\n\n开发子例程，养成良好的习惯，使得日常事项可以无意识地完成，这进一步减轻大脑的思考负担。\n\n开发子例程的示例：\n\n①   早起例程： 7:00起床 --- 漱口 --- 洗脸 --- 洗发 --- 剃须 --- 出门例程。\n\n②   出门例程： 检查衣饰是否整洁干净 --- 检查身上是否干净清爽 --- 整理着装 --- 出门。\n\n③   一日之初例程： 每天来到办公室或实验室，先花15-25分钟规划全天要完成的任务及时间安排。\n\n通过初步练习上述四个技能，我发现自己的生活确实变得更有序更清晰更踏实了，不会再花费多余的时间在无益的事情上，并且将更多的时间放在了我认为值得去做的事情。如果你也希望使生活变得更充实更有序一些，不妨试试上述技巧。\n\n\n本文转自 https://www.cnblogs.com/lovesqcc/p/4038512.html，如有侵权，请联系删除。",charsets:{cjk:!0},lastUpdated:"2023/11/01, 06:53:06",lastUpdatedTimestamp:1698821586e3},{title:"Home",frontmatter:{home:!0,heroText:"xiong201的个人知识库",tagline:"🚀知识：学习、吸收、输出、使用",actionText:"Java 知识体系 →",actionLink:"/pages/0e35d1/",bannerBg:"none",postList:"none"},regularPath:"/",relativePath:"index.md",key:"v-5ffddbde",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/10/24, 05:40:01",lastUpdatedTimestamp:1698126001e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"Java 知识体系",link:"/pages/0e35d1/"},{text:"Java 面试宝典",link:"/pages/5547aa/"},{text:"软技能",link:"/pages/1eb629/"}],sidebarDepth:2,repo:"https://github.com/xiong201",searchMaxSuggestions:10,lastUpdated:"上次更新",sidebar:{"/01.Java 知识体系/":[{title:"计算机基础",collapsable:!0,children:[{title:"数据结构",collapsable:!0,children:[["01.计算机基础/01.数据结构/01.线性数据结构——数组、链表、栈、队列.md","线性数据结构——数组、链表、栈、队列","/pages/0e35d1/"],["01.计算机基础/01.数据结构/02.哈希表.md","哈希表","/pages/beb561/"],["01.计算机基础/01.数据结构/03.图.md","图","/pages/8751ef/"],["01.计算机基础/01.数据结构/04.树.md","树","/pages/d2ac96/"],["01.计算机基础/01.数据结构/05.红黑树.md","红黑树","/pages/b5322d/"]]},{title:"操作系统",collapsable:!0,children:[{title:"Linux",collapsable:!0,children:[["01.计算机基础/02.操作系统/01.Linux/01.Linux.md","Linux","/pages/ee514b/"],["01.计算机基础/02.操作系统/01.Linux/02.Linux 常用命令.md","Linux 常用命令","/pages/74b53c/"]]}]}]},{title:"数据库",collapsable:!0,children:[["02.数据库/01.数据库基础与SQL.md","数据库基础与SQL","/pages/67462f/"],{title:"MySQL",collapsable:!0,children:[["02.数据库/02.MySQL/01.MySQL简介.md","MySQL简介","/pages/c9b13a/"],["02.数据库/02.MySQL/02.MySQL体系结构.md","MySQL体系结构","/pages/198df0/"],["02.数据库/02.MySQL/03.MySQL索引.md","MySQL索引","/pages/17d468/"],["02.数据库/02.MySQL/04.MySQL调优.md","MySQL调优","/pages/ec5067/"],["02.数据库/02.MySQL/05.MySQL命令大全.md","MySQL命令大全","/pages/f7fcac/"]]}]},{title:"Java",collapsable:!0,children:[{title:"Java 基础",collapsable:!0,children:[["03.Java/01.Java 基础/01.BigDecimal 详解.md","BigDecimal 详解","/pages/f7214d/"],["03.Java/01.Java 基础/02.Java 异常体系.md","Java 异常体系","/pages/8f19aa/"]]},{title:"Java 容器",collapsable:!0,children:[["03.Java/02.Java 容器/01.Java 集合常用使用技巧.md","Java 集合常用使用技巧","/pages/33fb2e/"],["03.Java/02.Java 容器/02.ArrayList 源码分析及扩容机制.md","ArrayList 源码分析及扩容机制","/pages/528ca4/"],["03.Java/02.Java 容器/03.HashMap 源码及底层数据结构分析.md","HashMap 源码及底层数据结构分析","/pages/a794bb/"]]},{title:"Java 并发",collapsable:!0,children:[["03.Java/03.Java 并发/01.并发编程基础.md","并发编程基础","/pages/571a8d/"],["03.Java/03.Java 并发/02.Java 线程池详解.md","Java 线程池详解","/pages/adbda5/"],["03.Java/03.Java 并发/03.CompletableFuture 详解.md","CompletableFuture 详解","/pages/77c217/"],["03.Java/03.Java 并发/04.Java 锁.md","Java 锁","/pages/737a52/"]]},{title:"Java 新特性",collapsable:!0,children:[{title:"Java8 新特性",collapsable:!0,children:[["03.Java/04.Java 新特性/01.Java8 新特性/01.Java 8 新特性.md","Java 8 新特性","/pages/b6b76e/"],["03.Java/04.Java 新特性/01.Java8 新特性/02.Java 8 并行流.md","Java 8 并行流","/pages/f2f56b/"]]}]},{title:"JVM",collapsable:!0,children:[["03.Java/05.JVM/01.Java 内存区域.md","Java 内存区域","/pages/ecd0f2/"],["03.Java/05.JVM/02.JVM 垃圾收集.md","JVM 垃圾收集","/pages/5bf174/"],["03.Java/05.JVM/03.JVM 常用参数.md","JVM 常用参数","/pages/c5dfa7/"],["03.Java/05.JVM/04.JVM 常用的调优工具.md","JVM 常用的调优工具","/pages/2cdbc6/"],["03.Java/05.JVM/05.JVM 调优.md","JVM 调优","/pages/b8b917/"],["03.Java/05.JVM/06.JVM 问题排查及调优.md","JVM 问题排查及调优","/pages/7bbf36/"]]}]},{title:"系统设计",collapsable:!0,children:[{title:"常用框架",collapsable:!0,children:[{title:"Spring",collapsable:!0,children:[["04.系统设计/01.常用框架/01.Spring/01.Spring Bean.md","Spring Bean","/pages/47235b/"],["04.系统设计/01.常用框架/01.Spring/02.Spring事务总结.md","Spring事务总结","/pages/5fcbaa/"]]}]},{title:"分布式",collapsable:!0,children:[{title:"分布式锁",collapsable:!0,children:[["04.系统设计/02.分布式/01.分布式锁/01.分布式锁介绍.md","分布式锁介绍","/pages/4418d1/"],["04.系统设计/02.分布式/01.分布式锁/02.分布式锁常见实现方案总结.md","分布式锁常见实现方案总结","/pages/d51c58/"]]},{title:"幂等性",collapsable:!0,children:[["04.系统设计/02.分布式/02.幂等性/01.幂等性介绍.md","幂等性介绍","/pages/8c09c7/"]]},["04.系统设计/02.分布式/03.RPC介绍.md","RPC介绍","/pages/126fc8/"],["04.系统设计/02.分布式/04.Dubbo.md","Dubbo","/pages/80c6b1/"]]},{title:"微服务",collapsable:!0,children:[{title:"SpringCloud",collapsable:!0,children:[["04.系统设计/03.微服务/01.SpringCloud/01.SpringCloud.md","SpringCloud","/pages/d2a1d0/"]]},{title:"SpringCloudAlibaba",collapsable:!0,children:[["04.系统设计/03.微服务/02.SpringCloudAlibaba/01.SpringCloudAlibaba.md","SpringCloudAlibaba","/pages/a8e8ff/"]]},["04.系统设计/03.微服务/03.链路追踪SkyWalking.md","链路追踪SkyWalking","/pages/01d62e/"]]},{title:"定时任务",collapsable:!0,children:[["04.系统设计/04.定时任务/01.Java 定时任务大全.md","Java 定时任务大全","/pages/ae063e/"],["04.系统设计/04.定时任务/02.分布式定时任务——Quartz.md","分布式定时任务——Quartz","/pages/ada754/"]]},{title:"Web服务器",collapsable:!0,children:[["04.系统设计/05.Web服务器/01.Nginx.md","Nginx","/pages/dd97c6/"]]}]},{title:"代码质量",collapsable:!0,children:[{title:"设计模式",collapsable:!0,children:[["05.代码质量/01.设计模式/01.设计模式简介.md","设计模式简介","/pages/56a50e/"],["05.代码质量/01.设计模式/02.责任链模式.md","责任链模式","/pages/62b3c2/"],["05.代码质量/01.设计模式/03.模版方法模式.md","模版方法模式","/pages/a2e658/"]]},["05.代码质量/02.Java 命名规范.md","Java 命名规范","/pages/d83c14/"],["05.代码质量/03.代码优化.md","代码优化","/pages/6281f2/"]]}],catalogue:{},"/02.Java 面试宝典/":[{title:"面试准备",collapsable:!0,children:[["01.面试准备/01.面试准备.md","面试准备","/pages/5547aa/"],["01.面试准备/02.简历制作.md","简历制作","/pages/80654c/"],["01.面试准备/03.Boss 直聘投简历技巧.md","Boss 直聘投简历技巧","/pages/5da9d3/"]]},{title:"Java 八股文",collapsable:!0,children:[["02.Java 八股文/01.Java 基础面试题.md","Java 基础面试题","/pages/b4d599/"],["02.Java 八股文/02.Java 集合 面试题.md","Java 集合 面试题","/pages/346648/"],["02.Java 八股文/03.Java 并发面试题.md","Java 并发面试题","/pages/f4f268/"],["02.Java 八股文/04.Java 新特性面试题.md","Java 新特性面试题","/pages/89ee48/"],["02.Java 八股文/05.JVM 面试题.md","JVM 面试题","/pages/752c30/"],["02.Java 八股文/06.MySQL 面试题.md","MySQL 面试题","/pages/b23391/"],["02.Java 八股文/07.Redis 面试题.md","Redis 面试题","/pages/b1ecc7/"],["02.Java 八股文/08.Spring 面试题.md","Spring 面试题","/pages/330962/"],["02.Java 八股文/09.Mybatis&MybatisPlus 面试题.md","Mybatis&MybatisPlus 面试题","/pages/e68641/"],["02.Java 八股文/10.SpringBoot 面试题.md","SpringBoot 面试题","/pages/663a49/"],["02.Java 八股文/11.SpringCloud 面试题.md","SpringCloud 面试题","/pages/3c9abe/"],["02.Java 八股文/12.SpringCloudAlibaba 面试题.md","SpringCloudAlibaba 面试题","/pages/4a2429/"],["02.Java 八股文/13.分布式.md","分布式","/pages/0d16b1/"],["02.Java 八股文/14.Nginx 面试题.md","Nginx 面试题","/pages/d4abbd/"]]}],"/03.软技能/":[{title:"方法论",collapsable:!0,children:[["01.方法论/01.思考框架.md","思考框架","/pages/1eb629/"],["01.方法论/02.时间管理GTD.md","时间管理GTD","/pages/6fff61/"]]},{title:"知识管理",collapsable:!0,children:[["02.知识管理/01.搭建个人知识库.md","搭建个人知识库","/pages/15a2bc/"],["02.知识管理/02.如何写一篇好的技术博客.md","如何写一篇好的技术博客","/pages/feb22d/"],["02.知识管理/03.如何高效的学习技术.md","如何高效的学习技术","/pages/11d0b0/"]]},["03.生活管理实用技能.md","生活管理实用技能","/pages/f28926/"],{title:"项目管理",collapsable:!0,children:[["04.项目管理/01.初次走上技术管理岗位的思考总结 - 编码砖家 .md","初次走上技术管理岗位的思考总结 - 编码砖家","/pages/b7e1f4/"]]}]},updateBar:{showToArticle:!1},pageButton:!1,pageStyle:"line",category:!1,tag:!1,author:{name:"Xiong"},social:{},footer:{createYear:2023,copyrightInfo:"xiong201 | MIT License"}}};var Es=t(88),Ts=t.n(Es),_s=t(95),Ss=t(96),ks=t(11);var ws={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:a}}=n;return!(e||!1===t||!0===a)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,a=e.frontmatter.sticky;return t&&a?t==a?Object(ks.a)(n,e):t-a:t&&!a?-1:!t&&a?1:Object(ks.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(ks.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let a=0,r=n.length;a<r;a++){const{frontmatter:{categories:r,tags:i}}=n[a];"array"===Object(ks.n)(r)&&r.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[a]))}),"array"===Object(ks.n)(i)&&i.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[a]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Qt.component(_s.default),Qt.component(Ss.default);function Cs(n){return n.toString().padStart(2,"0")}t(244);Qt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,409))),Qt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,95))),Qt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,96)));t(245);var As=[Ts.a,({Vue:n,options:e,router:t,siteData:a})=>{a.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Cs(n.getUTCMonth()+1)}-${Cs(n.getUTCDate())} ${Cs(n.getUTCHours())}:${Cs(n.getUTCMinutes())}:${Cs(n.getUTCSeconds())}`}(e)),t?n.author=t:a.themeConfig.author&&(n.author=a.themeConfig.author)}),n.mixin(ws)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?01293bffa6c3962016c08ba685c79d78";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))}],Is=[];class zs extends class{constructor(){this.store=new Qt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Qt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(zs.prototype,{getPageAsyncComponent:ol,getLayoutAsyncComponent:ll,getAsyncComponent:sl,getVueComponent:cl});var Ls={install(n){const e=new zs;n.$vuepress=e,n.prototype.$vuepress=e}};function Ms(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var js={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return ul("pageKey",e),Qt.component(e)||Qt.component(e,ol(e)),Qt.component(e)?n(e):n("")}},Bs={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Ps={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Os=(t(246),t(247),Object(vs.a)(Ps,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Rs={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Qt.config.productionTip=!1,Qt.use(Go),Qt.use(Ls),Qt.mixin(function(n,e,t=Qt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const a=new(n(t.$vuepress.$get("siteData"))),r=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),i={};return Object.keys(r).reduce((n,e)=>(e.startsWith("$")&&(n[e]=r[e].get),n),i),{computed:i}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const a in n)"/"===a?t=n[a]:0===this.$page.path.indexOf(a)&&(e=n[a]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,a=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?a?a+" | "+t:t:a||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const a=n[t];if(a.path.toLowerCase()===e.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},xs)),Qt.component("Content",js),Qt.component("ContentSlotsDistributor",Bs),Qt.component("OutboundLink",Os),Qt.component("ClientOnly",Rs),Qt.component("Layout",ll("Layout")),Qt.component("NotFound",ll("NotFound")),Qt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.9",hash:"18e5a89"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:xs.routerBase||xs.base,t=new Go({base:e,mode:"history",fallback:!1,routes:ys,scrollBehavior:(n,e,t)=>t||(n.hash?!Qt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,a)=>{if(Ms(n,e.path))a();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Ms(n,t)?a(t):a()}else a();else{const t=e.path+"/",r=e.path+".html";Ms(n,r)?a(r):Ms(n,t)?a(t):a()}})}(t);const a={};try{await Promise.all(As.filter(n=>"function"==typeof n).map(e=>e({Vue:Qt,options:a,router:t,siteData:xs,isServer:n})))}catch(n){console.error(n)}return{app:new Qt(Object.assign(a,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Is.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);