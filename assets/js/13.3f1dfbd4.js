(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{342:function(s,t,v){"use strict";v.r(t);var _=v(7),a=Object(_.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",[s._v("MySQL是基于客户机——服务器的DBMS。服务器部分负责所有数据访问和处理的一个软件。客户机是与用户打交道的软件。")]),s._v(" "),t("p",[s._v("使用MySQL的原因：")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("成本")]),s._v("：MySQL开源，可以免费使用。")]),s._v(" "),t("li",[t("strong",[s._v("性能")]),s._v("：MySQL执行非常快。")]),s._v(" "),t("li",[t("strong",[s._v("可信赖")]),s._v("：某些非常重要和声望高的公司、站点使用MySQL处理重要数据。")]),s._v(" "),t("li",[t("strong",[s._v("简单")]),s._v("：MySQL容易安装和使用。")])]),s._v(" "),t("h1",{attrs:{id:"并发控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并发控制"}},[s._v("#")]),s._v(" 并发控制")]),s._v(" "),t("p",[s._v("MySQL有两个层面的并发控制：服务器层与存储引擎层。")]),s._v(" "),t("p",[s._v("通用使用锁解决并发问题。有两种类型的锁：共享锁和排他锁，也叫读锁和写锁。读锁是共享的，相互不阻塞，写锁是排他的，一个写锁会阻塞其他的读和写操作。")]),s._v(" "),t("p",[s._v("有两种最重要的锁策略：表锁和行级锁。")]),s._v(" "),t("p",[s._v("表锁是最基本的锁策略，并且是开销最小的策略（加锁也是需要消耗资源的）。表锁会锁定整张表。")]),s._v(" "),t("p",[s._v("行级锁可以最大程度支持并发处理，同时也带来最大的锁开销。行级锁只在存储引擎实现。比如InnoDB存储引擎就实现了行急锁。")]),s._v(" "),t("h1",{attrs:{id:"事务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[s._v("#")]),s._v(" 事务")]),s._v(" "),t("p",[s._v("MySQL的InnoDB存储引擎支持事务。")]),s._v(" "),t("p",[s._v("MySQL默认自动提交事务。可以通过设置AUTOCOMMIT变量来启用或者禁用自动提交事务。")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("show")]),s._v(" VARIABLES "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("like")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'AUTOCOMMIT'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//查看是否是自动提交模式，ON启用，OFF禁用")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SET")]),s._v(" AUTOCOMMIT"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//1启用自动提交模式，0禁用")]),s._v("\n")])])]),t("p",[s._v("可以通过"),t("code",[s._v("SET TRANSACTION ISOLATION LEVEL")]),s._v(" 命令设置隔离级别,新的隔离级别在下一个事务开始的时候生效。MySQL的InnoDB存储引擎支持所有隔离级别。")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SET")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("TRANSACTION")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("ISOLATION")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("LEVEL")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("READ")]),s._v(" COMMITED\n")])])]),t("p",[s._v("MySQL事务是由下层的存储引擎实现的，所以避免在同一个事务中，使用多种存储引擎。假如在一个事务中混合使用了事务型和非事务型表（比如InnoDB和MyISAM表），回滚时非事务型表的数据是无法回滚的。")]),s._v(" "),t("h1",{attrs:{id:"多版本并发控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多版本并发控制"}},[s._v("#")]),s._v(" 多版本并发控制")]),s._v(" "),t("p",[s._v("MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。为了提高并发性能，一般都同时实现了多版本并发控制（MVCC）。")]),s._v(" "),t("p",[s._v("MVCC是行级锁的一个变种，在大多数情况下避免了加锁操作，因此开销更低。"),t("strong",[s._v("MVCC的实现，是通过保存数据在某个时间点的快照来实现的")]),s._v("。不同存储引擎的MVCC实现不同，典型的有"),t("strong",[s._v("乐观并发控制和悲观并发控制")]),s._v("。")]),s._v(" "),t("p",[s._v("InnoDB存储引擎的MVCC是通过在每行记录后面保存两个隐藏的列实现的。这两个列，一个保存行的创建时间，一个保存行的过期时间（或删除时间）。存储的不是实际时间值而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。")]),s._v(" "),t("p",[t("strong",[s._v("MVCC具体实现")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("SELECT：InnoDB会根据以下两个条件检查每行记录\n"),t("ul",[t("li",[s._v("InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号）")]),s._v(" "),t("li",[s._v("行的删除版本要么未定义，要么大于当前事务版本号。")])])]),s._v(" "),t("li",[s._v("INSERT：InnoDB为新插入的每一行保存当前系统版本号作为行版本号")]),s._v(" "),t("li",[s._v("DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除标识。")]),s._v(" "),t("li",[s._v("UPDATE：InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。")])]),s._v(" "),t("p",[s._v("MVCC只在REPEATABLE READ 和READ COMMITTED 两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容。")])])}),[],!1,null,null,null);t.default=a.exports}}]);