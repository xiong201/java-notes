---
title: Redis 面试题
date: 2023-10-24 15:45:05
permalink: /pages/b1ecc7/
---
# Redis 基础

## 简单介绍下 Redis

Redis 是 C 语言开发的数据库，与传统数据库不同是 Redis 的数据是存在内存中的，所以读写非常快，因此Redis 被广泛应用在缓存方面。Redis 除了做缓存，也可以用来做分布式锁，甚至是消息队列。

Redis 提供了多种数据类型来支持不同的业务场景。Redis还支持事务、持久化、Lua脚本和多种集群方案。

## 缓存数据处理流程是怎么样的

1. 如果用户请求的数据在缓存中存在就直接返回数据
2. 如果缓存不存在就看数据库是否存在数据。
3. 数据库如果存在数据的话，就更新缓存的数据，并将数据返回给用户。
4. 如果数据库没有数据的话，就返回空数据。

## 为什么要使用 Redis（缓存）

使用缓存是为了提高性能进而提升用户体验。

## Redis 除了做缓存，还能做什么

- 分布式锁：Redis 做分布式锁是一种常见的方式。通常情况下，我们都是基于 Redisson  来实现分布式锁。
- 限流：可以通过 Redis+Lua 脚本实现限流。
- 消息队列：Redis 自带的 list 数据结构可以作为一个简单的队列使用。

# Redis 数据结构

## Redis 常用的数据结构有哪些

- **5种基础数据结构**：String（字符串）、List（列表）、Hash（散列）、Set（集合）、Zset（有序集合）
- **3种特殊数据结构**：HyperLogLogs（基数统计）、Bitmap（位存储）、Geospatial（地理位置）

## String 的应用场景有哪些

- 常规数据（比如 session、token、序列化后的对象）的缓存。
- 计数：比如用户单位时间的请求数、页面单位时间的访问数。
- 分布式锁（利用 `SETNX key value` 命令可以实现一个最简易的分布式锁）

## String 还是 Hash存储对象数据更好呢

绝大部分建议使用 String 存储对象数据，除非对象中的某个字段经常变动或者需要单独查询对象中的个别字段信息，这时就可以是 Hash存储。

## 使用 Redis 实现一个排行榜怎么做

Redis 中有一个叫做`sorted set`的数据结构经常被用在各种排行榜的场景。

使用相关的 Redis 命令可以进行排行： `ZRANGE` (从小到大排序) 、 `ZREVRANGE` （从大到小排序）、 `ZREVRANK` (指定元素排名)。

## 使用 Set 实现抽奖系统

- `SPOP key count`：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。
- `SRANDMEMBER key count`：随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。

# Redis 内存管理

## Reids 给缓存数据设置过期时间有啥用

主要有两个方面：

- 内存是有限的，如果缓存中的所有数据都一直保存的话，分分钟就内存溢出了。
- 有些业务场景就是需要数据只在某一时间段内存在，比如短信验证码、用户登录的 token。

Redis 中除了字符串类型有自己设置过期时间命令 `setex`外，其他方法都需要依靠 `expire`命令来设置过期时间。另外，`persist`命令可以移除一个键的过期时间。

## Redis 是如何判断数据是否过期呢

Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key（键），过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向数据库键的过期时间。

## Redis 过期数据的删除策略了解吗

常见的过期数据删除策略有两种：

- 惰性删除：只会在取出 key 的时候才对数据进行过期检查。
- 定期删除：每隔一段时间抽取一批 key 执行删除过期 key 操作。

定期删除对内存更加友好，惰性删除对CPU比较友好。Redis采用的定期删除+惰性删除。

# Redis 持久化机制

## 怎么保证 Redis 挂掉之后再重启数据可以进行恢复

通过持久化恢复数据。持久化数据就是将内存中的数据写入到硬盘里面，可以用来恢复数据。

Redis 支持持久化数据，并且支持两种不同的持久化操作。一种持久化方式叫快照（RDB），另一种方式是只追加文件（AOF）。

## 什么是 RDB 持久化

Redis 可以通过创建快照来获得存储在内存中的数据在某个时间点的副本。创建快照后，可以对快照进行备份，也可以复制到其他服务器创建相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能）。快照持久化是 Redis 默认采用的持久化方式。

## RDB 创建快照时会阻塞主线程吗

Redis 提供了 `save` 和 `bgsave` 两个命令来生成 RDB 快照文件，默认选项是`bgsave`。

`save`命令是主线程执行的，会阻塞主线程。

`bgsave`命令是子线程执行，不会阻塞主线程。

## 什么是 AOF 持久化

与快照持久化相比， AOF 持久化实时性更好，是现在主流的持久化方案。默认情况下 Redis 没有开启 AOF 持久化方式，可以通过 `appendonly`  参数开启。

```
appendonly yes
```

AOF 持久化每执行一条更改 Redis 数据的命令， Redis 就会将该命令写入到内存缓存 `server.aof_buf`，然后再根据 `appendfsync`配置决定何时同步到硬盘中的 AOF 文件。

AOF 文件保存位置和 RDB 文件相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。

Redis 配置文件存在三种不同的 AOF 持久化方式，分别是：

```
appendfsync always
#每次有数据修改发生时都会写入AOF文件，这样会严重降低Redis的速度
appendfsync everysec
#每秒钟同步一次，显式地将多个写命令同步到硬盘
appendfsync no
让操作系统决定何时进行同步
```

可以考虑使用`appendfsync everysec`进行持久化，这样 Redis 每秒同步一次 AOF 文件，对 Redis 性能几乎没影响，而且即使系统崩溃，最多只会丢失一秒之内的数据。

## AOF 日志是如何实现的

关系型数据库（如 MySQL）通过都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化是在执行命令之后记录日志。

在执行命令后记录日志可以避免额外的检查开销，并且不会阻塞当前命令的执行。但是如果刚执行完命令 Reids 就挂掉的话就会导致对应的修改丢失。

# Redis 事务

## 如何使用 Reids 事务

Redis 可以通过 `MULTI`， `EXEC`，`DISCARD`，`WATCH`等命令来实现事务。

使用 `MULIT`命令后可以输入多个命令。Redis 不会立刻执行这些命令，而是放入队列中，当调用 `EXEC`命令后将执行所有命令。

`DISCARD`命令可以取消一个事务，会将事务队列中保存的所有命令清空。

`WATCH`命令监听指定的键，当调用 `EXEC`命令执行事务时，如果一个被 `WATCH`命令监视的键被修改，整个事务都不会执行，直接返回失败。

## Redis 事务支持原子性吗

Redis 事务不支持原子性。Redis 事务在运行错误的情况下，除了处理执行过程中出现的错误命令外，其他命令都能正常执行。并且 Redis 不支持回滚操作。因此，Redis 事务不满足原子性。


# Redis 分布式锁

## Redis 分布式锁的底层原理

不管是实现本地锁还是分布式锁，核心都在于“互斥”。
**互斥**：在 Redis 中， SETNX 命令是可以帮助我们实现互斥。SETNX 即 **SET** if **N**ot e**X**ists (对应 Java 中的 setIfAbsent 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， SETNX 啥也不做。释放锁的话，直接通过 DEL 命令删除对应的 key 即可。    
**原子性**：为了防止误删其他的锁，使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。



# Redis 生产问题

## 缓存穿透

### 什么是缓存穿透

缓存穿透就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。

### 缓存穿透的处理流程是怎样的

具体处理流程是：

1. 用户请求在缓存中找不到对应的数据
2. 在数据库也查询不到对应的数据，最终返回空数据。

### 有哪些解决办法

（1）缓存无效 key

如果缓存和数据库都查不到某个key的数据，就写一个空数据到 Redis 并设置一个短暂的过期时间（过期时间尽量短一点）。这种方案只适用于请求的 key 变化不频繁的情况，并不能从根本上解决这问题。

（2）布隆过滤器

将所有可能存在的请求值都存在布隆过滤器中，当用户请求过来，先判断用户发来的请求是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走正常获取缓存的流程。

## 缓存雪崩

缓存雪崩就是缓存在同一时间大面积失效，后面的请求都直接落到数据库上，造成数据库短时间内承受大量请求。

缓存雪崩可以出现原因：

- Redis 服务不可用
- 热点缓存失效

针对 Redis 服务不可用的情况，可以搭建 Redis 集群，避免单机出现问题整个缓存服务都没法使用。还可以限流，避免同时处理大量的请求。

针对热点缓存失效，可以设置热点缓存不同的失效时间，甚至可以设置缓存永不失效。

## 如何保证缓存和数据库数据的一致性

没法完全保证缓存数据与数据库的一致，但可以尽量让它们保持一致。可以使用旁路缓存模式，当遇到写请求时：先更新数据库，再删除缓存。

如果更新数据库成功，删除缓存失败的话，就使用消息队列进行异步重试。
