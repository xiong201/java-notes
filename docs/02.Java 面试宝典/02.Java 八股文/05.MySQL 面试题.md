---
title: MySQL 面试题
date: 2023-10-24 15:44:55
permalink: /pages/b23391/
---
# MySQL 体系结构

## MySQL 逻辑架构
MySQL 逻辑架构分为三层：

- 第一层的连接层是进行连接管理的，包括连接处理、身份认证、权限获取、安全等功能。连接层有个线程池，MySQL会从线程池分配一个线程与客户端进行交互，省去创建和销毁线程开销。
- 第二层是服务层，包括SQL接口、解析器、优化器、查询缓存。
   - SQL接口用来接收SQL命令。并返回结果，支持DML、DDL、存储过程、视图、触发器等多种SQL语言接口。
   - 解析器是验证和解析SQL，并创建语法树
   - 优化器生成执行计划，并按照执行计划调用存储引擎的API方法执行查询
   - 查询缓存会缓存查询结果，不必进行查询解析、优化、执行等过程，直接将结果返回。在MySQL8.0中移除。
- 第三层是存储引擎层。主要负责数据的存储与提取。

## 一条SQL语句在MySQL中是怎么执行的

1. 服务器中如果在**查询缓存**中发现这条SQL，就会直接将结果返回，否则进入解析器阶段。
2. **解析器 **对SQL语句进行语法分析、语义检查。如果SQL语句正确的话就会生成一个语法树。
3. **优化器**会对SQL语句进行优化，并确定SQL语句的执行计划。
4. **执行器**在执行之前判断用户是否具备权限。如果没有权限，返回权限错误。如果具备权限的话，就执行SQL语句并返回结果。如果设置了查询缓存，会将结果进行缓存。

# MySQL存储引擎
## MySQL提供了哪些存储引擎
可以通过`show engines`查看MySQL所有存储引擎。最常见的存储引擎是InnoDB和MyISAM。MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。  

## MySQL存储引擎架构了解吗
MySQL 存储引擎采用的是插件式架构，支持多种存储引擎。存储引擎是基于表的，而不是数据库，可以为不同的数据库表设置不同的存储引擎。

## MyISAM和InnoDB区别

1. **是否支持行级锁**：MyISAM只支持表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁。
2. **是否支持事务**：MyISAM不支持事务，InnoDB支持事务。
3. **是否支持外键**：MyISAM不支持外键，InnoDB支持外键。
4. **是否支持数据库异常崩溃后的安全恢复**：MyISAM不支持，InnoDB支持。InnoDB通过`redo log`保证数据库崩溃后能安全恢复。
5. **是否支持MVCC**：MyISAM不支持，InnoDB支持。
6. **索引实现不一样**：MyISAM和InnoDB虽然都是使用B+ Tree实现索引，但是实现方式不太一样，InnoDB的聚簇索引叶子节点存储完整数据，而MyISAM叶子节点存储的是数据记录的地址。

# MySQL 事务
## 什么是事务
事务是逻辑上的一组操作，事务中的操作要么全都执行，要么全都不执行。

## 什么是数据库事务
数据库事务保证多个对数据库的操作（也就是SQL）构成一个逻辑上的整体。这些操作要么全部执行成功，要么全部不执行。
## ACID特性是什么

- **原子性（Atomicity）**： 事务是最小的执行单位，不允许分割。事务的原子性确保事务中操作要么全部完成，要么全都不完成。
- **一致性（Consistency）**：事务前后数据要保持一致。
- **隔离性（Isolation）**：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。
- **持久性（Durability）**：事务一旦被提交，将永久的保存到数据库，即使是数据库发生故障也不应该对其有任何影响。

**只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的**

## 并发事务带来什么问题

- **脏读（Dirty read）**：一个事务读取另一个事务未提交数据
- **丢失更新（Lost to modify）**：一个事务对数据的修改被另一个事务所覆盖
- **不可重复读**：一个事务两次读取相同数据，在这期间，另一个事务对数据进行修改，导致第一个事务两次读取的数据不一致
- **幻读**：一个事务多次读取数据不一致，发现读取到的数据增加了
## 不可重复读和幻读区别

- **不可重复读**的重点是**内容修改或者记录减少**。比如指多次读取一条记录，发现其中某些记录的值被修改。
- **幻读**的重点在于**记录新增**。比如多次执行同一条查询语句，发现查询到记录增加了。
> delete和update操作，可以直接对记录加锁，保证事务安全。
> 而执行insert操作时，记录锁只能锁住已存在记录，为了避免插入新记录，需要使用间隙锁。


## SQL标志定义了哪些事务隔离级别
SQL标志定义了四个隔离级别：

- **READ-UNCOMMITTED(读取未提交)** ： 最低的隔离级别，允许读取尚未提交的数据，可能会导致脏读、幻读或不可重复读。
- **READ-COMMITTED(读取已提交)** ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
- **REPEATABLE-READ(可重复读)** ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
- **SERIALIZABLE(可串行化)** ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

## MySQL默认隔离级别是什么？能解决幻读问题吗
MySQL InnoDB存储引擎默认隔离级别是**REPEATABLE-READ（可重复读）**。可以通过`SELECT @@tx_isolation;`命令查看， MySQL 8.0 该命令改为`SELECT @@transaction_isolation;`
**InnoDB实现的 REPEATABLE-READ 隔离级别可以解决幻读问题**，主要通过`MVCC`和`Next-key Lock`解决幻读问题：

- **快照读**：由MVCC机制来保证不会出现幻读。
- **当前读**： 使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是记录锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。


## 什么是MVCC? 有什么用？原理是什么？（待完善）
MVCC是多版本并发控制，是InnoDB存储引擎对非锁定一致性读的实现。

# MySQL锁

## 表级锁和行级锁了解吗？有什么区别？

MyISAM仅仅支持表级锁，一锁就锁整张表，这在并发写的情况下性能非常差。InnoDB不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录进行加锁（对一行或者多行记录进行加锁），所以对于并发写的情况下，InnoDB的性能更高。
**表级锁和行级锁对比**：

- **表级锁：** MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。
- **行级锁：** MySQL 中锁定粒度最小的一种锁，是 **针对索引字段加的锁** ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。
## 行级锁的使用有什么注意事项
InnoDB行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 UPDATE、DELETE 语句时，如果 WHERE条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！
不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。

## 共享锁和排他锁呢
不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：

- **共享锁（S 锁）** ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。
- **排他锁（X 锁）** ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。

排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。

|  | S 锁 | X 锁 |
| --- | --- | --- |
| S 锁 | 不冲突 | 冲突 |
| X 锁 | 冲突 | 冲突 |

## 当前读和快照读有什么区别
**快照读**（一致性非锁定读）就是单纯的 SELECT 语句，但不包括下面这两类 SELECT 语句：  
```sql
SELECT ... FOR UPDATE
SELECT ... LOCK IN SHARE MODE

```
快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。

**当前读** （一致性锁定读）就是给行记录加 X 锁或 S 锁。
当前读的一些常见 SQL 语句类型如下：
```sql
# 对读的记录加一个X锁
SELECT...FOR UPDATE
# 对读的记录加一个S锁
SELECT...LOCK IN SHARE MODE
# 对修改的记录加一个X锁
INSERT...
UPDATE...
DELETE...

```
## InnoDB有哪几类行锁
InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：

- **记录锁（Record Lock）** ：也被称为记录锁，属于单个行记录上的锁。
- **间隙锁（Gap Lock）** ：锁定一个范围，不包括记录本身。
- **临键锁（Next-Key Lock）** ：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。

**在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。**

# MySQL索引

## 何为索引？有什么作用？
索引是一种帮助MySQL高效获取数据的数据结构，由具体的存储引擎实现。索引相当于书的目录，有了目录就可以直接定位到我们要查找的数据，无须一页一页的进行查找。常见的索引结构有：B树、B+树、Hash、红黑树。在MySQL中，InnoDB和MyISAM都使用了B+树作为索引结构。
## 索引的优缺点
优点：

- 索引可以提高查询效率，这是创建索引最主要的原因。
- 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性

缺点：

- 创建和维护索引需要一定开销，当对表中的数据进行增删改操作时，索引也要动态的修改，会降低SQL执行效率。
- 索引需要使用物理文件存储，也会耗费一定空间。
## 索引的底层数据结构（待完善）
索引的底层数据结构：Hash表、B树、B+树。

## MySQL的索引结构为什么使用B+树？

- 二叉查找树(BST)：解决了排序的基本问题，但是由于无法保证平衡，可能**退化为链表**；
- 平衡二叉树(AVL)：通过旋转解决了平衡的问题，但是**旋转操作效率太低**；
- 红黑树：通过舍弃严格的平衡和引入红黑节点，解决了AVL旋转效率过低的问题，但是在磁盘等场景下，**树仍然太高，IO次数太多**；
- B树：通过将二叉树改为多路平衡查找树，解决了树过高的问题；
- B+树：在B树的基础上，将**非叶节点改造为不存储数据的纯索引节点，进一步降低了树的高度**；此外将叶节点使用指针连接成链表，范围查询更加高效。 

参考资料：[https://www.cnblogs.com/kismetv/p/11582214.html](https://www.cnblogs.com/kismetv/p/11582214.html)

## 主键索引和二级索引
**主键索引**：数据表的主键列使用的就是主键索引。一张数据表只能有一个主键，并且不为null，不能重复。在MySQL的InnoDB表中，如果没有显示的指定表的主键，InnoDB会自动检查表中是否有唯一索引并且不允许为null 值的字段，有的话，默认该字段未默认的主键，否则InnoDB将自动创建一个自增主键。
**二级索引（辅助索引）**：二级索引又称为辅助索引，因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。普通索引，唯一索引等都属于二级索引。
## 聚簇索引和非聚簇索引
**聚簇索引：聚簇索引即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。**聚簇索引的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。聚簇索引的查询速度非常快，因为数据是直接存储在叶子节点。
**非聚簇索引**：**非聚簇索引即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。**非聚簇索叶子节点是不存放数据的。innoDB使用非聚簇索引大部分情况下都需要进行回表操作，除非使用覆盖索引，才不用回表。 
## 覆盖索引
非聚簇索引查询数据时，如果查询语句所用到字段包含在索引字段+主键，此时就无须进行回表操作，可以直接将数据返回。

## 联合索引
 使用表中的多个字段创建索引，就是 **联合索引**，也叫 **组合索引** 或 **复合索引**。  
## 最左前缀匹配原则
最左前缀匹配原则指的是，在使用联合索引时，**MySQL** 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 **>**、**<**、**between** 和 **以%开头的like查询** 等条件，才会停止匹配。
所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。

## 创建索引的注意事项有哪些

- **选择合适的字段创建索引**
- **频繁更新的字段应该慎重建立索引**
- **尽可能的考虑建立联合索引而不是单列索引**
- **避免索引失效**
- **删除长期未使用的索引**： 不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用  
## 哪些字段适合创建索引

- 具有唯一特性的字段应当建立唯一索引
- 频繁作为where查询条件的字段
- 经常order by，group by的字段
- 联合查询时连接条件用到的字段

## 索引失效的情况

- 创建了组合索引，但查询条件未准守最左匹配原则;
- 在索引列上进行计算、函数、类型转换等操作;
- 以 % 开头的 LIKE 查询比如 like '%abc';
- 查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到

## 如何让唯一索引和逻辑删除兼容
通过唯一索引和逻辑删除字段建立联合唯一索引。如果数据被删除，逻辑删除字段的值就是当前数据的id。

参考：[https://blog.csdn.net/Park33/article/details/130015392](https://blog.csdn.net/Park33/article/details/130015392)


# MySQL日志

## MySQL常见的日志有哪些
MySQL中常见的日志类型主要有下面几类（针对的是InnoDB存储引擎）：

- **错误日志（error log）**：对MySQL的启动、运行、关闭过程进行了记录。
- **二进制日志（binary log，binlog）**：主要记录的是更改数据库数据的SQL语句
- **一般查询日志（general query log）**：已建立连接的客户端发送给MySQL服务器的所有SQL记录，因为SQL的量比较大，默认是不开启的，也不建议开启。
- **慢查询日志（show query log）**：执行时间超过`long_query_time`秒钟的查询，解决SQL慢查询问题会用到。
- **事务日志（redo log 和undo log）**：redo log是重做日志，undo log 是回滚日志。
- **中继日志（relay log）**：relay log 是复制过程中产生的日志，很多方面都跟binary log差不多。不过，relay log 针对的是主从复制中的从库。
- **DDL日志（metadata log）**：DDL语句执行的元数据操作。
## 慢查询日志有什么用
慢查询日志记录了执行时间超过`long_query_time`（默认是10s，通常设置为1s）的所有查询语句，在解决SQL慢查询（SQL执行时间长）问题经常会用到。
找到慢SQL是优化SQL语句性能的第一步，然后使用`EXPLAIN`命名对慢SQL进行分析，获取执行计划。
可以通过`show_query_log`和long_query_time变量分别查看慢查询日志是否开启（默认关闭）和慢查询时间阈值。
在实际开发中，慢查询日志可能会比较大，直接分析不方便，可以借助MySQL官方的慢查询分析调优工具mysqldumpslow进行分析。
## binlog 主要记录了什么？有什么用
MySQL binlog（binary log 即二进制日志文件）主要记录了MySQL数据库中数据的所有变化（数据库执行的所有DDL和DML语句）。binlog最主要的应用场景是主从复制，主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据的一致性。此外，binlog还能帮忙我们进行数据恢复，在启用binlog日志情况下（默认是开启的），当我们误删数据甚至是整个数据库的情况下，就可以使用binlog来帮忙我们恢复数据。

## redo log 如何保证事务的持久性
redo log 主要做的事情就是记录页的修改，比如某个页面某个偏移量处修改了几个字节的值以及具体被修改的内容是什么。在事务提交时，我们会将redo log按照刷盘策略刷到磁盘上去，这样即使 MySQL 宕机了，重启之后也能恢复未能写入磁盘的数据，从而保证事务的持久性。
> InnoDB存储引擎使用Buffer Pool（缓冲池）来提高读写性能。当一个事务提交之后，缓冲池的对应页的修改还未持久化到磁盘，这时，如果MySQL突然宕机的话，事务的更改是不是直接就消失了?redo log就是来解决这个问题的

## 页修改之后为什么不直接刷盘呢
**直接刷盘性能非常差**！InnoDB页的大小一般为16KB，而页又是磁盘和内存交互的基本单位。这就导致即使我们只修改页中的几个字节数据，一次刷盘操作也就将16KB 大小的页整个都刷新到磁盘中。而且，这些修改的页可能并不相邻，也就是说这还是随机IO。
采用redo log 的方式可以避免这种性能问题，因为**redo log的刷盘性能很好**。redo log的写入属于顺序IO，并且一行redo log记录只占几十个字节。

## binlog 和redolog有什么区别

- **用途**：binlog主要用于数据库还原，属于数据级别的数据恢复，主从复制是binlog最常见的一个应用场景。redolog主要用于保证事务的持久性，属于事务级别的数据恢复。
- **是否是InnoDB引擎特有的**：redolog属于InnoDB引擎特有的，binlog属于所有存储引擎共有的。因为binlog是MySQL的Server层实现的。
- redolog属于物理日志，主要记录的某个页的修改。binlog属于逻辑日志，主要记录的是数据库执行的所有DDL和DML语句。
- **写入方式**：binlog通过追加的方式进行写入，大小没有限制。redo log 采用循环写的方式进行写入，大小固定，当写到结尾时，会回到开头循环写日志。
## undo log 如何保证事务的原子性
每一个事务对数据的修改都会被记录到undo log，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL可以利用undo log将数据恢复到事务开始之前的状态。
undo log 属于逻辑日志，记录的是SQL语句，比如说事务执行一条DELETE语句，那undo log就会记录一条相对于的INSERT语句。
# 调优

## SQL优化

1. **避免使用select ***：select * 会查询多余的数据，造成数据库资源浪费和数据传输消耗。而且select * 不会走覆盖索引，会出现大量的回表操作，降低查询sql的性能。
2. **用union all 代替union**：union 需要排重，排重过程需要遍历、排序和比较，更耗时，也更消耗cpu资源。
3. **小表驱动大表**：也就是说用小表的数据集驱动大表的数据集。 ` in`  适用于左边大表，右边小表。`exists` 适用于左边小表，右边大表。这两个核心思想都是用小表驱动大表。使用left join 时左边应该是小表
4. **批量操作**：一次性操作适度数据。如果操作的数据量较大时，可以分多批次处理。  
5. **多用limit**：当只需要数据中第一条时，使用limit 1，当数据库找到符合的条件的一条数据就直接返回结果，大大提高了提升了性能。
6. **用连接查询代替子查询**：MySQL 执行子查询时，需要创建临时表，查询完毕后，需要再删除这些临时表，有一些额外的性能消耗。
7. **join的表不宜过多**：join 表的数量不应该超过3个，必要时表中可以存在冗余字段
8. **控制索引数量**：优先使用联合索引，并且删除无用的单列索引。
9. **选择合理的字段类型**：
   1. 能用数字类型，就不用字符串，因为字符的处理往往比数字要慢。
   2. 尽可能使用小的类型，比如：用bit存布尔值，用tinyint存枚举值等。
   3. 长度固定的字符串字段，用char类型。
   4. 长度可变的字符串字段，用varchar类型。
   5. 金额字段用decimal，避免精度丢失问题。
10. **提高group by 效率**：使用group by 分组时，优化在where 子句分组前进行过滤，而不是在having分组后进行过滤。
11. **索引优化**：使用explian查看执行计划，看sql是否走了索引，如果没有走索引，看是否建立了索引或者索引是否失效并进行相应的处理。


> 参考：
> - [https://cloud.tencent.com/developer/article/1899907](https://cloud.tencent.com/developer/article/1899907)
> - [https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247488618&idx=1&sn=e70a31865b5eadcb151f439004a4dd72&chksm=cea25ba1f9d5d2b795222ba90e0326618d649e858ec23e9c7360f90fbfc23a7786c33bff9556&token=1647609083&lang=zh_CN#rd](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247488618&idx=1&sn=e70a31865b5eadcb151f439004a4dd72&chksm=cea25ba1f9d5d2b795222ba90e0326618d649e858ec23e9c7360f90fbfc23a7786c33bff9556&token=1647609083&lang=zh_CN#rd)



## MySQL limit深度分页优化
**原因**：MySQL分页到后面越来越慢，其实是进行大量无用回表操作造成（前面数据都不需要，也进行了回表操作）。
**解决方案**：使用 **join+覆盖索引** 进行优化。使用覆盖索引查询对应数据主键，再join获取到完整数据，避免大量回表操作。

> 参考：[https://mp.weixin.qq.com/s/fNN77OxZbokcl7ax1tdZBA](https://mp.weixin.qq.com/s/fNN77OxZbokcl7ax1tdZBA)


# MySQL 读写分离

## 读写分离延迟如何解决
技术上没想到方法。业务上如果要求强一致性，就都读主库，如果不要求强一致性，就读从库。

