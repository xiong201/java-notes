-  衡量指标 

- - TPS：Transaction Per Second（每秒传输事务处理个数），指服务器每秒处理的事务数。

- - QPS：Queries Per Second（每秒查询处理量）

-  常用工具 

- - MySqlSlap：官方提供的MySQL5.1.4版本开始压力测试工具。测试MySQL服务器瓶颈。



# 1.MySQL逻辑架构



![image-20221028161910535](https://notes-img2022.oss-cn-shenzhen.aliyuncs.com/img/image-20221028161910535.png)



第一层结构主要处理客户端与mysql服务端的连接、授权认证、安全等；第二层是Mysql服务端的核心，功能包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数字和加密函数），跨存储引擎的存储过程、触发器、视图等都在这一层实现；第三层的存储引擎主要负责数据存储和提取，存储引擎不会去解析sql，不同存储引擎之间不会通讯，只会简单地响应上层服务器的请求



## 1.1 连接管理与安全性



### 处理流程



![image-20221028161932770](https://notes-img2022.oss-cn-shenzhen.aliyuncs.com/img/image-20221028161932770.png)



-  每个连接的查询都在一个进程中的线程完成。 

-  服务器负责缓存线程，所以服务层不需要为每个连接新建线程 



### 认证流程



![image-20221028161946668](https://notes-img2022.oss-cn-shenzhen.aliyuncs.com/img/image-20221028161946668.png)



连接到服务器，服务器需要对其进行验证，也就是用户名、IP、密码验证，一旦连接成功，还要验证是否具有执行某个特定查询的权限（例如，是否允许客户端对某个数据库某个表的某个操作）



## 1.2 优化与执行



![image-20221028162002399](https://notes-img2022.oss-cn-shenzhen.aliyuncs.com/img/image-20221028162002399.png)



-  在解析查询之前，服务器会“询问”是否进行了查询缓存(只能缓存SELECT语句和相应结果)。缓存过的直接返回结果，未缓存的就需要进行解析查询，优化，重新执行返回结果。 

-  解析查询时会创建一个内部数据结构(树)，然后对其进行各种优化。 

-  优化:重写查询，决定查询的读表顺序，选择需使用的索引。 



# 2.MySQL存储引擎



查看所有存储引擎：`SHOW ENGINES`



查看当前默认的存储引擎：`show variables like '%storage_engine%';`



## 2.1 存储引擎-MyISAM



MySQL 5.5以前默认的存储引擎。



有三个文件：



- frm：存储表结构，任何存储引擎都具备

- myd：数据库文件

- myi：索引文件



特性：



- 并发性与锁级别：表级锁

- 支持全文索引

- 支持数据压缩



适用场景



- 非事务型应用（数据仓库，报表，日志数据）。MyISAM 不支持事务

- 只读类应用。MyISAM 查询速度比InnoDB快

- 空间类应用（空间函数，坐标）



## 2.2  存储引擎-InnoDB



MySQL 5.5版本后默认使用InnoDB引擎。



innodb_file_per_table参数设置表空间使用类型：



- ON：独立表空间，tablename.ibd

- OFF：系统表空间：ibdataX



MySQL5.6以前默认为系统表空间，后面版本默认使用独立表空间（建议使用独立表空间）。系统表空间和独立表空间区别：



- 系统表空间无法简单收缩文件大小，独立表空间可以通过optimize table收缩系统文件

- 系统表空间会产生IO瓶颈，独立表空间可以同时向多个文件刷新数据。



InnoDB引擎特性：



- InnoDB是一种事务型存储引擎

- 支持事务的ACID特性

- Redo Log和Undo Log

- InnoDB支持行级锁（并发程度更高）



## 2.3 InnoDB和MyISAM区别（重要）

| 对比项 | MyISAM                                                       | InnoDB                           |
| ------ | ------------------------------------------------------------ | -------------------------------- |
| 外键   | 不支持                                                       | 支持                             |
| 事务   | **MyISAM** 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快。不支持事务 | 支持                             |
| 行表锁 | 只支持表级锁                                                 | 支持行级锁和表级锁，默认为行级锁 |



# 3.MySQL 事务



## 什么是事务



事务是逻辑上的一组操作，组成事务的各个执行单位，操作要么全部成功，要么全部失败。



## 事务的特性



事务具有四个特性，称为ACID特性



- 原子性：事务不可分割的，事务中操作要么全部成功，要么全部不成功。

- 一致性：事务执行前后数据的完整性要保持一致。

- 隔离型：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的

- 持久性：事务被提交后，就永久的保存在数据库中，即使是数据库发生故障也不会产生影响。



## 并发事务带来的问题



-  **脏读（Dirty read）:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。 

-  **丢失修改（Lost to modify）:**  指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。   例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
  **不可重复读（Unrepeatableread）:** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
  **幻读（Phantom read）:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。 



**不可重复读和幻读区别：**



不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。



## 事务的隔离级别



- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。

- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。

- **REPEATABLE-READ(可重复读)：**  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。

- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

| 隔离级别         | 脏读 | 不可重复读 | 幻影读 |
| ---------------- | ---- | ---------- | ------ |
| READ-UNCOMMITTED | √    | √          | √      |
| READ-COMMITTED   | ×    | √          | √      |
| REPEATABLE-READ  | ×    | ×          | √      |
| SERIALIZABLE     | ×    | ×          | ×      |



MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。我们可以通过`SELECT @@tx_isolation;`命令来查看



```plain
mysql> SELECT @@tx_isolation;
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+
```



## 事务的语法



- 开启事务 

- - begin

- - start transaction

- - begin work

- 事务回滚  rollback

- 事务提交  commit

- 还原点 savepoint



MySQL默认自动提交事务。通过`select @@autocommit`





# 4.MySQL锁





锁是计算机协调多个进场和线程并发访问某一资源的机制。



MySQL不同的存储引擎支持不同的锁机制。



**MyISAM 和 InnoDB 存储引擎使用的锁**



- MyISAM 采用表级锁(table-level locking)。

- InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁



**表级锁和行级锁对比：**



- **表级锁：** MySQL 中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。

- **行级锁：** MySQL 中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。



## 1.1 MyISAM表级锁



MySQL的表级锁有两种模式



-  表共享读锁 

```sql
lock table 表名 read
```

 

-  表独占写锁 

```sql
lock table 表名 write
```

 



总结：



- 对MylSAM表的读操作， 不会阻塞其他用户对同表的读请求， 但会阻塞对同一表的写请求

- 对MylSAM表的读操作， 不会阻塞当前session对表读， 当对表进行修改会保存

- 一个session使用LOCK TABLE命令给表f加了读锁， 这个session可以查询锁定表中的记录， 但更新或访问其他表都会提示错误；

- 另外一个session可以查询表中的记录， 但更新就会出现锁等待

- 对MylSAM表的写操作， 则会阻塞其他用户对同一表的读和写操作

- 对 MylSAM表的写操作， 当前session可以对本表做CRUD,但对其他表进行操作会报错



## 1.2 InnoDB锁



### 1.2.1 InnoDB行锁



行锁分为：



- 共享锁（读锁）：当一个事务对某几行上读锁时，允许其他事务对这几行进行读操作，但不允许其进行写操作，也不允许其他事务给这几行上排他锁，但允许上读锁。 

- - 语法：`lock in share mode`

- - 例如：`select * from 表 where 条件 lock in share mode`

- 排它锁（写锁）：当一个事务对某几个上写锁时，不允许其他事务写，但允许读。更不允许其他事务给这几行上任何锁。包括写锁。 

- - 语法：`for update`

- - 例如： `select * from 表 where 条件 for update`



注意：



- 两个事务不能锁同一个索引

- insert,delete,update在事务中都会自动默认加上排它锁。

- 行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了。



### 1.2.2 innoDB表锁



和MyISAM差别不大，但是开启一个新事务的时候会解锁表。



如果是读锁 `lock table tablename READ`，在同一个session中，插入和修改会报错，在不同session中会继续等待，直到解锁才会执行。在同一个session中，对另外的表的所有操作都会报错。





# 5.SQL优化

## 1.数据库优化的目的



1. 避免出现页面访问错误 

- - 由于数据库连接tomeout页面出现5xx错误

- - 由于慢查询造成页面无法加载

- - 由于阻塞造成数据无法提交

1. 增加数据库的稳定性 

- - 很多数据库问题都是由于低效的查询引起的

1. 优化用户体验 

- - 流畅页面的访问速度

- - 良好的网站功能体验



## 2.数据库优化的方式

![image-20221028162411200](https://notes-img2022.oss-cn-shenzhen.aliyuncs.com/img/image-20221028162411200.png)





### 2.1 SQL语句优化



#### 2.1.1 慢查询日志



慢查询日志就是**查询慢的日志**，是指mysql记录所有执行超过long_query_time参数设定的时间阈值的SQL语句的日志。可以帮助我们进行SQL优化。默认情况下，慢查询日志是关闭的。



##### 慢查询基本配置



- **slow_query_log**：是否开启慢查询日志

- **slow_query_log_file**：设置慢查询日志文件地址（默认和数据文件放一起）

- **long_query_time**：指定记录慢查询日志SQL执行时间得伐值（单位：秒，默认10秒）。查询超过这个值将会被记录到日志。

- **log_queries_not_using_indexes**：是否记录未使用索引的SQL

- **log_output**：日志存放的地方【TABLE】【FILE】【FILE,TABLE】



查看配置



```plain
show variables like 'slow_query_log';    //查看是否开启慢查日志
```



设置配置



```plain
set global slow_query_log_file = 'xxx' //设置慢查日志的文件地址

set global log_queries_not_using_indexes=on;    //是否把没有使用sql索引记录到慢查日志中

set global long_query_time=1;    //设置慢查日志的时间，查寻超过多少秒记录(单位：秒)
```



##### 慢查询日志解读



从慢查询日志里面摘选一条慢查询日志，数据组成如下





把为解读放吧，慢查询格式显示







第一行：用户名 、用户的IP信息、线程ID号



第二行：执行花费的时间【单位：毫秒】



第三行：执行获得锁的时间



第四行：获得的结果行数



第五行：扫描的数据行数



第六行：这SQL执行的具体时间



第七行：具体的SQL语句



##### 慢查询日志分析工具



###### mysqldumpslow



常用的慢查询日志分析工具，汇总除查询条件外其他完全相同的SQL，并将分析结果按照参数中所指定的顺序输出。



**注意**：要想运行mysqldumpslow.pl，需要下载perl编译器。



**语法**：



```plain
mysqldumpslow -s r -t 10 slow-mysql.log
-s order (c,t,l,r,at,al,ar) 
         c:总次数
         t:总时间
         l:锁的时间
         r:总数据行
         at,al,ar  :t,l,r平均数  【例如：at = 总时间/总次数】

  -t  top   指定取前面几天作为结果输出
```



###### pt-query-digest



##### 如何通过慢查日志发现有问题的SQL





#### 2.1.2 通过explain查询和分析SQL的执行计划



##### 1 什么是执行计划



使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈



##### 2 执行计划作用



-  表的读取顺序 

-  数据读取操作的操作类型 

-  哪些索引可以使用 

-  哪些索引被实际使用 

-  表之间的引用 

-  每张表有多少行被优化器查询 



##### 3 执行计划语法



执行计划的语法其实非常简单： 在SQL查询的前面加上EXPLAIN关键字就行。



比如：`EXPLAIN select * from table1`



##### 4 执行计划详解



`Explain` 执行计划包含字段信息如下：分别是 `id`、`select_type`、`table`、`partitions`、`type`、`possible_keys`、`key`、`key_len`、`ref`、`rows`、`filtered`、`Extra` 12个字段。





###### id



表示查询中执行select子句或者操作表的顺序，`**id**`**的值越大，代表优先级越高，越先执行**。`id`大致会出现 3种情况：



- **id相同**：看到三条记录的`id`都相同，可以理解成这三个表为一组，具有同样的优先级，执行顺序由上而下，具体顺序由优化器决定。

- **id不同**：如果我们的 `SQL` 中存在子查询，那么 `id`的序号会递增，`id`值越大优先级越高，越先被执行 。

- **以上两种同时存在**：相同`id`划分为一组，这样就有三个组，同组的从上往下顺序执行，不同组 `id`值越大，优先级越高，越先执行。



###### select_type



`select_type`：表示 `select` 查询的类型，主要是用于区分各种复杂的查询，例如：`普通查询`、`联合查询`、`子查询`等。



- SIMPLE：表示最简单的 select 查询语句，也就是在查询中不包含子查询或者 `union`交并差集等操作。

- PRIMARY：当查询语句中包含任何复杂的子部分，最外层查询则被标记为`PRIMARY`。

- SUBQUERY：当 `select` 或 `where` 列表中包含了子查询，该子查询被标记为：`SUBQUERY` 。

- DERIVED：表示包含在`from`子句中的子查询的select，在我们的 `from` 列表中包含的子查询会被标记为`derived` 。

- UNION：如果`union`后边又出现的`select` 语句，则会被标记为`union`；若 `union` 包含在 `from` 子句的子查询中，外层 `select` 将被标记为 `derived`。

- UNION RESULT：代表从`union`的临时表中读取数据，而`table`列的`<union1,4>`表示用第一个和第四个`select`的结果进行`union`操作。



###### table



查询的表名，并不一定是真实存在的表，有别名显示别名，也可能为临时表



###### partitions



查询时匹配到的分区信息，对于非分区表值为`NULL`，当查询的是分区表时，`partitions`显示分区表命中的分区情况。



###### type



type：查询使用了何种类型，它在 SQL优化中是一个非常重要的指标，以下性能从好到坏依次是：`system > const > eq_ref > ref > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL`



- system：表仅有一行记录时(系统表)，数据量很少，往往不需要进行磁盘IO，速度非常快。

- const：表示查询时命中 `primary key` 主键或者 `unique` 唯一索引，或者被连接的部分是一个常量(`const`)值。这类扫描效率极高，返回数据量少，速度非常快。

- eq_ref：查询时命中主键`primary key` 或者 `unique key`索引， `type` 就是 `eq_ref`。

- ref：区别于`eq_ref` ，`ref`表示使用非唯一性索引，会找到很多个符合条件的行。

- ref_or_null：这种连接类型类似于 ref，区别在于 `MySQL`会额外搜索包含`NULL`值的行。

- index_merge：使用了索引合并优化方法，查询使用了两个以上的索引。

- unique_subquery：替换下面的 `IN`子查询，子查询返回不重复的集合。

- index_subquery：区别于`unique_subquery`，用于非唯一索引，可以返回重复值。

- range：使用索引选择行，仅检索给定范围内的行。简单点说就是针对一个有索引的字段，给定范围检索数据。在`where`语句中使用 `bettween...and`、`<`、`>`、`<=`、`in` 等条件查询 `type` 都是 `range`。

- index：`Index` 与`ALL` 其实都是读全表，区别在于`index`是遍历索引树读取，而`ALL`是从硬盘中读取。

- ALL：将遍历全表以找到匹配的行，性能最差。



###### possible_keys



表示在`MySQL`中通过哪些索引，能让我们在表中找到想要的记录，一旦查询涉及到的某个字段上存在索引，则索引将被列出，**但这个索引并不定一会是最终查询数据时所被用到的索引**。



###### key



区别于`possible_keys`，key是查询中实际使用到的索引，若没有使用索引，显示为`NULL`。



当 `type` 为 `index_merge` 时，可能会显示多个索引。



###### key_len



`key_len`：表示查询用到的索引长度（字节数），原则上长度越短越好 。



- 单列索引，那么需要将整个索引长度算进去；

- 多列索引，不是所有列都能用到，需要计算查询中实际用到的列。



**注意：**`**key_len**`**只计算**`**where**`**条件中用到的索引长度，而排序和分组即便是用到了索引，也不会计算到**`**key_len**`**中**。



###### ref



常见的有：`const`，`func`，`null`，字段名。



- 当使用常量等值查询，显示`const`，

- 当关联查询时，会显示相应关联表的`关联字段`

- 如果查询条件使用了`表达式`、`函数`，或者条件列发生内部隐式转换，可能显示为`func`

- 其他情况`null`



###### rows



以表的统计信息和索引使用情况，估算要找到我们所需的记录，需要读取的行数。



这是评估`SQL` 性能的一个比较重要的数据，`mysql`需要扫描的行数，很直观的显示 `SQL` 性能的好坏，一般情况下 `rows` 值越小越好。



###### filtered



`filtered` 这个是一个百分比的值，表里符合条件的记录数的百分比。简单点说，这个字段表示存储引擎返回的数据在经过过滤后，剩下满足条件的记录数量的比例。



在`MySQL.5.7`版本以前想要显示`filtered`需要使用`explain extended`命令。`MySQL.5.7`后，默认`explain`直接显示`partitions`和`filtered`的信息。



###### Extra



不适合在其他列中显示的信息，`Explain` 中的很多额外的信息会在 `Extra` 字段显示。



- Using index：我们在相应的 `select` 操作中使用了覆盖索引，通俗一点讲就是查询的列被索引覆盖，使用到覆盖索引查询速度会非常快，`SQl`优化中理想的状态。

- Using where：查询时未找到可用的索引，进而通过`where`条件过滤获取所需数据，但要注意的是并不是所有带`where`语句的查询都会显示`Using where`。

- Using temporary：表示查询后结果需要使用临时表来存储，一般在排序或者分组查询时用到。

- Using filesort：表示无法利用索引完成的排序操作，也就是`ORDER BY`的字段没有索引，**通常这样的SQL都是需要优化的。**

- Using join buffer：在我们联表查询的时候，如果表的连接条件没有用到索引，需要有一个连接缓冲区来存储中间结果。

- Impossible where：表示在我们用不太正确的`where`语句，导致没有符合条件的行。

- No tables used：我们的查询语句中没有`FROM`子句，或者有 `FROM DUAL`子句。



### 2.2 索引优化



#### 索引是什么



索引是帮助MySQL高效获取数据的数据结构。



#### 索引分类



-  **普通索引：**即一个索引只包含单个列，一个表可以有多个单列索引 

-  **唯一索引：**索引列的值必须唯一，但允许有空值 

-  **复合索引：**即一个索引包含多个列 

-  **聚簇索引(****聚集索引)**：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。 

-  **非聚簇索引：**不是聚簇索引，就是非聚簇索引 



#### 索引语法



-  查看索引 

```sql
show index from tablename
```

 

-  创建索引 

```sql
CREATE  [UNIQUE ] INDEX indexName ON mytable(columnname(length));
ALTER TABLE 表名 ADD  [UNIQUE ]  INDEX [indexName] ON (columnname(length))
```

 

-  删除索引 

```sql
DROP INDEX [indexName] ON mytable;
```

 



#### 选择合适的列建立索引



1.  在where，group by，order by，on从句中出现的列 

1.  索引字段越小越好(因为数据库的存储单位是页，一页中能存下的数据越多越好) 

1.  离散度高得列放在联合索引前面
   查看离散度 通过统计不同的列值来实现 count越大 离散程度越高 唯一值越多 

```plain
select count(distinct customer_id), count(distinct staff_id) from payment;
```


查看离散度 通过统计不同的列值来实现 count越大 离散程度越高 唯一值越多 



#### 索引的维护及优化



由于用户变更等可能性，有些索引不再使用，因此需要删除不用索引。



##### 重复及冗余索引



过多的索引不但影响写入，而且影响查询，索引越多，分析越慢
如何找到重复和多余的索引，主键已经是索引了，所以primay key 的主键不用再设置unique唯一索引了
冗余索引，是指多个索引的前缀列相同，innodb会在每个索引后面自动加上主键信息









**冗余索引查询工具：pt-duplicate-key-checke**





##### 删除无用索引





### 2.3 数据库结构优化



#### 选择合适的数据类型



选择合适的数据类型



1. 使用可存下数据的最小的数据类型

1. 使用简单地数据类型，Int要比varchar类型在mysql处理上更简单

1. 尽可能使用not null定义字段，这是由innodb的特性决定的，因为非not null的数据可能需要一些额外的字段进行存储，这样就会增加一些IO。可以对非null的字段设置一个默认值

1. 尽量少用text，非用不可最好分表，将text字段存放到另一张表中，在需要的时候再使用联合查询，这样可提高查询主表的效率 

- - 例子1、用Int存储日期时间
    from_unixtime()可将Int类型的时间戳转换为时间格式
    select from_unixtime(1392178320); 输出为 2014-02-12 12:12:00
    unix_timestamp()可将时间格式转换为Int类型
    select unix_timestamp('2014-02-12 12:12:00'); 输出为1392178320

- - 例子2
    存储IP地址——bigInt
    利用inet_aton(),inet_ntoa()转换
    select inet_aton('192.169.1.1'); 输出为3232301313
    select inet_ntoa(3232301313); 输出为192.169.1.1



#### 数据库表范式化优化



表的范式化即数据库设计的规范化：数据表不存在非关键字段对任意关键字段的传递函数依赖，则符合第三范式。
可以将一张数据表进行拆分，来满足第三范式的要求。
设计表的时候符合范式化是为了：减少数据冗余、减少表的插入、更新、删除异常
不符合第三范式要求的表存在以下问题：



1.  数据冗余:（分类、分类描述）对于每一个商品都会进行记录 

1.  数据插入异常 

1.  数据更新异常 

1.  数据删除异常 

