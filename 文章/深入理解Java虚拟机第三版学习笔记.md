# 第一部分 走进Java

## 第1章 走进Java

### Java 技术体系

按 Java 各个组成部分的功能划分：

- Java 程序设计语言
- 各个平台上的 Java 虚拟机实现
- Class 文件格式
- Java 类库 API
- 来自商业机构和开源社区的第三方 Java 类库

![image-20221126110507812](https://notes-img2022.oss-cn-shenzhen.aliyuncs.com/img/image-20221126110507812.png)

**JDK**：Java 程序开发的最小环境。包括 Java 程序设计语言、Java 虚拟机、Java 类库。

**JRE**：支持 Java 程序运行的标准环境。包括 Java 类库 API 中的 Java SE API 子集合 和 Java 虚拟机。



### OpenJDK和OracleJDK

OpenJDK：是Sun公司在2006年开源（源码开放）的版本。可以商用。

OracleJDK：是商用版本。个人使用免费，商用收费。

两者非常接近，共用了绝大部分相同的代码。

![image-20221126123256448](https://notes-img2022.oss-cn-shenzhen.aliyuncs.com/img/image-20221126123256448.png)





# 第二部分 自动内存管理

## 第2章 Java 内存区域与内存溢出异常

### 运行时数据区域

线程共享：

- 方法区
- 堆



线程独享：

- 程序计数器
- 虚拟机栈
- 本地方法栈

![image-20221126134009363](https://notes-img2022.oss-cn-shenzhen.aliyuncs.com/img/image-20221126134009363.png)



#### 程序计数器

程序计数器是**当前线程所执行的字节码的行号指示器**。

字节码解释器就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。

为了线程切换后能恢复到正确的执行位置，每条线程都有独立的程序计数器。所以程序计数器是**线程私有**的。

当线程在执行一个Java方法，这个计数器记录的是正在执行虚拟机字节码指令的地址，如果执行的是本地（Native）方法，这个计数器值则应为空。

**程序计数器是唯一一个不会出现OutOfMemoryError情况的内存区域**。



#### Java 虚拟机栈

Java 虚拟机栈也是**线程私有**的。

Java虚拟机栈描述的是**Java方法执行**的线程内存模型。每个方法被执行的时候，Java虚拟机都会同步创建一个**栈帧**用于**存储局部变量表、操作数栈、动态链接、方法出库等信息**。每一个方法被调用直至执行完毕的过程，就是一个栈帧在虚拟机栈中从入栈到出栈的过程。

**局部变量表**存放了**编译期可知**的各种**Java虚拟机基本数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和**returnAddress类型**（指向了一条字节码指令的地址）。

这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表的大小（指变量槽的数量，具体的内存空间由虚拟机自行决定）是在编译器确定的，在运行期间并不会发生改变。

Java 虚拟机栈有两类异常情况：**如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常**。

**HotSpot虚拟机的栈容量是不可以动态扩展**的，所以不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常。但是如果**线程申请栈空间不成功还是会出现OOM异常**。



#### 本地方法栈

本地方法栈和Java虚拟机栈作用相似，区别是虚拟机栈是为虚拟机执行Java方法服务的，而本地方法栈是**为虚拟机使用到的本地（Native）方法服务的**。

本地方法栈由具体的虚拟机实现，HotSpot虚拟机将本地方法栈和虚拟机栈合二为一。

本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。



#### Java 堆

对于Java应用程序来说，Java堆是虚拟机管理的内存中最大的一块。是所有**线程共享**的一块内存区域。在虚拟机启动时创建。

Java 堆的唯一目的就是**存放对象实例**。**几乎**所有的对象实例都在这分配内存。

java堆是**垃圾收集器管理的内存区域**。因此也被称为GC堆。从回收内存角度看，大部分垃圾收集器都是基于分代收集理论设计的。分为新年代、老年代、永久代。在G1收集器出现后，上面的分代理论就不那么准确了。

从分配内存来看，所有线程共享的Java堆可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），提升对象分配时的效率。

Java堆可以处于物理上不连续的内存空间，但是逻辑上要视为连续的。

Java堆可以实现成固定大小，也可以是可扩展的，主流的Java虚拟机都是可扩展的（通过参数-Xmx和-Xms设定）。**如果在Java堆中没有内存完成实例分配，并且堆也无法扩展时，Java虚拟机会抛出OutOfMemoryError异常**。

#### 方法区

方法区是**线程共享**的内存区域，用于存储已被虚拟机加载
的**类型信息、常量、静态变量、即时编译器编译后的代码缓存等**数据。

**永久代并不等于方法区，可以说永久代实现方法区**。仅仅当时HotSpot虚拟机将收集器的分代设计扩展至方法区，便于垃圾收集器管理这部分内存。但对其他虚拟机来说，并不存在永久代这个概念。使用**永久代实现方法区会更容易遇到内存溢出的问题**（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题）。JDK7的HotSpot将原本放在永久代的字符串常量池、静态变量移出**，到了JDK8，永久代被完全废弃，改用本地内存实现的元空间来代替**，将JDK7永久代中还剩余的内容全部移到元空间。

这个区域的垃圾收集行为较少，主要内存回收目标是对常量池的回收和对类型的卸载。方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。



#### 运行时常量池

运行时常量池是方法区的一部分。Class文件的常量池表用于存放编译期间生成的各种字面量和符号引用，这些内容将在类加载后存放到方法区的运行时常量池。

运行时常量池另外一个重要特征是具备动态性，运行期间也可以将新的常量放入池中，这种特性利用比较多的是String类的intern()方法。

当常量池无法再申请到内存时会抛出OutOfMemoryError异常。



#### 直接内存

直接内存并不是虚拟机运行时数据区的一部分。但是这部分内存也被频繁使用，而且也可能导致OutOfMemoryError异常出现。

JDK1.4的NIO类就使用到这部分内存。

直接内存不是受到Java堆大小的限制，但是还是会受到本机总内存大小及处理器寻址空间的限制。如果配置虚拟机参数时，忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出OutOfMemoryError异常。



### HotSpot 虚拟机对象探秘

深入探讨一下HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。

#### 对象的创建

虚拟机创建一个普通Java的过程：

##### 1.类加载检查

当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程

##### 2.分配内存

虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。假设Java堆中内存是**绝对规整**的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“**指针碰撞**”（Bump ThePointer）。但如果Java堆中的**内存并不是规整**的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录这种分配方式称为“**空闲列表**”（Free List）。选择**哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定**。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。对于并发情况下发生的线程安全问题，有两种解决方法：一种是对分配内存空间的动作进行同步处理——+·



##### 3.初始化零值：

##### 4.设置对象头：

##### 5.执行`<init>()`方法：





