# 相关概念

## STW



GC如何需要停止所有应用程序的进程称为STW（**Stop-the-world** ）。



## saft point（安全点）



挂起线程的点

- 从全局观点来看，所有线程必须在GC 运行前，在一个safepoint处阻塞（block）。
- 从局部观点来看，safepoint是一个代码块中特殊的一点，该处正在执行的线程可以因GC而阻塞。
- GC的标记阶段需要stop the world，让所有Java线程挂起，这样JVM才可以安全地来标记对象。

**safepoint**可以用来实现让所有Java线程挂起的需求。这是一种 **"主动式"**(Voluntary Suspension)的实现

safe point指的特定位置主要有:

1. 循环的末尾 (防止大循环的时候一直不进入safepoint，而其他线程在等待它进入safepoint)
2. 方法返回前
3. 调用方法的call之后
4. 抛出异常的位置



## 垃圾回收类型

- 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。Minor GC 非常频繁，回收速度比较快。

- 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集， Major GC 一般比 Minor GC慢 10 倍以上。目前只有CMS收集器会有单独收集老年代的行为。

- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。

- 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。









# 对象已经死亡？

## 引用计数算法

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。

**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。** 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。

```java
public class ReferenceCountingGc {
    Object instance = null;
	public static void main(String[] args) {
		ReferenceCountingGc objA = new ReferenceCountingGc();
		ReferenceCountingGc objB = new ReferenceCountingGc();
		objA.instance = objB;
		objB.instance = objA;
		objA = null;
		objB = null;

	}
}

```





## 可达性分析算法

这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

![image-20230408111009982](https://notes-img2022.oss-cn-shenzhen.aliyuncs.com/img/image-20230408111009982.png)



可作为 GC Roots 的对象包括下面几种:

- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象

## 不可达的对象并非“非死不可”

即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。

被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。





# 垃圾收集算法



## 标记-清除算法

该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题： 

1. **效率问题**
2. **空间问题（标记清除后会产生大量不连续的碎片）**

![image-20230408111309453](https://notes-img2022.oss-cn-shenzhen.aliyuncs.com/img/image-20230408111309453.png)



## 标记-复制算法

为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。**标记-复制算法虽然解决了碎片化问题，但是存在空间浪费。**

![image-20230408111351728](https://notes-img2022.oss-cn-shenzhen.aliyuncs.com/img/image-20230408111351728.png)



## 标记-整理算法

根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

![image-20230408111541970](https://notes-img2022.oss-cn-shenzhen.aliyuncs.com/img/image-20230408111541970.png)

## 分代收集算法

当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

**比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**









# 垃圾收集器

串行收集器：使用**单线程**进行垃圾回收的收集器，每次回收时，串行收集器只有一个工作线程，对于**并行能力较弱**的计算机来说，串行收集器的专注性和独占性往往有更好的性能表现。

串行收集器：

- Serial 收集器
- Serial Old 收集器

并行收集器：

- Parallel Scavenge 收集器

- Parallel Old 收集器
- ParNew 收集器
- CMS 收集器
- G1 收集器



有 7 种不同的垃圾回收器，它们分别用于不同分代的垃圾回收。

- 新生代回收器：Serial、ParNew、Parallel Scavenge
- 老年代回收器：Serial Old、Parallel Old、CMS
- 整堆回收器：G1



可选的搭配方案：

| 新生代            | 老年代       |
| ----------------- | ------------ |
| Serial            | Serial Old   |
| Serial            | CMS          |
| ParNew            | Serial Old   |
| ParNew            | CMS          |
| Parallel Scavenge | Serial Old   |
| Parallel Scavenge | Parallel Old |
| G1                | G1           |



## Serial 收集器

Serial收集器是一个新生代收集器，单线程执行，使用**标记-复制算法**。它在进行垃圾收集时，必须暂停其他所有的工作线程(用户线程)。是JVM Client模式下默认的新生代收集器。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的**单线程收集效率**。

![image-20230405162406014](https://notes-img2022.oss-cn-shenzhen.aliyuncs.com/img/image-20230405162406014.png)



## Serial Old 收集器

Serial收集器的老年代版本，它同样是一个单线程收集器，使用 **“标记-整理”算法**。也会暂定所有用户线程。



## Parallel Scavenge 收集器



配置参数：**-XX:+UseParallelGC**

目标是达到一个可控制的吞吐量（Throughput）。

吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）。

虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是99%。

![image-20230406075328810](https://notes-img2022.oss-cn-shenzhen.aliyuncs.com/img/image-20230406075328810.png)



特点：

- 新生代使用**并行回收收集器**，老年代使用**串行收集器**
- 吞吐量优先收集器
- 新生代收集器**复制算法**，是并行的多线程收集器。



## Parallel Old 收集器



配置参数：**-XX:+UseParallelOldGC**

特点：

- Parallel Scavenge收集器的老年代版本，使用多线程和 **“标记-整理”算法**。
- 在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑**Parallel Scavenge**加**Parallel Old**收集器。

## ParNew 收集器

配置参数：**-XX:+UseParNewGC**

配置参数：**-XX:ParallelGCThreads=n** 设置并行收集器收集时使用的并行收集线程数。一般最好和计算机的CPU相当

特点：

- 新生代并行（ParNew），老年代串行（Serial Old）
- Serial收集器的多线程版本
- 单CPU性能并不如Serial，因为存在线程交互的开销

![image-20230406075821025](https://notes-img2022.oss-cn-shenzhen.aliyuncs.com/img/image-20230406075821025.png)



## CMS 收集器

配置参数：**-XX:+UseConcMarkSweepGC** 应用CMS收集器。

尽管CMS收集器采用的是 **并发回收（非独占式）** ，但是在其**初始标记**和**重新标记**这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长。

因此可以说明 **目前所有的垃圾收集器都做不到完全不需要“stop-the-World** ， **只是尽可能地缩短暂停时间** 。

由于最耗费时间的**并发标记**与**并发清除**阶段都不需要暂停工作，所以整体的回收是低停顿的。

另外，由于在垃圾收集阶段**用户线程没有中断** ，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。

**特点:**

- 低延迟： 减少STW对用户体验的影响【响应时间和延迟要求高】
- 并发收集：可以同时执行用户线程
- CMS收集器 不能像其他收集器那样等到老年代几乎完全被填满了再进行收集 ，而是当堆内存使用率达到某一阈值时，便开始进行回收。
- CMS收集器的垃圾收集算法采用的是标记清除算法。
- 会产生内存碎片，导致并发清除后，用户线程可用的空间不足。
- CMS收集器对CPU资源非常敏感。

CMS垃圾回收器：

CMS整个过程比之前的收集器要复杂，整个过程分为 4 个主要阶段，即**初始标记阶段**、**并发标记阶段**、**重新标记阶段**和**并发清除阶段**。

> ( 涉及STW的阶段主要是：**初始标记** 和 **重新标记** )

- **初始标记**（Initial-Mark）阶段 ：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GCRoots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。【STW】

- **并发标记**（Concurrent-Mark）阶段 ：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。

- **重新标记**（Remark）阶段 ：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了 修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录 ，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。【STW】

- **并发清除**（Concurrent-Sweep）阶段 ：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

## G1 收集器

配置参数：**-XX:+UseG1Gc** 应用G1收集器

配置参数：**-XX:MaxGCPauseMillis** 指定最大停顿时间

配置参数：**-XX:ParallelGCThreads** 设置并行回收的线程数量

Garbage-First当今收集器技术发展的最前沿成果之一，G1是一款面向服务端应用的垃圾收集器。大内存，企业配置的垃圾收集器大多都是G1。

特点：

1. 并行与并发：充分利用多CPU、多核环境下的硬件优势
2. 分代收集：不需要其他收集器配合就能独立管理整个GC堆
3. 空间整合：“标记—整理”算法实现的收集器，局部上基于“复制”算法不会产生内存空间碎片
4. 可预测的停顿：能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒

![image-20230406080304552](https://notes-img2022.oss-cn-shenzhen.aliyuncs.com/img/image-20230406080304552.png)



G1收集器的运作大致可划分为以下几个步骤：

1. **初始标记**：标记一下GC Roots能直接关联到的对象，需要停顿线程，但耗时很短
2. **并发标记**：是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行
3. **最终标记**：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录
4. **筛选回收**：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划




